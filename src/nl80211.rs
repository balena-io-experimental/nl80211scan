/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const NL80211_GENL_NAME: &[u8; 8usize] = b"nl80211\0";
pub const NL80211_MULTICAST_GROUP_CONFIG: &[u8; 7usize] = b"config\0";
pub const NL80211_MULTICAST_GROUP_SCAN: &[u8; 5usize] = b"scan\0";
pub const NL80211_MULTICAST_GROUP_REG: &[u8; 11usize] = b"regulatory\0";
pub const NL80211_MULTICAST_GROUP_MLME: &[u8; 5usize] = b"mlme\0";
pub const NL80211_MULTICAST_GROUP_VENDOR: &[u8; 7usize] = b"vendor\0";
pub const NL80211_MULTICAST_GROUP_NAN: &[u8; 4usize] = b"nan\0";
pub const NL80211_MULTICAST_GROUP_TESTMODE: &[u8; 9usize] = b"testmode\0";
pub const NL80211_EDMG_BW_CONFIG_MIN: u32 = 4;
pub const NL80211_EDMG_BW_CONFIG_MAX: u32 = 15;
pub const NL80211_EDMG_CHANNELS_MIN: u32 = 1;
pub const NL80211_EDMG_CHANNELS_MAX: u32 = 60;
pub const NL80211_WIPHY_NAME_MAXLEN: u32 = 64;
pub const NL80211_MAX_SUPP_RATES: u32 = 32;
pub const NL80211_MAX_SUPP_HT_RATES: u32 = 77;
pub const NL80211_MAX_SUPP_REG_RULES: u32 = 128;
pub const NL80211_TKIP_DATA_OFFSET_ENCR_KEY: u32 = 0;
pub const NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY: u32 = 16;
pub const NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY: u32 = 24;
pub const NL80211_HT_CAPABILITY_LEN: u32 = 26;
pub const NL80211_VHT_CAPABILITY_LEN: u32 = 12;
pub const NL80211_HE_MIN_CAPABILITY_LEN: u32 = 16;
pub const NL80211_HE_MAX_CAPABILITY_LEN: u32 = 54;
pub const NL80211_MAX_NR_CIPHER_SUITES: u32 = 5;
pub const NL80211_MAX_NR_AKM_SUITES: u32 = 2;
pub const NL80211_MIN_REMAIN_ON_CHANNEL_TIME: u32 = 10;
pub const NL80211_SCAN_RSSI_THOLD_OFF: i32 = -300;
pub const NL80211_CQM_TXE_MAX_INTVL: u32 = 1800;
pub const NL80211_VHT_NSS_MAX: u32 = 8;
pub const NL80211_HE_NSS_MAX: u32 = 8;
pub const NL80211_KCK_LEN: u32 = 16;
pub const NL80211_KEK_LEN: u32 = 16;
pub const NL80211_KCK_EXT_LEN: u32 = 24;
pub const NL80211_KEK_EXT_LEN: u32 = 32;
pub const NL80211_REPLAY_CTR_LEN: u32 = 8;
pub const NL80211_CRIT_PROTO_MAX_DURATION: u32 = 5000;
pub const NL80211_VENDOR_ID_IS_LINUX: u32 = 2147483648;
pub const NL80211_NAN_FUNC_SERVICE_ID_LEN: u32 = 6;
pub const NL80211_NAN_FUNC_SERVICE_SPEC_INFO_MAX_LEN: u32 = 255;
pub const NL80211_NAN_FUNC_SRF_MAX_LEN: u32 = 255;
pub const NL80211_FILS_DISCOVERY_TMPL_MIN_LEN: u32 = 42;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub const nl80211_commands_NL80211_CMD_UNSPEC: nl80211_commands = 0;
pub const nl80211_commands_NL80211_CMD_GET_WIPHY: nl80211_commands = 1;
pub const nl80211_commands_NL80211_CMD_SET_WIPHY: nl80211_commands = 2;
pub const nl80211_commands_NL80211_CMD_NEW_WIPHY: nl80211_commands = 3;
pub const nl80211_commands_NL80211_CMD_DEL_WIPHY: nl80211_commands = 4;
pub const nl80211_commands_NL80211_CMD_GET_INTERFACE: nl80211_commands = 5;
pub const nl80211_commands_NL80211_CMD_SET_INTERFACE: nl80211_commands = 6;
pub const nl80211_commands_NL80211_CMD_NEW_INTERFACE: nl80211_commands = 7;
pub const nl80211_commands_NL80211_CMD_DEL_INTERFACE: nl80211_commands = 8;
pub const nl80211_commands_NL80211_CMD_GET_KEY: nl80211_commands = 9;
pub const nl80211_commands_NL80211_CMD_SET_KEY: nl80211_commands = 10;
pub const nl80211_commands_NL80211_CMD_NEW_KEY: nl80211_commands = 11;
pub const nl80211_commands_NL80211_CMD_DEL_KEY: nl80211_commands = 12;
pub const nl80211_commands_NL80211_CMD_GET_BEACON: nl80211_commands = 13;
pub const nl80211_commands_NL80211_CMD_SET_BEACON: nl80211_commands = 14;
pub const nl80211_commands_NL80211_CMD_START_AP: nl80211_commands = 15;
pub const nl80211_commands_NL80211_CMD_NEW_BEACON: nl80211_commands = 15;
pub const nl80211_commands_NL80211_CMD_STOP_AP: nl80211_commands = 16;
pub const nl80211_commands_NL80211_CMD_DEL_BEACON: nl80211_commands = 16;
pub const nl80211_commands_NL80211_CMD_GET_STATION: nl80211_commands = 17;
pub const nl80211_commands_NL80211_CMD_SET_STATION: nl80211_commands = 18;
pub const nl80211_commands_NL80211_CMD_NEW_STATION: nl80211_commands = 19;
pub const nl80211_commands_NL80211_CMD_DEL_STATION: nl80211_commands = 20;
pub const nl80211_commands_NL80211_CMD_GET_MPATH: nl80211_commands = 21;
pub const nl80211_commands_NL80211_CMD_SET_MPATH: nl80211_commands = 22;
pub const nl80211_commands_NL80211_CMD_NEW_MPATH: nl80211_commands = 23;
pub const nl80211_commands_NL80211_CMD_DEL_MPATH: nl80211_commands = 24;
pub const nl80211_commands_NL80211_CMD_SET_BSS: nl80211_commands = 25;
pub const nl80211_commands_NL80211_CMD_SET_REG: nl80211_commands = 26;
pub const nl80211_commands_NL80211_CMD_REQ_SET_REG: nl80211_commands = 27;
pub const nl80211_commands_NL80211_CMD_GET_MESH_CONFIG: nl80211_commands = 28;
pub const nl80211_commands_NL80211_CMD_SET_MESH_CONFIG: nl80211_commands = 29;
pub const nl80211_commands_NL80211_CMD_SET_MGMT_EXTRA_IE: nl80211_commands = 30;
pub const nl80211_commands_NL80211_CMD_GET_REG: nl80211_commands = 31;
pub const nl80211_commands_NL80211_CMD_GET_SCAN: nl80211_commands = 32;
pub const nl80211_commands_NL80211_CMD_TRIGGER_SCAN: nl80211_commands = 33;
pub const nl80211_commands_NL80211_CMD_NEW_SCAN_RESULTS: nl80211_commands = 34;
pub const nl80211_commands_NL80211_CMD_SCAN_ABORTED: nl80211_commands = 35;
pub const nl80211_commands_NL80211_CMD_REG_CHANGE: nl80211_commands = 36;
pub const nl80211_commands_NL80211_CMD_AUTHENTICATE: nl80211_commands = 37;
pub const nl80211_commands_NL80211_CMD_ASSOCIATE: nl80211_commands = 38;
pub const nl80211_commands_NL80211_CMD_DEAUTHENTICATE: nl80211_commands = 39;
pub const nl80211_commands_NL80211_CMD_DISASSOCIATE: nl80211_commands = 40;
pub const nl80211_commands_NL80211_CMD_MICHAEL_MIC_FAILURE: nl80211_commands = 41;
pub const nl80211_commands_NL80211_CMD_REG_BEACON_HINT: nl80211_commands = 42;
pub const nl80211_commands_NL80211_CMD_JOIN_IBSS: nl80211_commands = 43;
pub const nl80211_commands_NL80211_CMD_LEAVE_IBSS: nl80211_commands = 44;
pub const nl80211_commands_NL80211_CMD_TESTMODE: nl80211_commands = 45;
pub const nl80211_commands_NL80211_CMD_CONNECT: nl80211_commands = 46;
pub const nl80211_commands_NL80211_CMD_ROAM: nl80211_commands = 47;
pub const nl80211_commands_NL80211_CMD_DISCONNECT: nl80211_commands = 48;
pub const nl80211_commands_NL80211_CMD_SET_WIPHY_NETNS: nl80211_commands = 49;
pub const nl80211_commands_NL80211_CMD_GET_SURVEY: nl80211_commands = 50;
pub const nl80211_commands_NL80211_CMD_NEW_SURVEY_RESULTS: nl80211_commands = 51;
pub const nl80211_commands_NL80211_CMD_SET_PMKSA: nl80211_commands = 52;
pub const nl80211_commands_NL80211_CMD_DEL_PMKSA: nl80211_commands = 53;
pub const nl80211_commands_NL80211_CMD_FLUSH_PMKSA: nl80211_commands = 54;
pub const nl80211_commands_NL80211_CMD_REMAIN_ON_CHANNEL: nl80211_commands = 55;
pub const nl80211_commands_NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL: nl80211_commands = 56;
pub const nl80211_commands_NL80211_CMD_SET_TX_BITRATE_MASK: nl80211_commands = 57;
pub const nl80211_commands_NL80211_CMD_REGISTER_FRAME: nl80211_commands = 58;
pub const nl80211_commands_NL80211_CMD_REGISTER_ACTION: nl80211_commands = 58;
pub const nl80211_commands_NL80211_CMD_FRAME: nl80211_commands = 59;
pub const nl80211_commands_NL80211_CMD_ACTION: nl80211_commands = 59;
pub const nl80211_commands_NL80211_CMD_FRAME_TX_STATUS: nl80211_commands = 60;
pub const nl80211_commands_NL80211_CMD_ACTION_TX_STATUS: nl80211_commands = 60;
pub const nl80211_commands_NL80211_CMD_SET_POWER_SAVE: nl80211_commands = 61;
pub const nl80211_commands_NL80211_CMD_GET_POWER_SAVE: nl80211_commands = 62;
pub const nl80211_commands_NL80211_CMD_SET_CQM: nl80211_commands = 63;
pub const nl80211_commands_NL80211_CMD_NOTIFY_CQM: nl80211_commands = 64;
pub const nl80211_commands_NL80211_CMD_SET_CHANNEL: nl80211_commands = 65;
pub const nl80211_commands_NL80211_CMD_SET_WDS_PEER: nl80211_commands = 66;
pub const nl80211_commands_NL80211_CMD_FRAME_WAIT_CANCEL: nl80211_commands = 67;
pub const nl80211_commands_NL80211_CMD_JOIN_MESH: nl80211_commands = 68;
pub const nl80211_commands_NL80211_CMD_LEAVE_MESH: nl80211_commands = 69;
pub const nl80211_commands_NL80211_CMD_UNPROT_DEAUTHENTICATE: nl80211_commands = 70;
pub const nl80211_commands_NL80211_CMD_UNPROT_DISASSOCIATE: nl80211_commands = 71;
pub const nl80211_commands_NL80211_CMD_NEW_PEER_CANDIDATE: nl80211_commands = 72;
pub const nl80211_commands_NL80211_CMD_GET_WOWLAN: nl80211_commands = 73;
pub const nl80211_commands_NL80211_CMD_SET_WOWLAN: nl80211_commands = 74;
pub const nl80211_commands_NL80211_CMD_START_SCHED_SCAN: nl80211_commands = 75;
pub const nl80211_commands_NL80211_CMD_STOP_SCHED_SCAN: nl80211_commands = 76;
pub const nl80211_commands_NL80211_CMD_SCHED_SCAN_RESULTS: nl80211_commands = 77;
pub const nl80211_commands_NL80211_CMD_SCHED_SCAN_STOPPED: nl80211_commands = 78;
pub const nl80211_commands_NL80211_CMD_SET_REKEY_OFFLOAD: nl80211_commands = 79;
pub const nl80211_commands_NL80211_CMD_PMKSA_CANDIDATE: nl80211_commands = 80;
pub const nl80211_commands_NL80211_CMD_TDLS_OPER: nl80211_commands = 81;
pub const nl80211_commands_NL80211_CMD_TDLS_MGMT: nl80211_commands = 82;
pub const nl80211_commands_NL80211_CMD_UNEXPECTED_FRAME: nl80211_commands = 83;
pub const nl80211_commands_NL80211_CMD_PROBE_CLIENT: nl80211_commands = 84;
pub const nl80211_commands_NL80211_CMD_REGISTER_BEACONS: nl80211_commands = 85;
pub const nl80211_commands_NL80211_CMD_UNEXPECTED_4ADDR_FRAME: nl80211_commands = 86;
pub const nl80211_commands_NL80211_CMD_SET_NOACK_MAP: nl80211_commands = 87;
pub const nl80211_commands_NL80211_CMD_CH_SWITCH_NOTIFY: nl80211_commands = 88;
pub const nl80211_commands_NL80211_CMD_START_P2P_DEVICE: nl80211_commands = 89;
pub const nl80211_commands_NL80211_CMD_STOP_P2P_DEVICE: nl80211_commands = 90;
pub const nl80211_commands_NL80211_CMD_CONN_FAILED: nl80211_commands = 91;
pub const nl80211_commands_NL80211_CMD_SET_MCAST_RATE: nl80211_commands = 92;
pub const nl80211_commands_NL80211_CMD_SET_MAC_ACL: nl80211_commands = 93;
pub const nl80211_commands_NL80211_CMD_RADAR_DETECT: nl80211_commands = 94;
pub const nl80211_commands_NL80211_CMD_GET_PROTOCOL_FEATURES: nl80211_commands = 95;
pub const nl80211_commands_NL80211_CMD_UPDATE_FT_IES: nl80211_commands = 96;
pub const nl80211_commands_NL80211_CMD_FT_EVENT: nl80211_commands = 97;
pub const nl80211_commands_NL80211_CMD_CRIT_PROTOCOL_START: nl80211_commands = 98;
pub const nl80211_commands_NL80211_CMD_CRIT_PROTOCOL_STOP: nl80211_commands = 99;
pub const nl80211_commands_NL80211_CMD_GET_COALESCE: nl80211_commands = 100;
pub const nl80211_commands_NL80211_CMD_SET_COALESCE: nl80211_commands = 101;
pub const nl80211_commands_NL80211_CMD_CHANNEL_SWITCH: nl80211_commands = 102;
pub const nl80211_commands_NL80211_CMD_VENDOR: nl80211_commands = 103;
pub const nl80211_commands_NL80211_CMD_SET_QOS_MAP: nl80211_commands = 104;
pub const nl80211_commands_NL80211_CMD_ADD_TX_TS: nl80211_commands = 105;
pub const nl80211_commands_NL80211_CMD_DEL_TX_TS: nl80211_commands = 106;
pub const nl80211_commands_NL80211_CMD_GET_MPP: nl80211_commands = 107;
pub const nl80211_commands_NL80211_CMD_JOIN_OCB: nl80211_commands = 108;
pub const nl80211_commands_NL80211_CMD_LEAVE_OCB: nl80211_commands = 109;
pub const nl80211_commands_NL80211_CMD_CH_SWITCH_STARTED_NOTIFY: nl80211_commands = 110;
pub const nl80211_commands_NL80211_CMD_TDLS_CHANNEL_SWITCH: nl80211_commands = 111;
pub const nl80211_commands_NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH: nl80211_commands = 112;
pub const nl80211_commands_NL80211_CMD_WIPHY_REG_CHANGE: nl80211_commands = 113;
pub const nl80211_commands_NL80211_CMD_ABORT_SCAN: nl80211_commands = 114;
pub const nl80211_commands_NL80211_CMD_START_NAN: nl80211_commands = 115;
pub const nl80211_commands_NL80211_CMD_STOP_NAN: nl80211_commands = 116;
pub const nl80211_commands_NL80211_CMD_ADD_NAN_FUNCTION: nl80211_commands = 117;
pub const nl80211_commands_NL80211_CMD_DEL_NAN_FUNCTION: nl80211_commands = 118;
pub const nl80211_commands_NL80211_CMD_CHANGE_NAN_CONFIG: nl80211_commands = 119;
pub const nl80211_commands_NL80211_CMD_NAN_MATCH: nl80211_commands = 120;
pub const nl80211_commands_NL80211_CMD_SET_MULTICAST_TO_UNICAST: nl80211_commands = 121;
pub const nl80211_commands_NL80211_CMD_UPDATE_CONNECT_PARAMS: nl80211_commands = 122;
pub const nl80211_commands_NL80211_CMD_SET_PMK: nl80211_commands = 123;
pub const nl80211_commands_NL80211_CMD_DEL_PMK: nl80211_commands = 124;
pub const nl80211_commands_NL80211_CMD_PORT_AUTHORIZED: nl80211_commands = 125;
pub const nl80211_commands_NL80211_CMD_RELOAD_REGDB: nl80211_commands = 126;
pub const nl80211_commands_NL80211_CMD_EXTERNAL_AUTH: nl80211_commands = 127;
pub const nl80211_commands_NL80211_CMD_STA_OPMODE_CHANGED: nl80211_commands = 128;
pub const nl80211_commands_NL80211_CMD_CONTROL_PORT_FRAME: nl80211_commands = 129;
pub const nl80211_commands_NL80211_CMD_GET_FTM_RESPONDER_STATS: nl80211_commands = 130;
pub const nl80211_commands_NL80211_CMD_PEER_MEASUREMENT_START: nl80211_commands = 131;
pub const nl80211_commands_NL80211_CMD_PEER_MEASUREMENT_RESULT: nl80211_commands = 132;
pub const nl80211_commands_NL80211_CMD_PEER_MEASUREMENT_COMPLETE: nl80211_commands = 133;
pub const nl80211_commands_NL80211_CMD_NOTIFY_RADAR: nl80211_commands = 134;
pub const nl80211_commands_NL80211_CMD_UPDATE_OWE_INFO: nl80211_commands = 135;
pub const nl80211_commands_NL80211_CMD_PROBE_MESH_LINK: nl80211_commands = 136;
pub const nl80211_commands_NL80211_CMD_SET_TID_CONFIG: nl80211_commands = 137;
pub const nl80211_commands_NL80211_CMD_UNPROT_BEACON: nl80211_commands = 138;
pub const nl80211_commands_NL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS: nl80211_commands = 139;
pub const nl80211_commands_NL80211_CMD_SET_SAR_SPECS: nl80211_commands = 140;
pub const nl80211_commands___NL80211_CMD_AFTER_LAST: nl80211_commands = 141;
pub const nl80211_commands_NL80211_CMD_MAX: nl80211_commands = 140;
#[doc = " enum nl80211_commands - supported nl80211 commands"]
#[doc = ""]
#[doc = " @NL80211_CMD_UNSPEC: unspecified command to catch errors"]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_WIPHY: request information about a wiphy or dump request"]
#[doc = "\tto get a list of all present wiphys."]
#[doc = " @NL80211_CMD_SET_WIPHY: set wiphy parameters, needs %NL80211_ATTR_WIPHY or"]
#[doc = "\t%NL80211_ATTR_IFINDEX; can be used to set %NL80211_ATTR_WIPHY_NAME,"]
#[doc = "\t%NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ,"]
#[doc = "\t%NL80211_ATTR_WIPHY_FREQ_OFFSET (and the attributes determining the"]
#[doc = "\tchannel width; this is used for setting monitor mode channel),"]
#[doc = "\t%NL80211_ATTR_WIPHY_RETRY_SHORT, %NL80211_ATTR_WIPHY_RETRY_LONG,"]
#[doc = "\t%NL80211_ATTR_WIPHY_FRAG_THRESHOLD, and/or"]
#[doc = "\t%NL80211_ATTR_WIPHY_RTS_THRESHOLD.  However, for setting the channel,"]
#[doc = "\tsee %NL80211_CMD_SET_CHANNEL instead, the support here is for backward"]
#[doc = "\tcompatibility only."]
#[doc = " @NL80211_CMD_NEW_WIPHY: Newly created wiphy, response to get request"]
#[doc = "\tor rename notification. Has attributes %NL80211_ATTR_WIPHY and"]
#[doc = "\t%NL80211_ATTR_WIPHY_NAME."]
#[doc = " @NL80211_CMD_DEL_WIPHY: Wiphy deleted. Has attributes"]
#[doc = "\t%NL80211_ATTR_WIPHY and %NL80211_ATTR_WIPHY_NAME."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_INTERFACE: Request an interface's configuration;"]
#[doc = "\teither a dump request for all interfaces or a specific get with a"]
#[doc = "\tsingle %NL80211_ATTR_IFINDEX is supported."]
#[doc = " @NL80211_CMD_SET_INTERFACE: Set type of a virtual interface, requires"]
#[doc = "\t%NL80211_ATTR_IFINDEX and %NL80211_ATTR_IFTYPE."]
#[doc = " @NL80211_CMD_NEW_INTERFACE: Newly created virtual interface or response"]
#[doc = "\tto %NL80211_CMD_GET_INTERFACE. Has %NL80211_ATTR_IFINDEX,"]
#[doc = "\t%NL80211_ATTR_WIPHY and %NL80211_ATTR_IFTYPE attributes. Can also"]
#[doc = "\tbe sent from userspace to request creation of a new virtual interface,"]
#[doc = "\tthen requires attributes %NL80211_ATTR_WIPHY, %NL80211_ATTR_IFTYPE and"]
#[doc = "\t%NL80211_ATTR_IFNAME."]
#[doc = " @NL80211_CMD_DEL_INTERFACE: Virtual interface was deleted, has attributes"]
#[doc = "\t%NL80211_ATTR_IFINDEX and %NL80211_ATTR_WIPHY. Can also be sent from"]
#[doc = "\tuserspace to request deletion of a virtual interface, then requires"]
#[doc = "\tattribute %NL80211_ATTR_IFINDEX."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_KEY: Get sequence counter information for a key specified"]
#[doc = "\tby %NL80211_ATTR_KEY_IDX and/or %NL80211_ATTR_MAC."]
#[doc = " @NL80211_CMD_SET_KEY: Set key attributes %NL80211_ATTR_KEY_DEFAULT,"]
#[doc = "\t%NL80211_ATTR_KEY_DEFAULT_MGMT, or %NL80211_ATTR_KEY_THRESHOLD."]
#[doc = " @NL80211_CMD_NEW_KEY: add a key with given %NL80211_ATTR_KEY_DATA,"]
#[doc = "\t%NL80211_ATTR_KEY_IDX, %NL80211_ATTR_MAC, %NL80211_ATTR_KEY_CIPHER,"]
#[doc = "\tand %NL80211_ATTR_KEY_SEQ attributes."]
#[doc = " @NL80211_CMD_DEL_KEY: delete a key identified by %NL80211_ATTR_KEY_IDX"]
#[doc = "\tor %NL80211_ATTR_MAC."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_BEACON: (not used)"]
#[doc = " @NL80211_CMD_SET_BEACON: change the beacon on an access point interface"]
#[doc = "\tusing the %NL80211_ATTR_BEACON_HEAD and %NL80211_ATTR_BEACON_TAIL"]
#[doc = "\tattributes. For drivers that generate the beacon and probe responses"]
#[doc = "\tinternally, the following attributes must be provided: %NL80211_ATTR_IE,"]
#[doc = "\t%NL80211_ATTR_IE_PROBE_RESP and %NL80211_ATTR_IE_ASSOC_RESP."]
#[doc = " @NL80211_CMD_START_AP: Start AP operation on an AP interface, parameters"]
#[doc = "\tare like for %NL80211_CMD_SET_BEACON, and additionally parameters that"]
#[doc = "\tdo not change are used, these include %NL80211_ATTR_BEACON_INTERVAL,"]
#[doc = "\t%NL80211_ATTR_DTIM_PERIOD, %NL80211_ATTR_SSID,"]
#[doc = "\t%NL80211_ATTR_HIDDEN_SSID, %NL80211_ATTR_CIPHERS_PAIRWISE,"]
#[doc = "\t%NL80211_ATTR_CIPHER_GROUP, %NL80211_ATTR_WPA_VERSIONS,"]
#[doc = "\t%NL80211_ATTR_AKM_SUITES, %NL80211_ATTR_PRIVACY,"]
#[doc = "\t%NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_INACTIVITY_TIMEOUT,"]
#[doc = "\t%NL80211_ATTR_ACL_POLICY and %NL80211_ATTR_MAC_ADDRS."]
#[doc = "\tThe channel to use can be set on the interface or be given using the"]
#[doc = "\t%NL80211_ATTR_WIPHY_FREQ and %NL80211_ATTR_WIPHY_FREQ_OFFSET, and the"]
#[doc = "\tattributes determining channel width."]
#[doc = " @NL80211_CMD_NEW_BEACON: old alias for %NL80211_CMD_START_AP"]
#[doc = " @NL80211_CMD_STOP_AP: Stop AP operation on the given interface"]
#[doc = " @NL80211_CMD_DEL_BEACON: old alias for %NL80211_CMD_STOP_AP"]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_STATION: Get station attributes for station identified by"]
#[doc = "\t%NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX."]
#[doc = " @NL80211_CMD_SET_STATION: Set station attributes for station identified by"]
#[doc = "\t%NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX."]
#[doc = " @NL80211_CMD_NEW_STATION: Add a station with given attributes to the"]
#[doc = "\tinterface identified by %NL80211_ATTR_IFINDEX."]
#[doc = " @NL80211_CMD_DEL_STATION: Remove a station identified by %NL80211_ATTR_MAC"]
#[doc = "\tor, if no MAC address given, all stations, on the interface identified"]
#[doc = "\tby %NL80211_ATTR_IFINDEX. %NL80211_ATTR_MGMT_SUBTYPE and"]
#[doc = "\t%NL80211_ATTR_REASON_CODE can optionally be used to specify which type"]
#[doc = "\tof disconnection indication should be sent to the station"]
#[doc = "\t(Deauthentication or Disassociation frame and reason code for that"]
#[doc = "\tframe)."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_MPATH: Get mesh path attributes for mesh path to"]
#[doc = " \tdestination %NL80211_ATTR_MAC on the interface identified by"]
#[doc = " \t%NL80211_ATTR_IFINDEX."]
#[doc = " @NL80211_CMD_SET_MPATH:  Set mesh path attributes for mesh path to"]
#[doc = " \tdestination %NL80211_ATTR_MAC on the interface identified by"]
#[doc = " \t%NL80211_ATTR_IFINDEX."]
#[doc = " @NL80211_CMD_NEW_MPATH: Create a new mesh path for the destination given by"]
#[doc = "\t%NL80211_ATTR_MAC via %NL80211_ATTR_MPATH_NEXT_HOP."]
#[doc = " @NL80211_CMD_DEL_MPATH: Delete a mesh path to the destination given by"]
#[doc = "\t%NL80211_ATTR_MAC."]
#[doc = " @NL80211_CMD_NEW_PATH: Add a mesh path with given attributes to the"]
#[doc = "\tinterface identified by %NL80211_ATTR_IFINDEX."]
#[doc = " @NL80211_CMD_DEL_PATH: Remove a mesh path identified by %NL80211_ATTR_MAC"]
#[doc = "\tor, if no MAC address given, all mesh paths, on the interface identified"]
#[doc = "\tby %NL80211_ATTR_IFINDEX."]
#[doc = " @NL80211_CMD_SET_BSS: Set BSS attributes for BSS identified by"]
#[doc = "\t%NL80211_ATTR_IFINDEX."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_REG: ask the wireless core to send us its currently set"]
#[doc = "\tregulatory domain. If %NL80211_ATTR_WIPHY is specified and the device"]
#[doc = "\thas a private regulatory domain, it will be returned. Otherwise, the"]
#[doc = "\tglobal regdomain will be returned."]
#[doc = "\tA device will have a private regulatory domain if it uses the"]
#[doc = "\tregulatory_hint() API. Even when a private regdomain is used the channel"]
#[doc = "\tinformation will still be mended according to further hints from"]
#[doc = "\tthe regulatory core to help with compliance. A dump version of this API"]
#[doc = "\tis now available which will returns the global regdomain as well as"]
#[doc = "\tall private regdomains of present wiphys (for those that have it)."]
#[doc = "\tIf a wiphy is self-managed (%NL80211_ATTR_WIPHY_SELF_MANAGED_REG), then"]
#[doc = "\tits private regdomain is the only valid one for it. The regulatory"]
#[doc = "\tcore is not used to help with compliance in this case."]
#[doc = " @NL80211_CMD_SET_REG: Set current regulatory domain. CRDA sends this command"]
#[doc = "\tafter being queried by the kernel. CRDA replies by sending a regulatory"]
#[doc = "\tdomain structure which consists of %NL80211_ATTR_REG_ALPHA set to our"]
#[doc = "\tcurrent alpha2 if it found a match. It also provides"]
#[doc = " \tNL80211_ATTR_REG_RULE_FLAGS, and a set of regulatory rules. Each"]
#[doc = " \tregulatory rule is a nested set of attributes  given by"]
#[doc = " \t%NL80211_ATTR_REG_RULE_FREQ_[START|END] and"]
#[doc = " \t%NL80211_ATTR_FREQ_RANGE_MAX_BW with an attached power rule given by"]
#[doc = " \t%NL80211_ATTR_REG_RULE_POWER_MAX_ANT_GAIN and"]
#[doc = " \t%NL80211_ATTR_REG_RULE_POWER_MAX_EIRP."]
#[doc = " @NL80211_CMD_REQ_SET_REG: ask the wireless core to set the regulatory domain"]
#[doc = " \tto the specified ISO/IEC 3166-1 alpha2 country code. The core will"]
#[doc = " \tstore this as a valid request and then query userspace for it."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_MESH_CONFIG: Get mesh networking properties for the"]
#[doc = "\tinterface identified by %NL80211_ATTR_IFINDEX"]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_MESH_CONFIG: Set mesh networking properties for the"]
#[doc = "      interface identified by %NL80211_ATTR_IFINDEX"]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_MGMT_EXTRA_IE: Set extra IEs for management frames. The"]
#[doc = "\tinterface is identified with %NL80211_ATTR_IFINDEX and the management"]
#[doc = "\tframe subtype with %NL80211_ATTR_MGMT_SUBTYPE. The extra IE data to be"]
#[doc = "\tadded to the end of the specified management frame is specified with"]
#[doc = "\t%NL80211_ATTR_IE. If the command succeeds, the requested data will be"]
#[doc = "\tadded to all specified management frames generated by"]
#[doc = "\tkernel/firmware/driver."]
#[doc = "\tNote: This command has been removed and it is only reserved at this"]
#[doc = "\tpoint to avoid re-using existing command number. The functionality this"]
#[doc = "\tcommand was planned for has been provided with cleaner design with the"]
#[doc = "\toption to specify additional IEs in NL80211_CMD_TRIGGER_SCAN,"]
#[doc = "\tNL80211_CMD_AUTHENTICATE, NL80211_CMD_ASSOCIATE,"]
#[doc = "\tNL80211_CMD_DEAUTHENTICATE, and NL80211_CMD_DISASSOCIATE."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_SCAN: get scan results"]
#[doc = " @NL80211_CMD_TRIGGER_SCAN: trigger a new scan with the given parameters"]
#[doc = "\t%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the"]
#[doc = "\tprobe requests at CCK rate or not. %NL80211_ATTR_BSSID can be used to"]
#[doc = "\tspecify a BSSID to scan for; if not included, the wildcard BSSID will"]
#[doc = "\tbe used."]
#[doc = " @NL80211_CMD_NEW_SCAN_RESULTS: scan notification (as a reply to"]
#[doc = "\tNL80211_CMD_GET_SCAN and on the \"scan\" multicast group)"]
#[doc = " @NL80211_CMD_SCAN_ABORTED: scan was aborted, for unspecified reasons,"]
#[doc = "\tpartial scan results may be available"]
#[doc = ""]
#[doc = " @NL80211_CMD_START_SCHED_SCAN: start a scheduled scan at certain"]
#[doc = "\tintervals and certain number of cycles, as specified by"]
#[doc = "\t%NL80211_ATTR_SCHED_SCAN_PLANS. If %NL80211_ATTR_SCHED_SCAN_PLANS is"]
#[doc = "\tnot specified and only %NL80211_ATTR_SCHED_SCAN_INTERVAL is specified,"]
#[doc = "\tscheduled scan will run in an infinite loop with the specified interval."]
#[doc = "\tThese attributes are mutually exculsive,"]
#[doc = "\ti.e. NL80211_ATTR_SCHED_SCAN_INTERVAL must not be passed if"]
#[doc = "\tNL80211_ATTR_SCHED_SCAN_PLANS is defined."]
#[doc = "\tIf for some reason scheduled scan is aborted by the driver, all scan"]
#[doc = "\tplans are canceled (including scan plans that did not start yet)."]
#[doc = "\tLike with normal scans, if SSIDs (%NL80211_ATTR_SCAN_SSIDS)"]
#[doc = "\tare passed, they are used in the probe requests.  For"]
#[doc = "\tbroadcast, a broadcast SSID must be passed (ie. an empty"]
#[doc = "\tstring).  If no SSID is passed, no probe requests are sent and"]
#[doc = "\ta passive scan is performed.  %NL80211_ATTR_SCAN_FREQUENCIES,"]
#[doc = "\tif passed, define which channels should be scanned; if not"]
#[doc = "\tpassed, all channels allowed for the current regulatory domain"]
#[doc = "\tare used.  Extra IEs can also be passed from the userspace by"]
#[doc = "\tusing the %NL80211_ATTR_IE attribute.  The first cycle of the"]
#[doc = "\tscheduled scan can be delayed by %NL80211_ATTR_SCHED_SCAN_DELAY"]
#[doc = "\tis supplied. If the device supports multiple concurrent scheduled"]
#[doc = "\tscans, it will allow such when the caller provides the flag attribute"]
#[doc = "\t%NL80211_ATTR_SCHED_SCAN_MULTI to indicate user-space support for it."]
#[doc = " @NL80211_CMD_STOP_SCHED_SCAN: stop a scheduled scan. Returns -ENOENT if"]
#[doc = "\tscheduled scan is not running. The caller may assume that as soon"]
#[doc = "\tas the call returns, it is safe to start a new scheduled scan again."]
#[doc = " @NL80211_CMD_SCHED_SCAN_RESULTS: indicates that there are scheduled scan"]
#[doc = "\tresults available."]
#[doc = " @NL80211_CMD_SCHED_SCAN_STOPPED: indicates that the scheduled scan has"]
#[doc = "\tstopped.  The driver may issue this event at any time during a"]
#[doc = "\tscheduled scan.  One reason for stopping the scan is if the hardware"]
#[doc = "\tdoes not support starting an association or a normal scan while running"]
#[doc = "\ta scheduled scan.  This event is also sent when the"]
#[doc = "\t%NL80211_CMD_STOP_SCHED_SCAN command is received or when the interface"]
#[doc = "\tis brought down while a scheduled scan was running."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_SURVEY: get survey resuls, e.g. channel occupation"]
#[doc = "      or noise level"]
#[doc = " @NL80211_CMD_NEW_SURVEY_RESULTS: survey data notification (as a reply to"]
#[doc = "\tNL80211_CMD_GET_SURVEY and on the \"scan\" multicast group)"]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_PMKSA: Add a PMKSA cache entry using %NL80211_ATTR_MAC"]
#[doc = "\t(for the BSSID), %NL80211_ATTR_PMKID, and optionally %NL80211_ATTR_PMK"]
#[doc = "\t(PMK is used for PTKSA derivation in case of FILS shared key offload) or"]
#[doc = "\tusing %NL80211_ATTR_SSID, %NL80211_ATTR_FILS_CACHE_ID,"]
#[doc = "\t%NL80211_ATTR_PMKID, and %NL80211_ATTR_PMK in case of FILS"]
#[doc = "\tauthentication where %NL80211_ATTR_FILS_CACHE_ID is the identifier"]
#[doc = "\tadvertized by a FILS capable AP identifying the scope of PMKSA in an"]
#[doc = "\tESS."]
#[doc = " @NL80211_CMD_DEL_PMKSA: Delete a PMKSA cache entry, using %NL80211_ATTR_MAC"]
#[doc = "\t(for the BSSID) and %NL80211_ATTR_PMKID or using %NL80211_ATTR_SSID,"]
#[doc = "\t%NL80211_ATTR_FILS_CACHE_ID, and %NL80211_ATTR_PMKID in case of FILS"]
#[doc = "\tauthentication."]
#[doc = " @NL80211_CMD_FLUSH_PMKSA: Flush all PMKSA cache entries."]
#[doc = ""]
#[doc = " @NL80211_CMD_REG_CHANGE: indicates to userspace the regulatory domain"]
#[doc = " \thas been changed and provides details of the request information"]
#[doc = " \tthat caused the change such as who initiated the regulatory request"]
#[doc = " \t(%NL80211_ATTR_REG_INITIATOR), the wiphy_idx"]
#[doc = " \t(%NL80211_ATTR_REG_ALPHA2) on which the request was made from if"]
#[doc = " \tthe initiator was %NL80211_REGDOM_SET_BY_COUNTRY_IE or"]
#[doc = " \t%NL80211_REGDOM_SET_BY_DRIVER, the type of regulatory domain"]
#[doc = " \tset (%NL80211_ATTR_REG_TYPE), if the type of regulatory domain is"]
#[doc = " \t%NL80211_REG_TYPE_COUNTRY the alpha2 to which we have moved on"]
#[doc = " \tto (%NL80211_ATTR_REG_ALPHA2)."]
#[doc = " @NL80211_CMD_REG_BEACON_HINT: indicates to userspace that an AP beacon"]
#[doc = " \thas been found while world roaming thus enabling active scan or"]
#[doc = " \tany mode of operation that initiates TX (beacons) on a channel"]
#[doc = " \twhere we would not have been able to do either before. As an example"]
#[doc = " \tif you are world roaming (regulatory domain set to world or if your"]
#[doc = " \tdriver is using a custom world roaming regulatory domain) and while"]
#[doc = " \tdoing a passive scan on the 5 GHz band you find an AP there (if not"]
#[doc = " \ton a DFS channel) you will now be able to actively scan for that AP"]
#[doc = " \tor use AP mode on your card on that same channel. Note that this will"]
#[doc = " \tnever be used for channels 1-11 on the 2 GHz band as they are always"]
#[doc = " \tenabled world wide. This beacon hint is only sent if your device had"]
#[doc = " \teither disabled active scanning or beaconing on a channel. We send to"]
#[doc = " \tuserspace the wiphy on which we removed a restriction from"]
#[doc = " \t(%NL80211_ATTR_WIPHY) and the channel on which this occurred"]
#[doc = " \tbefore (%NL80211_ATTR_FREQ_BEFORE) and after (%NL80211_ATTR_FREQ_AFTER)"]
#[doc = " \tthe beacon hint was processed."]
#[doc = ""]
#[doc = " @NL80211_CMD_AUTHENTICATE: authentication request and notification."]
#[doc = "\tThis command is used both as a command (request to authenticate) and"]
#[doc = "\tas an event on the \"mlme\" multicast group indicating completion of the"]
#[doc = "\tauthentication process."]
#[doc = "\tWhen used as a command, %NL80211_ATTR_IFINDEX is used to identify the"]
#[doc = "\tinterface. %NL80211_ATTR_MAC is used to specify PeerSTAAddress (and"]
#[doc = "\tBSSID in case of station mode). %NL80211_ATTR_SSID is used to specify"]
#[doc = "\tthe SSID (mainly for association, but is included in authentication"]
#[doc = "\trequest, too, to help BSS selection. %NL80211_ATTR_WIPHY_FREQ +"]
#[doc = "\t%NL80211_ATTR_WIPHY_FREQ_OFFSET is used to specify the frequence of the"]
#[doc = "\tchannel in MHz. %NL80211_ATTR_AUTH_TYPE is used to specify the"]
#[doc = "\tauthentication type. %NL80211_ATTR_IE is used to define IEs"]
#[doc = "\t(VendorSpecificInfo, but also including RSN IE and FT IEs) to be added"]
#[doc = "\tto the frame."]
#[doc = "\tWhen used as an event, this reports reception of an Authentication"]
#[doc = "\tframe in station and IBSS modes when the local MLME processed the"]
#[doc = "\tframe, i.e., it was for the local STA and was received in correct"]
#[doc = "\tstate. This is similar to MLME-AUTHENTICATE.confirm primitive in the"]
#[doc = "\tMLME SAP interface (kernel providing MLME, userspace SME). The"]
#[doc = "\tincluded %NL80211_ATTR_FRAME attribute contains the management frame"]
#[doc = "\t(including both the header and frame body, but not FCS). This event is"]
#[doc = "\talso used to indicate if the authentication attempt timed out. In that"]
#[doc = "\tcase the %NL80211_ATTR_FRAME attribute is replaced with a"]
#[doc = "\t%NL80211_ATTR_TIMED_OUT flag (and %NL80211_ATTR_MAC to indicate which"]
#[doc = "\tpending authentication timed out)."]
#[doc = " @NL80211_CMD_ASSOCIATE: association request and notification; like"]
#[doc = "\tNL80211_CMD_AUTHENTICATE but for Association and Reassociation"]
#[doc = "\t(similar to MLME-ASSOCIATE.request, MLME-REASSOCIATE.request,"]
#[doc = "\tMLME-ASSOCIATE.confirm or MLME-REASSOCIATE.confirm primitives). The"]
#[doc = "\t%NL80211_ATTR_PREV_BSSID attribute is used to specify whether the"]
#[doc = "\trequest is for the initial association to an ESS (that attribute not"]
#[doc = "\tincluded) or for reassociation within the ESS (that attribute is"]
#[doc = "\tincluded)."]
#[doc = " @NL80211_CMD_DEAUTHENTICATE: deauthentication request and notification; like"]
#[doc = "\tNL80211_CMD_AUTHENTICATE but for Deauthentication frames (similar to"]
#[doc = "\tMLME-DEAUTHENTICATION.request and MLME-DEAUTHENTICATE.indication"]
#[doc = "\tprimitives)."]
#[doc = " @NL80211_CMD_DISASSOCIATE: disassociation request and notification; like"]
#[doc = "\tNL80211_CMD_AUTHENTICATE but for Disassociation frames (similar to"]
#[doc = "\tMLME-DISASSOCIATE.request and MLME-DISASSOCIATE.indication primitives)."]
#[doc = ""]
#[doc = " @NL80211_CMD_MICHAEL_MIC_FAILURE: notification of a locally detected Michael"]
#[doc = "\tMIC (part of TKIP) failure; sent on the \"mlme\" multicast group; the"]
#[doc = "\tevent includes %NL80211_ATTR_MAC to describe the source MAC address of"]
#[doc = "\tthe frame with invalid MIC, %NL80211_ATTR_KEY_TYPE to show the key"]
#[doc = "\ttype, %NL80211_ATTR_KEY_IDX to indicate the key identifier, and"]
#[doc = "\t%NL80211_ATTR_KEY_SEQ to indicate the TSC value of the frame; this"]
#[doc = "\tevent matches with MLME-MICHAELMICFAILURE.indication() primitive"]
#[doc = ""]
#[doc = " @NL80211_CMD_JOIN_IBSS: Join a new IBSS -- given at least an SSID and a"]
#[doc = "\tFREQ attribute (for the initial frequency if no peer can be found)"]
#[doc = "\tand optionally a MAC (as BSSID) and FREQ_FIXED attribute if those"]
#[doc = "\tshould be fixed rather than automatically determined. Can only be"]
#[doc = "\texecuted on a network interface that is UP, and fixed BSSID/FREQ"]
#[doc = "\tmay be rejected. Another optional parameter is the beacon interval,"]
#[doc = "\tgiven in the %NL80211_ATTR_BEACON_INTERVAL attribute, which if not"]
#[doc = "\tgiven defaults to 100 TU (102.4ms)."]
#[doc = " @NL80211_CMD_LEAVE_IBSS: Leave the IBSS -- no special arguments, the IBSS is"]
#[doc = "\tdetermined by the network interface."]
#[doc = ""]
#[doc = " @NL80211_CMD_TESTMODE: testmode command, takes a wiphy (or ifindex) attribute"]
#[doc = "\tto identify the device, and the TESTDATA blob attribute to pass through"]
#[doc = "\tto the driver."]
#[doc = ""]
#[doc = " @NL80211_CMD_CONNECT: connection request and notification; this command"]
#[doc = "\trequests to connect to a specified network but without separating"]
#[doc = "\tauth and assoc steps. For this, you need to specify the SSID in a"]
#[doc = "\t%NL80211_ATTR_SSID attribute, and can optionally specify the association"]
#[doc = "\tIEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE,"]
#[doc = "\t%NL80211_ATTR_USE_MFP, %NL80211_ATTR_MAC, %NL80211_ATTR_WIPHY_FREQ,"]
#[doc = "\t%NL80211_ATTR_WIPHY_FREQ_OFFSET, %NL80211_ATTR_CONTROL_PORT,"]
#[doc = "\t%NL80211_ATTR_CONTROL_PORT_ETHERTYPE,"]
#[doc = "\t%NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT,"]
#[doc = "\t%NL80211_ATTR_CONTROL_PORT_OVER_NL80211, %NL80211_ATTR_MAC_HINT, and"]
#[doc = "\t%NL80211_ATTR_WIPHY_FREQ_HINT."]
#[doc = "\tIf included, %NL80211_ATTR_MAC and %NL80211_ATTR_WIPHY_FREQ are"]
#[doc = "\trestrictions on BSS selection, i.e., they effectively prevent roaming"]
#[doc = "\twithin the ESS. %NL80211_ATTR_MAC_HINT and %NL80211_ATTR_WIPHY_FREQ_HINT"]
#[doc = "\tcan be included to provide a recommendation of the initial BSS while"]
#[doc = "\tallowing the driver to roam to other BSSes within the ESS and also to"]
#[doc = "\tignore this recommendation if the indicated BSS is not ideal. Only one"]
#[doc = "\tset of BSSID,frequency parameters is used (i.e., either the enforcing"]
#[doc = "\t%NL80211_ATTR_MAC,%NL80211_ATTR_WIPHY_FREQ or the less strict"]
#[doc = "\t%NL80211_ATTR_MAC_HINT and %NL80211_ATTR_WIPHY_FREQ_HINT)."]
#[doc = "\tDriver shall not modify the IEs specified through %NL80211_ATTR_IE if"]
#[doc = "\t%NL80211_ATTR_MAC is included. However, if %NL80211_ATTR_MAC_HINT is"]
#[doc = "\tincluded, these IEs through %NL80211_ATTR_IE are specified by the user"]
#[doc = "\tspace based on the best possible BSS selected. Thus, if the driver ends"]
#[doc = "\tup selecting a different BSS, it can modify these IEs accordingly (e.g."]
#[doc = "\tuserspace asks the driver to perform PMKSA caching with BSS1 and the"]
#[doc = "\tdriver ends up selecting BSS2 with different PMKSA cache entry; RSNIE"]
#[doc = "\thas to get updated with the apt PMKID)."]
#[doc = "\t%NL80211_ATTR_PREV_BSSID can be used to request a reassociation within"]
#[doc = "\tthe ESS in case the device is already associated and an association with"]
#[doc = "\ta different BSS is desired."]
#[doc = "\tBackground scan period can optionally be"]
#[doc = "\tspecified in %NL80211_ATTR_BG_SCAN_PERIOD,"]
#[doc = "\tif not specified default background scan configuration"]
#[doc = "\tin driver is used and if period value is 0, bg scan will be disabled."]
#[doc = "\tThis attribute is ignored if driver does not support roam scan."]
#[doc = "\tIt is also sent as an event, with the BSSID and response IEs when the"]
#[doc = "\tconnection is established or failed to be established. This can be"]
#[doc = "\tdetermined by the %NL80211_ATTR_STATUS_CODE attribute (0 = success,"]
#[doc = "\tnon-zero = failure). If %NL80211_ATTR_TIMED_OUT is included in the"]
#[doc = "\tevent, the connection attempt failed due to not being able to initiate"]
#[doc = "\tauthentication/association or not receiving a response from the AP."]
#[doc = "\tNon-zero %NL80211_ATTR_STATUS_CODE value is indicated in that case as"]
#[doc = "\twell to remain backwards compatible."]
#[doc = " @NL80211_CMD_ROAM: Notification indicating the card/driver roamed by itself."]
#[doc = "\tWhen a security association was established on an 802.1X network using"]
#[doc = "\tfast transition, this event should be followed by an"]
#[doc = "\t%NL80211_CMD_PORT_AUTHORIZED event."]
#[doc = " @NL80211_CMD_DISCONNECT: drop a given connection; also used to notify"]
#[doc = "\tuserspace that a connection was dropped by the AP or due to other"]
#[doc = "\treasons, for this the %NL80211_ATTR_DISCONNECTED_BY_AP and"]
#[doc = "\t%NL80211_ATTR_REASON_CODE attributes are used."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_WIPHY_NETNS: Set a wiphy's netns. Note that all devices"]
#[doc = "\tassociated with this wiphy must be down and will follow."]
#[doc = ""]
#[doc = " @NL80211_CMD_REMAIN_ON_CHANNEL: Request to remain awake on the specified"]
#[doc = "\tchannel for the specified amount of time. This can be used to do"]
#[doc = "\toff-channel operations like transmit a Public Action frame and wait for"]
#[doc = "\ta response while being associated to an AP on another channel."]
#[doc = "\t%NL80211_ATTR_IFINDEX is used to specify which interface (and thus"]
#[doc = "\tradio) is used. %NL80211_ATTR_WIPHY_FREQ is used to specify the"]
#[doc = "\tfrequency for the operation."]
#[doc = "\t%NL80211_ATTR_DURATION is used to specify the duration in milliseconds"]
#[doc = "\tto remain on the channel. This command is also used as an event to"]
#[doc = "\tnotify when the requested duration starts (it may take a while for the"]
#[doc = "\tdriver to schedule this time due to other concurrent needs for the"]
#[doc = "\tradio)."]
#[doc = "\tWhen called, this operation returns a cookie (%NL80211_ATTR_COOKIE)"]
#[doc = "\tthat will be included with any events pertaining to this request;"]
#[doc = "\tthe cookie is also used to cancel the request."]
#[doc = " @NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL: This command can be used to cancel a"]
#[doc = "\tpending remain-on-channel duration if the desired operation has been"]
#[doc = "\tcompleted prior to expiration of the originally requested duration."]
#[doc = "\t%NL80211_ATTR_WIPHY or %NL80211_ATTR_IFINDEX is used to specify the"]
#[doc = "\tradio. The %NL80211_ATTR_COOKIE attribute must be given as well to"]
#[doc = "\tuniquely identify the request."]
#[doc = "\tThis command is also used as an event to notify when a requested"]
#[doc = "\tremain-on-channel duration has expired."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_TX_BITRATE_MASK: Set the mask of rates to be used in TX"]
#[doc = "\trate selection. %NL80211_ATTR_IFINDEX is used to specify the interface"]
#[doc = "\tand @NL80211_ATTR_TX_RATES the set of allowed rates."]
#[doc = ""]
#[doc = " @NL80211_CMD_REGISTER_FRAME: Register for receiving certain mgmt frames"]
#[doc = "\t(via @NL80211_CMD_FRAME) for processing in userspace. This command"]
#[doc = "\trequires an interface index, a frame type attribute (optional for"]
#[doc = "\tbackward compatibility reasons, if not given assumes action frames)"]
#[doc = "\tand a match attribute containing the first few bytes of the frame"]
#[doc = "\tthat should match, e.g. a single byte for only a category match or"]
#[doc = "\tfour bytes for vendor frames including the OUI. The registration"]
#[doc = "\tcannot be dropped, but is removed automatically when the netlink"]
#[doc = "\tsocket is closed. Multiple registrations can be made."]
#[doc = "\tThe %NL80211_ATTR_RECEIVE_MULTICAST flag attribute can be given if"]
#[doc = "\t%NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS is available, in which"]
#[doc = "\tcase the registration can also be modified to include/exclude the"]
#[doc = "\tflag, rather than requiring unregistration to change it."]
#[doc = " @NL80211_CMD_REGISTER_ACTION: Alias for @NL80211_CMD_REGISTER_FRAME for"]
#[doc = "\tbackward compatibility"]
#[doc = " @NL80211_CMD_FRAME: Management frame TX request and RX notification. This"]
#[doc = "\tcommand is used both as a request to transmit a management frame and"]
#[doc = "\tas an event indicating reception of a frame that was not processed in"]
#[doc = "\tkernel code, but is for us (i.e., which may need to be processed in a"]
#[doc = "\tuser space application). %NL80211_ATTR_FRAME is used to specify the"]
#[doc = "\tframe contents (including header). %NL80211_ATTR_WIPHY_FREQ is used"]
#[doc = "\tto indicate on which channel the frame is to be transmitted or was"]
#[doc = "\treceived. If this channel is not the current channel (remain-on-channel"]
#[doc = "\tor the operational channel) the device will switch to the given channel"]
#[doc = "\tand transmit the frame, optionally waiting for a response for the time"]
#[doc = "\tspecified using %NL80211_ATTR_DURATION. When called, this operation"]
#[doc = "\treturns a cookie (%NL80211_ATTR_COOKIE) that will be included with the"]
#[doc = "\tTX status event pertaining to the TX request."]
#[doc = "\t%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the"]
#[doc = "\tmanagement frames at CCK rate or not in 2GHz band."]
#[doc = "\t%NL80211_ATTR_CSA_C_OFFSETS_TX is an array of offsets to CSA"]
#[doc = "\tcounters which will be updated to the current value. This attribute"]
#[doc = "\tis used during CSA period."]
#[doc = " @NL80211_CMD_FRAME_WAIT_CANCEL: When an off-channel TX was requested, this"]
#[doc = "\tcommand may be used with the corresponding cookie to cancel the wait"]
#[doc = "\ttime if it is known that it is no longer necessary.  This command is"]
#[doc = "\talso sent as an event whenever the driver has completed the off-channel"]
#[doc = "\twait time."]
#[doc = " @NL80211_CMD_ACTION: Alias for @NL80211_CMD_FRAME for backward compatibility."]
#[doc = " @NL80211_CMD_FRAME_TX_STATUS: Report TX status of a management frame"]
#[doc = "\ttransmitted with %NL80211_CMD_FRAME. %NL80211_ATTR_COOKIE identifies"]
#[doc = "\tthe TX command and %NL80211_ATTR_FRAME includes the contents of the"]
#[doc = "\tframe. %NL80211_ATTR_ACK flag is included if the recipient acknowledged"]
#[doc = "\tthe frame."]
#[doc = " @NL80211_CMD_ACTION_TX_STATUS: Alias for @NL80211_CMD_FRAME_TX_STATUS for"]
#[doc = "\tbackward compatibility."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_POWER_SAVE: Set powersave, using %NL80211_ATTR_PS_STATE"]
#[doc = " @NL80211_CMD_GET_POWER_SAVE: Get powersave status in %NL80211_ATTR_PS_STATE"]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_CQM: Connection quality monitor configuration. This command"]
#[doc = "\tis used to configure connection quality monitoring notification trigger"]
#[doc = "\tlevels."]
#[doc = " @NL80211_CMD_NOTIFY_CQM: Connection quality monitor notification. This"]
#[doc = "\tcommand is used as an event to indicate the that a trigger level was"]
#[doc = "\treached."]
#[doc = " @NL80211_CMD_SET_CHANNEL: Set the channel (using %NL80211_ATTR_WIPHY_FREQ"]
#[doc = "\tand the attributes determining channel width) the given interface"]
#[doc = "\t(identifed by %NL80211_ATTR_IFINDEX) shall operate on."]
#[doc = "\tIn case multiple channels are supported by the device, the mechanism"]
#[doc = "\twith which it switches channels is implementation-defined."]
#[doc = "\tWhen a monitor interface is given, it can only switch channel while"]
#[doc = "\tno other interfaces are operating to avoid disturbing the operation"]
#[doc = "\tof any other interfaces, and other interfaces will again take"]
#[doc = "\tprecedence when they are used."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_WDS_PEER: Set the MAC address of the peer on a WDS interface"]
#[doc = "\t(no longer supported)."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_MULTICAST_TO_UNICAST: Configure if this AP should perform"]
#[doc = "\tmulticast to unicast conversion. When enabled, all multicast packets"]
#[doc = "\twith ethertype ARP, IPv4 or IPv6 (possibly within an 802.1Q header)"]
#[doc = "\twill be sent out to each station once with the destination (multicast)"]
#[doc = "\tMAC address replaced by the station's MAC address. Note that this may"]
#[doc = "\tbreak certain expectations of the receiver, e.g. the ability to drop"]
#[doc = "\tunicast IP packets encapsulated in multicast L2 frames, or the ability"]
#[doc = "\tto not send destination unreachable messages in such cases."]
#[doc = "\tThis can only be toggled per BSS. Configure this on an interface of"]
#[doc = "\ttype %NL80211_IFTYPE_AP. It applies to all its VLAN interfaces"]
#[doc = "\t(%NL80211_IFTYPE_AP_VLAN), except for those in 4addr (WDS) mode."]
#[doc = "\tIf %NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED is not present with this"]
#[doc = "\tcommand, the feature is disabled."]
#[doc = ""]
#[doc = " @NL80211_CMD_JOIN_MESH: Join a mesh. The mesh ID must be given, and initial"]
#[doc = "\tmesh config parameters may be given."]
#[doc = " @NL80211_CMD_LEAVE_MESH: Leave the mesh network -- no special arguments, the"]
#[doc = "\tnetwork is determined by the network interface."]
#[doc = ""]
#[doc = " @NL80211_CMD_UNPROT_DEAUTHENTICATE: Unprotected deauthentication frame"]
#[doc = "\tnotification. This event is used to indicate that an unprotected"]
#[doc = "\tdeauthentication frame was dropped when MFP is in use."]
#[doc = " @NL80211_CMD_UNPROT_DISASSOCIATE: Unprotected disassociation frame"]
#[doc = "\tnotification. This event is used to indicate that an unprotected"]
#[doc = "\tdisassociation frame was dropped when MFP is in use."]
#[doc = ""]
#[doc = " @NL80211_CMD_NEW_PEER_CANDIDATE: Notification on the reception of a"]
#[doc = "      beacon or probe response from a compatible mesh peer.  This is only"]
#[doc = "      sent while no station information (sta_info) exists for the new peer"]
#[doc = "      candidate and when @NL80211_MESH_SETUP_USERSPACE_AUTH,"]
#[doc = "      @NL80211_MESH_SETUP_USERSPACE_AMPE, or"]
#[doc = "      @NL80211_MESH_SETUP_USERSPACE_MPM is set.  On reception of this"]
#[doc = "      notification, userspace may decide to create a new station"]
#[doc = "      (@NL80211_CMD_NEW_STATION).  To stop this notification from"]
#[doc = "      reoccurring, the userspace authentication daemon may want to create the"]
#[doc = "      new station with the AUTHENTICATED flag unset and maybe change it later"]
#[doc = "      depending on the authentication result."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_WOWLAN: get Wake-on-Wireless-LAN (WoWLAN) settings."]
#[doc = " @NL80211_CMD_SET_WOWLAN: set Wake-on-Wireless-LAN (WoWLAN) settings."]
#[doc = "\tSince wireless is more complex than wired ethernet, it supports"]
#[doc = "\tvarious triggers. These triggers can be configured through this"]
#[doc = "\tcommand with the %NL80211_ATTR_WOWLAN_TRIGGERS attribute. For"]
#[doc = "\tmore background information, see"]
#[doc = "\thttps://wireless.wiki.kernel.org/en/users/Documentation/WoWLAN."]
#[doc = "\tThe @NL80211_CMD_SET_WOWLAN command can also be used as a notification"]
#[doc = "\tfrom the driver reporting the wakeup reason. In this case, the"]
#[doc = "\t@NL80211_ATTR_WOWLAN_TRIGGERS attribute will contain the reason"]
#[doc = "\tfor the wakeup, if it was caused by wireless. If it is not present"]
#[doc = "\tin the wakeup notification, the wireless device didn't cause the"]
#[doc = "\twakeup but reports that it was woken up."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_REKEY_OFFLOAD: This command is used give the driver"]
#[doc = "\tthe necessary information for supporting GTK rekey offload. This"]
#[doc = "\tfeature is typically used during WoWLAN. The configuration data"]
#[doc = "\tis contained in %NL80211_ATTR_REKEY_DATA (which is nested and"]
#[doc = "\tcontains the data in sub-attributes). After rekeying happened,"]
#[doc = "\tthis command may also be sent by the driver as an MLME event to"]
#[doc = "\tinform userspace of the new replay counter."]
#[doc = ""]
#[doc = " @NL80211_CMD_PMKSA_CANDIDATE: This is used as an event to inform userspace"]
#[doc = "\tof PMKSA caching dandidates."]
#[doc = ""]
#[doc = " @NL80211_CMD_TDLS_OPER: Perform a high-level TDLS command (e.g. link setup)."]
#[doc = "\tIn addition, this can be used as an event to request userspace to take"]
#[doc = "\tactions on TDLS links (set up a new link or tear down an existing one)."]
#[doc = "\tIn such events, %NL80211_ATTR_TDLS_OPERATION indicates the requested"]
#[doc = "\toperation, %NL80211_ATTR_MAC contains the peer MAC address, and"]
#[doc = "\t%NL80211_ATTR_REASON_CODE the reason code to be used (only with"]
#[doc = "\t%NL80211_TDLS_TEARDOWN)."]
#[doc = " @NL80211_CMD_TDLS_MGMT: Send a TDLS management frame. The"]
#[doc = "\t%NL80211_ATTR_TDLS_ACTION attribute determines the type of frame to be"]
#[doc = "\tsent. Public Action codes (802.11-2012 8.1.5.1) will be sent as"]
#[doc = "\t802.11 management frames, while TDLS action codes (802.11-2012"]
#[doc = "\t8.5.13.1) will be encapsulated and sent as data frames. The currently"]
#[doc = "\tsupported Public Action code is %WLAN_PUB_ACTION_TDLS_DISCOVER_RES"]
#[doc = "\tand the currently supported TDLS actions codes are given in"]
#[doc = "\t&enum ieee80211_tdls_actioncode."]
#[doc = ""]
#[doc = " @NL80211_CMD_UNEXPECTED_FRAME: Used by an application controlling an AP"]
#[doc = "\t(or GO) interface (i.e. hostapd) to ask for unexpected frames to"]
#[doc = "\timplement sending deauth to stations that send unexpected class 3"]
#[doc = "\tframes. Also used as the event sent by the kernel when such a frame"]
#[doc = "\tis received."]
#[doc = "\tFor the event, the %NL80211_ATTR_MAC attribute carries the TA and"]
#[doc = "\tother attributes like the interface index are present."]
#[doc = "\tIf used as the command it must have an interface index and you can"]
#[doc = "\tonly unsubscribe from the event by closing the socket. Subscription"]
#[doc = "\tis also for %NL80211_CMD_UNEXPECTED_4ADDR_FRAME events."]
#[doc = ""]
#[doc = " @NL80211_CMD_UNEXPECTED_4ADDR_FRAME: Sent as an event indicating that the"]
#[doc = "\tassociated station identified by %NL80211_ATTR_MAC sent a 4addr frame"]
#[doc = "\tand wasn't already in a 4-addr VLAN. The event will be sent similarly"]
#[doc = "\tto the %NL80211_CMD_UNEXPECTED_FRAME event, to the same listener."]
#[doc = ""]
#[doc = " @NL80211_CMD_PROBE_CLIENT: Probe an associated station on an AP interface"]
#[doc = "\tby sending a null data frame to it and reporting when the frame is"]
#[doc = "\tacknowleged. This is used to allow timing out inactive clients. Uses"]
#[doc = "\t%NL80211_ATTR_IFINDEX and %NL80211_ATTR_MAC. The command returns a"]
#[doc = "\tdirect reply with an %NL80211_ATTR_COOKIE that is later used to match"]
#[doc = "\tup the event with the request. The event includes the same data and"]
#[doc = "\thas %NL80211_ATTR_ACK set if the frame was ACKed."]
#[doc = ""]
#[doc = " @NL80211_CMD_REGISTER_BEACONS: Register this socket to receive beacons from"]
#[doc = "\tother BSSes when any interfaces are in AP mode. This helps implement"]
#[doc = "\tOLBC handling in hostapd. Beacons are reported in %NL80211_CMD_FRAME"]
#[doc = "\tmessages. Note that per PHY only one application may register."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_NOACK_MAP: sets a bitmap for the individual TIDs whether"]
#[doc = "      No Acknowledgement Policy should be applied."]
#[doc = ""]
#[doc = " @NL80211_CMD_CH_SWITCH_NOTIFY: An AP or GO may decide to switch channels"]
#[doc = "\tindependently of the userspace SME, send this event indicating"]
#[doc = "\t%NL80211_ATTR_IFINDEX is now on %NL80211_ATTR_WIPHY_FREQ and the"]
#[doc = "\tattributes determining channel width.  This indication may also be"]
#[doc = "\tsent when a remotely-initiated switch (e.g., when a STA receives a CSA"]
#[doc = "\tfrom the remote AP) is completed;"]
#[doc = ""]
#[doc = " @NL80211_CMD_CH_SWITCH_STARTED_NOTIFY: Notify that a channel switch"]
#[doc = "\thas been started on an interface, regardless of the initiator"]
#[doc = "\t(ie. whether it was requested from a remote device or"]
#[doc = "\tinitiated on our own).  It indicates that"]
#[doc = "\t%NL80211_ATTR_IFINDEX will be on %NL80211_ATTR_WIPHY_FREQ"]
#[doc = "\tafter %NL80211_ATTR_CH_SWITCH_COUNT TBTT's.  The userspace may"]
#[doc = "\tdecide to react to this indication by requesting other"]
#[doc = "\tinterfaces to change channel as well."]
#[doc = ""]
#[doc = " @NL80211_CMD_START_P2P_DEVICE: Start the given P2P Device, identified by"]
#[doc = "\tits %NL80211_ATTR_WDEV identifier. It must have been created with"]
#[doc = "\t%NL80211_CMD_NEW_INTERFACE previously. After it has been started, the"]
#[doc = "\tP2P Device can be used for P2P operations, e.g. remain-on-channel and"]
#[doc = "\tpublic action frame TX."]
#[doc = " @NL80211_CMD_STOP_P2P_DEVICE: Stop the given P2P Device, identified by"]
#[doc = "\tits %NL80211_ATTR_WDEV identifier."]
#[doc = ""]
#[doc = " @NL80211_CMD_CONN_FAILED: connection request to an AP failed; used to"]
#[doc = "\tnotify userspace that AP has rejected the connection request from a"]
#[doc = "\tstation, due to particular reason. %NL80211_ATTR_CONN_FAILED_REASON"]
#[doc = "\tis used for this."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_MCAST_RATE: Change the rate used to send multicast frames"]
#[doc = "\tfor IBSS or MESH vif."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_MAC_ACL: sets ACL for MAC address based access control."]
#[doc = "\tThis is to be used with the drivers advertising the support of MAC"]
#[doc = "\taddress based access control. List of MAC addresses is passed in"]
#[doc = "\t%NL80211_ATTR_MAC_ADDRS and ACL policy is passed in"]
#[doc = "\t%NL80211_ATTR_ACL_POLICY. Driver will enable ACL with this list, if it"]
#[doc = "\tis not already done. The new list will replace any existing list. Driver"]
#[doc = "\twill clear its ACL when the list of MAC addresses passed is empty. This"]
#[doc = "\tcommand is used in AP/P2P GO mode. Driver has to make sure to clear its"]
#[doc = "\tACL list during %NL80211_CMD_STOP_AP."]
#[doc = ""]
#[doc = " @NL80211_CMD_RADAR_DETECT: Start a Channel availability check (CAC). Once"]
#[doc = "\ta radar is detected or the channel availability scan (CAC) has finished"]
#[doc = "\tor was aborted, or a radar was detected, usermode will be notified with"]
#[doc = "\tthis event. This command is also used to notify userspace about radars"]
#[doc = "\twhile operating on this channel."]
#[doc = "\t%NL80211_ATTR_RADAR_EVENT is used to inform about the type of the"]
#[doc = "\tevent."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_PROTOCOL_FEATURES: Get global nl80211 protocol features,"]
#[doc = "\ti.e. features for the nl80211 protocol rather than device features."]
#[doc = "\tReturns the features in the %NL80211_ATTR_PROTOCOL_FEATURES bitmap."]
#[doc = ""]
#[doc = " @NL80211_CMD_UPDATE_FT_IES: Pass down the most up-to-date Fast Transition"]
#[doc = "\tInformation Element to the WLAN driver"]
#[doc = ""]
#[doc = " @NL80211_CMD_FT_EVENT: Send a Fast transition event from the WLAN driver"]
#[doc = "\tto the supplicant. This will carry the target AP's MAC address along"]
#[doc = "\twith the relevant Information Elements. This event is used to report"]
#[doc = "\treceived FT IEs (MDIE, FTIE, RSN IE, TIE, RICIE)."]
#[doc = ""]
#[doc = " @NL80211_CMD_CRIT_PROTOCOL_START: Indicates user-space will start running"]
#[doc = "\ta critical protocol that needs more reliability in the connection to"]
#[doc = "\tcomplete."]
#[doc = ""]
#[doc = " @NL80211_CMD_CRIT_PROTOCOL_STOP: Indicates the connection reliability can"]
#[doc = "\treturn back to normal."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_COALESCE: Get currently supported coalesce rules."]
#[doc = " @NL80211_CMD_SET_COALESCE: Configure coalesce rules or clear existing rules."]
#[doc = ""]
#[doc = " @NL80211_CMD_CHANNEL_SWITCH: Perform a channel switch by announcing the"]
#[doc = "\tnew channel information (Channel Switch Announcement - CSA)"]
#[doc = "\tin the beacon for some time (as defined in the"]
#[doc = "\t%NL80211_ATTR_CH_SWITCH_COUNT parameter) and then change to the"]
#[doc = "\tnew channel. Userspace provides the new channel information (using"]
#[doc = "\t%NL80211_ATTR_WIPHY_FREQ and the attributes determining channel"]
#[doc = "\twidth). %NL80211_ATTR_CH_SWITCH_BLOCK_TX may be supplied to inform"]
#[doc = "\tother station that transmission must be blocked until the channel"]
#[doc = "\tswitch is complete."]
#[doc = ""]
#[doc = " @NL80211_CMD_VENDOR: Vendor-specified command/event. The command is specified"]
#[doc = "\tby the %NL80211_ATTR_VENDOR_ID attribute and a sub-command in"]
#[doc = "\t%NL80211_ATTR_VENDOR_SUBCMD. Parameter(s) can be transported in"]
#[doc = "\t%NL80211_ATTR_VENDOR_DATA."]
#[doc = "\tFor feature advertisement, the %NL80211_ATTR_VENDOR_DATA attribute is"]
#[doc = "\tused in the wiphy data as a nested attribute containing descriptions"]
#[doc = "\t(&struct nl80211_vendor_cmd_info) of the supported vendor commands."]
#[doc = "\tThis may also be sent as an event with the same attributes."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_QOS_MAP: Set Interworking QoS mapping for IP DSCP values."]
#[doc = "\tThe QoS mapping information is included in %NL80211_ATTR_QOS_MAP. If"]
#[doc = "\tthat attribute is not included, QoS mapping is disabled. Since this"]
#[doc = "\tQoS mapping is relevant for IP packets, it is only valid during an"]
#[doc = "\tassociation. This is cleared on disassociation and AP restart."]
#[doc = ""]
#[doc = " @NL80211_CMD_ADD_TX_TS: Ask the kernel to add a traffic stream for the given"]
#[doc = "\t%NL80211_ATTR_TSID and %NL80211_ATTR_MAC with %NL80211_ATTR_USER_PRIO"]
#[doc = "\tand %NL80211_ATTR_ADMITTED_TIME parameters."]
#[doc = "\tNote that the action frame handshake with the AP shall be handled by"]
#[doc = "\tuserspace via the normal management RX/TX framework, this only sets"]
#[doc = "\tup the TX TS in the driver/device."]
#[doc = "\tIf the admitted time attribute is not added then the request just checks"]
#[doc = "\tif a subsequent setup could be successful, the intent is to use this to"]
#[doc = "\tavoid setting up a session with the AP when local restrictions would"]
#[doc = "\tmake that impossible. However, the subsequent \"real\" setup may still"]
#[doc = "\tfail even if the check was successful."]
#[doc = " @NL80211_CMD_DEL_TX_TS: Remove an existing TS with the %NL80211_ATTR_TSID"]
#[doc = "\tand %NL80211_ATTR_MAC parameters. It isn't necessary to call this"]
#[doc = "\tbefore removing a station entry entirely, or before disassociating"]
#[doc = "\tor similar, cleanup will happen in the driver/device in this case."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_MPP: Get mesh path attributes for mesh proxy path to"]
#[doc = "\tdestination %NL80211_ATTR_MAC on the interface identified by"]
#[doc = "\t%NL80211_ATTR_IFINDEX."]
#[doc = ""]
#[doc = " @NL80211_CMD_JOIN_OCB: Join the OCB network. The center frequency and"]
#[doc = "\tbandwidth of a channel must be given."]
#[doc = " @NL80211_CMD_LEAVE_OCB: Leave the OCB network -- no special arguments, the"]
#[doc = "\tnetwork is determined by the network interface."]
#[doc = ""]
#[doc = " @NL80211_CMD_TDLS_CHANNEL_SWITCH: Start channel-switching with a TDLS peer,"]
#[doc = "\tidentified by the %NL80211_ATTR_MAC parameter. A target channel is"]
#[doc = "\tprovided via %NL80211_ATTR_WIPHY_FREQ and other attributes determining"]
#[doc = "\tchannel width/type. The target operating class is given via"]
#[doc = "\t%NL80211_ATTR_OPER_CLASS."]
#[doc = "\tThe driver is responsible for continually initiating channel-switching"]
#[doc = "\toperations and returning to the base channel for communication with the"]
#[doc = "\tAP."]
#[doc = " @NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH: Stop channel-switching with a TDLS"]
#[doc = "\tpeer given by %NL80211_ATTR_MAC. Both peers must be on the base channel"]
#[doc = "\twhen this command completes."]
#[doc = ""]
#[doc = " @NL80211_CMD_WIPHY_REG_CHANGE: Similar to %NL80211_CMD_REG_CHANGE, but used"]
#[doc = "\tas an event to indicate changes for devices with wiphy-specific regdom"]
#[doc = "\tmanagement."]
#[doc = ""]
#[doc = " @NL80211_CMD_ABORT_SCAN: Stop an ongoing scan. Returns -ENOENT if a scan is"]
#[doc = "\tnot running. The driver indicates the status of the scan through"]
#[doc = "\tcfg80211_scan_done()."]
#[doc = ""]
#[doc = " @NL80211_CMD_START_NAN: Start NAN operation, identified by its"]
#[doc = "\t%NL80211_ATTR_WDEV interface. This interface must have been"]
#[doc = "\tpreviously created with %NL80211_CMD_NEW_INTERFACE. After it"]
#[doc = "\thas been started, the NAN interface will create or join a"]
#[doc = "\tcluster. This command must have a valid"]
#[doc = "\t%NL80211_ATTR_NAN_MASTER_PREF attribute and optional"]
#[doc = "\t%NL80211_ATTR_BANDS attributes.  If %NL80211_ATTR_BANDS is"]
#[doc = "\tomitted or set to 0, it means don't-care and the device will"]
#[doc = "\tdecide what to use.  After this command NAN functions can be"]
#[doc = "\tadded."]
#[doc = " @NL80211_CMD_STOP_NAN: Stop the NAN operation, identified by"]
#[doc = "\tits %NL80211_ATTR_WDEV interface."]
#[doc = " @NL80211_CMD_ADD_NAN_FUNCTION: Add a NAN function. The function is defined"]
#[doc = "\twith %NL80211_ATTR_NAN_FUNC nested attribute. When called, this"]
#[doc = "\toperation returns the strictly positive and unique instance id"]
#[doc = "\t(%NL80211_ATTR_NAN_FUNC_INST_ID) and a cookie (%NL80211_ATTR_COOKIE)"]
#[doc = "\tof the function upon success."]
#[doc = "\tSince instance ID's can be re-used, this cookie is the right"]
#[doc = "\tway to identify the function. This will avoid races when a termination"]
#[doc = "\tevent is handled by the user space after it has already added a new"]
#[doc = "\tfunction that got the same instance id from the kernel as the one"]
#[doc = "\twhich just terminated."]
#[doc = "\tThis cookie may be used in NAN events even before the command"]
#[doc = "\treturns, so userspace shouldn't process NAN events until it processes"]
#[doc = "\tthe response to this command."]
#[doc = "\tLook at %NL80211_ATTR_SOCKET_OWNER as well."]
#[doc = " @NL80211_CMD_DEL_NAN_FUNCTION: Delete a NAN function by cookie."]
#[doc = "\tThis command is also used as a notification sent when a NAN function is"]
#[doc = "\tterminated. This will contain a %NL80211_ATTR_NAN_FUNC_INST_ID"]
#[doc = "\tand %NL80211_ATTR_COOKIE attributes."]
#[doc = " @NL80211_CMD_CHANGE_NAN_CONFIG: Change current NAN"]
#[doc = "\tconfiguration. NAN must be operational (%NL80211_CMD_START_NAN"]
#[doc = "\twas executed).  It must contain at least one of the following"]
#[doc = "\tattributes: %NL80211_ATTR_NAN_MASTER_PREF,"]
#[doc = "\t%NL80211_ATTR_BANDS.  If %NL80211_ATTR_BANDS is omitted, the"]
#[doc = "\tcurrent configuration is not changed.  If it is present but"]
#[doc = "\tset to zero, the configuration is changed to don't-care"]
#[doc = "\t(i.e. the device can decide what to do)."]
#[doc = " @NL80211_CMD_NAN_FUNC_MATCH: Notification sent when a match is reported."]
#[doc = "\tThis will contain a %NL80211_ATTR_NAN_MATCH nested attribute and"]
#[doc = "\t%NL80211_ATTR_COOKIE."]
#[doc = ""]
#[doc = " @NL80211_CMD_UPDATE_CONNECT_PARAMS: Update one or more connect parameters"]
#[doc = "\tfor subsequent roaming cases if the driver or firmware uses internal"]
#[doc = "\tBSS selection. This command can be issued only while connected and it"]
#[doc = "\tdoes not result in a change for the current association. Currently,"]
#[doc = "\tonly the %NL80211_ATTR_IE data is used and updated with this command."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_PMK: For offloaded 4-Way handshake, set the PMK or PMK-R0"]
#[doc = "\tfor the given authenticator address (specified with %NL80211_ATTR_MAC)."]
#[doc = "\tWhen %NL80211_ATTR_PMKR0_NAME is set, %NL80211_ATTR_PMK specifies the"]
#[doc = "\tPMK-R0, otherwise it specifies the PMK."]
#[doc = " @NL80211_CMD_DEL_PMK: For offloaded 4-Way handshake, delete the previously"]
#[doc = "\tconfigured PMK for the authenticator address identified by"]
#[doc = "\t%NL80211_ATTR_MAC."]
#[doc = " @NL80211_CMD_PORT_AUTHORIZED: An event that indicates an 802.1X FT roam was"]
#[doc = "\tcompleted successfully. Drivers that support 4 way handshake offload"]
#[doc = "\tshould send this event after indicating 802.1X FT assocation with"]
#[doc = "\t%NL80211_CMD_ROAM. If the 4 way handshake failed %NL80211_CMD_DISCONNECT"]
#[doc = "\tshould be indicated instead."]
#[doc = " @NL80211_CMD_CONTROL_PORT_FRAME: Control Port (e.g. PAE) frame TX request"]
#[doc = "\tand RX notification.  This command is used both as a request to transmit"]
#[doc = "\ta control port frame and as a notification that a control port frame"]
#[doc = "\thas been received. %NL80211_ATTR_FRAME is used to specify the"]
#[doc = "\tframe contents.  The frame is the raw EAPoL data, without ethernet or"]
#[doc = "\t802.11 headers."]
#[doc = "\tWhen used as an event indication %NL80211_ATTR_CONTROL_PORT_ETHERTYPE,"]
#[doc = "\t%NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT and %NL80211_ATTR_MAC are added"]
#[doc = "\tindicating the protocol type of the received frame; whether the frame"]
#[doc = "\twas received unencrypted and the MAC address of the peer respectively."]
#[doc = ""]
#[doc = " @NL80211_CMD_RELOAD_REGDB: Request that the regdb firmware file is reloaded."]
#[doc = ""]
#[doc = " @NL80211_CMD_EXTERNAL_AUTH: This interface is exclusively defined for host"]
#[doc = "\tdrivers that do not define separate commands for authentication and"]
#[doc = "\tassociation, but rely on user space for the authentication to happen."]
#[doc = "\tThis interface acts both as the event request (driver to user space)"]
#[doc = "\tto trigger the authentication and command response (userspace to"]
#[doc = "\tdriver) to indicate the authentication status."]
#[doc = ""]
#[doc = "\tUser space uses the %NL80211_CMD_CONNECT command to the host driver to"]
#[doc = "\ttrigger a connection. The host driver selects a BSS and further uses"]
#[doc = "\tthis interface to offload only the authentication part to the user"]
#[doc = "\tspace. Authentication frames are passed between the driver and user"]
#[doc = "\tspace through the %NL80211_CMD_FRAME interface. Host driver proceeds"]
#[doc = "\tfurther with the association after getting successful authentication"]
#[doc = "\tstatus. User space indicates the authentication status through"]
#[doc = "\t%NL80211_ATTR_STATUS_CODE attribute in %NL80211_CMD_EXTERNAL_AUTH"]
#[doc = "\tcommand interface."]
#[doc = ""]
#[doc = "\tHost driver reports this status on an authentication failure to the"]
#[doc = "\tuser space through the connect result as the user space would have"]
#[doc = "\tinitiated the connection through the connect request."]
#[doc = ""]
#[doc = " @NL80211_CMD_STA_OPMODE_CHANGED: An event that notify station's"]
#[doc = "\tht opmode or vht opmode changes using any of %NL80211_ATTR_SMPS_MODE,"]
#[doc = "\t%NL80211_ATTR_CHANNEL_WIDTH,%NL80211_ATTR_NSS attributes with its"]
#[doc = "\taddress(specified in %NL80211_ATTR_MAC)."]
#[doc = ""]
#[doc = " @NL80211_CMD_GET_FTM_RESPONDER_STATS: Retrieve FTM responder statistics, in"]
#[doc = "\tthe %NL80211_ATTR_FTM_RESPONDER_STATS attribute."]
#[doc = ""]
#[doc = " @NL80211_CMD_PEER_MEASUREMENT_START: start a (set of) peer measurement(s)"]
#[doc = "\twith the given parameters, which are encapsulated in the nested"]
#[doc = "\t%NL80211_ATTR_PEER_MEASUREMENTS attribute. Optionally, MAC address"]
#[doc = "\trandomization may be enabled and configured by specifying the"]
#[doc = "\t%NL80211_ATTR_MAC and %NL80211_ATTR_MAC_MASK attributes."]
#[doc = "\tIf a timeout is requested, use the %NL80211_ATTR_TIMEOUT attribute."]
#[doc = "\tA u64 cookie for further %NL80211_ATTR_COOKIE use is returned in"]
#[doc = "\tthe netlink extended ack message."]
#[doc = ""]
#[doc = "\tTo cancel a measurement, close the socket that requested it."]
#[doc = ""]
#[doc = "\tMeasurement results are reported to the socket that requested the"]
#[doc = "\tmeasurement using @NL80211_CMD_PEER_MEASUREMENT_RESULT when they"]
#[doc = "\tbecome available, so applications must ensure a large enough socket"]
#[doc = "\tbuffer size."]
#[doc = ""]
#[doc = "\tDepending on driver support it may or may not be possible to start"]
#[doc = "\tmultiple concurrent measurements."]
#[doc = " @NL80211_CMD_PEER_MEASUREMENT_RESULT: This command number is used for the"]
#[doc = "\tresult notification from the driver to the requesting socket."]
#[doc = " @NL80211_CMD_PEER_MEASUREMENT_COMPLETE: Notification only, indicating that"]
#[doc = "\tthe measurement completed, using the measurement cookie"]
#[doc = "\t(%NL80211_ATTR_COOKIE)."]
#[doc = ""]
#[doc = " @NL80211_CMD_NOTIFY_RADAR: Notify the kernel that a radar signal was"]
#[doc = "\tdetected and reported by a neighboring device on the channel"]
#[doc = "\tindicated by %NL80211_ATTR_WIPHY_FREQ and other attributes"]
#[doc = "\tdetermining the width and type."]
#[doc = ""]
#[doc = " @NL80211_CMD_UPDATE_OWE_INFO: This interface allows the host driver to"]
#[doc = "\toffload OWE processing to user space. This intends to support"]
#[doc = "\tOWE AKM by the host drivers that implement SME but rely"]
#[doc = "\ton the user space for the cryptographic/DH IE processing in AP mode."]
#[doc = ""]
#[doc = " @NL80211_CMD_PROBE_MESH_LINK: The requirement for mesh link metric"]
#[doc = "\trefreshing, is that from one mesh point we be able to send some data"]
#[doc = "\tframes to other mesh points which are not currently selected as a"]
#[doc = "\tprimary traffic path, but which are only 1 hop away. The absence of"]
#[doc = "\tthe primary path to the chosen node makes it necessary to apply some"]
#[doc = "\tform of marking on a chosen packet stream so that the packets can be"]
#[doc = "\tproperly steered to the selected node for testing, and not by the"]
#[doc = "\tregular mesh path lookup. Further, the packets must be of type data"]
#[doc = "\tso that the rate control (often embedded in firmware) is used for"]
#[doc = "\trate selection."]
#[doc = ""]
#[doc = "\tHere attribute %NL80211_ATTR_MAC is used to specify connected mesh"]
#[doc = "\tpeer MAC address and %NL80211_ATTR_FRAME is used to specify the frame"]
#[doc = "\tcontent. The frame is ethernet data."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_TID_CONFIG: Data frame TID specific configuration"]
#[doc = "\tis passed using %NL80211_ATTR_TID_CONFIG attribute."]
#[doc = ""]
#[doc = " @NL80211_CMD_UNPROT_BEACON: Unprotected or incorrectly protected Beacon"]
#[doc = "\tframe. This event is used to indicate that a received Beacon frame was"]
#[doc = "\tdropped because it did not include a valid MME MIC while beacon"]
#[doc = "\tprotection was enabled (BIGTK configured in station mode)."]
#[doc = ""]
#[doc = " @NL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS: Report TX status of a control"]
#[doc = "\tport frame transmitted with %NL80211_CMD_CONTROL_PORT_FRAME."]
#[doc = "\t%NL80211_ATTR_COOKIE identifies the TX command and %NL80211_ATTR_FRAME"]
#[doc = "\tincludes the contents of the frame. %NL80211_ATTR_ACK flag is included"]
#[doc = "\tif the recipient acknowledged the frame."]
#[doc = ""]
#[doc = " @NL80211_CMD_SET_SAR_SPECS: SAR power limitation configuration is"]
#[doc = "\tpassed using %NL80211_ATTR_SAR_SPEC. %NL80211_ATTR_WIPHY is used to"]
#[doc = "\tspecify the wiphy index to be applied to."]
#[doc = ""]
#[doc = " @NL80211_CMD_MAX: highest used command number"]
#[doc = " @__NL80211_CMD_AFTER_LAST: internal use"]
pub type nl80211_commands = ::std::os::raw::c_uint;
pub const nl80211_attrs_NL80211_ATTR_UNSPEC: nl80211_attrs = 0;
pub const nl80211_attrs_NL80211_ATTR_WIPHY: nl80211_attrs = 1;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_NAME: nl80211_attrs = 2;
pub const nl80211_attrs_NL80211_ATTR_IFINDEX: nl80211_attrs = 3;
pub const nl80211_attrs_NL80211_ATTR_IFNAME: nl80211_attrs = 4;
pub const nl80211_attrs_NL80211_ATTR_IFTYPE: nl80211_attrs = 5;
pub const nl80211_attrs_NL80211_ATTR_MAC: nl80211_attrs = 6;
pub const nl80211_attrs_NL80211_ATTR_KEY_DATA: nl80211_attrs = 7;
pub const nl80211_attrs_NL80211_ATTR_KEY_IDX: nl80211_attrs = 8;
pub const nl80211_attrs_NL80211_ATTR_KEY_CIPHER: nl80211_attrs = 9;
pub const nl80211_attrs_NL80211_ATTR_KEY_SEQ: nl80211_attrs = 10;
pub const nl80211_attrs_NL80211_ATTR_KEY_DEFAULT: nl80211_attrs = 11;
pub const nl80211_attrs_NL80211_ATTR_BEACON_INTERVAL: nl80211_attrs = 12;
pub const nl80211_attrs_NL80211_ATTR_DTIM_PERIOD: nl80211_attrs = 13;
pub const nl80211_attrs_NL80211_ATTR_BEACON_HEAD: nl80211_attrs = 14;
pub const nl80211_attrs_NL80211_ATTR_BEACON_TAIL: nl80211_attrs = 15;
pub const nl80211_attrs_NL80211_ATTR_STA_AID: nl80211_attrs = 16;
pub const nl80211_attrs_NL80211_ATTR_STA_FLAGS: nl80211_attrs = 17;
pub const nl80211_attrs_NL80211_ATTR_STA_LISTEN_INTERVAL: nl80211_attrs = 18;
pub const nl80211_attrs_NL80211_ATTR_STA_SUPPORTED_RATES: nl80211_attrs = 19;
pub const nl80211_attrs_NL80211_ATTR_STA_VLAN: nl80211_attrs = 20;
pub const nl80211_attrs_NL80211_ATTR_STA_INFO: nl80211_attrs = 21;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_BANDS: nl80211_attrs = 22;
pub const nl80211_attrs_NL80211_ATTR_MNTR_FLAGS: nl80211_attrs = 23;
pub const nl80211_attrs_NL80211_ATTR_MESH_ID: nl80211_attrs = 24;
pub const nl80211_attrs_NL80211_ATTR_STA_PLINK_ACTION: nl80211_attrs = 25;
pub const nl80211_attrs_NL80211_ATTR_MPATH_NEXT_HOP: nl80211_attrs = 26;
pub const nl80211_attrs_NL80211_ATTR_MPATH_INFO: nl80211_attrs = 27;
pub const nl80211_attrs_NL80211_ATTR_BSS_CTS_PROT: nl80211_attrs = 28;
pub const nl80211_attrs_NL80211_ATTR_BSS_SHORT_PREAMBLE: nl80211_attrs = 29;
pub const nl80211_attrs_NL80211_ATTR_BSS_SHORT_SLOT_TIME: nl80211_attrs = 30;
pub const nl80211_attrs_NL80211_ATTR_HT_CAPABILITY: nl80211_attrs = 31;
pub const nl80211_attrs_NL80211_ATTR_SUPPORTED_IFTYPES: nl80211_attrs = 32;
pub const nl80211_attrs_NL80211_ATTR_REG_ALPHA2: nl80211_attrs = 33;
pub const nl80211_attrs_NL80211_ATTR_REG_RULES: nl80211_attrs = 34;
pub const nl80211_attrs_NL80211_ATTR_MESH_CONFIG: nl80211_attrs = 35;
pub const nl80211_attrs_NL80211_ATTR_BSS_BASIC_RATES: nl80211_attrs = 36;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_TXQ_PARAMS: nl80211_attrs = 37;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_FREQ: nl80211_attrs = 38;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_CHANNEL_TYPE: nl80211_attrs = 39;
pub const nl80211_attrs_NL80211_ATTR_KEY_DEFAULT_MGMT: nl80211_attrs = 40;
pub const nl80211_attrs_NL80211_ATTR_MGMT_SUBTYPE: nl80211_attrs = 41;
pub const nl80211_attrs_NL80211_ATTR_IE: nl80211_attrs = 42;
pub const nl80211_attrs_NL80211_ATTR_MAX_NUM_SCAN_SSIDS: nl80211_attrs = 43;
pub const nl80211_attrs_NL80211_ATTR_SCAN_FREQUENCIES: nl80211_attrs = 44;
pub const nl80211_attrs_NL80211_ATTR_SCAN_SSIDS: nl80211_attrs = 45;
pub const nl80211_attrs_NL80211_ATTR_GENERATION: nl80211_attrs = 46;
pub const nl80211_attrs_NL80211_ATTR_BSS: nl80211_attrs = 47;
pub const nl80211_attrs_NL80211_ATTR_REG_INITIATOR: nl80211_attrs = 48;
pub const nl80211_attrs_NL80211_ATTR_REG_TYPE: nl80211_attrs = 49;
pub const nl80211_attrs_NL80211_ATTR_SUPPORTED_COMMANDS: nl80211_attrs = 50;
pub const nl80211_attrs_NL80211_ATTR_FRAME: nl80211_attrs = 51;
pub const nl80211_attrs_NL80211_ATTR_SSID: nl80211_attrs = 52;
pub const nl80211_attrs_NL80211_ATTR_AUTH_TYPE: nl80211_attrs = 53;
pub const nl80211_attrs_NL80211_ATTR_REASON_CODE: nl80211_attrs = 54;
pub const nl80211_attrs_NL80211_ATTR_KEY_TYPE: nl80211_attrs = 55;
pub const nl80211_attrs_NL80211_ATTR_MAX_SCAN_IE_LEN: nl80211_attrs = 56;
pub const nl80211_attrs_NL80211_ATTR_CIPHER_SUITES: nl80211_attrs = 57;
pub const nl80211_attrs_NL80211_ATTR_FREQ_BEFORE: nl80211_attrs = 58;
pub const nl80211_attrs_NL80211_ATTR_FREQ_AFTER: nl80211_attrs = 59;
pub const nl80211_attrs_NL80211_ATTR_FREQ_FIXED: nl80211_attrs = 60;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_RETRY_SHORT: nl80211_attrs = 61;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_RETRY_LONG: nl80211_attrs = 62;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_FRAG_THRESHOLD: nl80211_attrs = 63;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_RTS_THRESHOLD: nl80211_attrs = 64;
pub const nl80211_attrs_NL80211_ATTR_TIMED_OUT: nl80211_attrs = 65;
pub const nl80211_attrs_NL80211_ATTR_USE_MFP: nl80211_attrs = 66;
pub const nl80211_attrs_NL80211_ATTR_STA_FLAGS2: nl80211_attrs = 67;
pub const nl80211_attrs_NL80211_ATTR_CONTROL_PORT: nl80211_attrs = 68;
pub const nl80211_attrs_NL80211_ATTR_TESTDATA: nl80211_attrs = 69;
pub const nl80211_attrs_NL80211_ATTR_PRIVACY: nl80211_attrs = 70;
pub const nl80211_attrs_NL80211_ATTR_DISCONNECTED_BY_AP: nl80211_attrs = 71;
pub const nl80211_attrs_NL80211_ATTR_STATUS_CODE: nl80211_attrs = 72;
pub const nl80211_attrs_NL80211_ATTR_CIPHER_SUITES_PAIRWISE: nl80211_attrs = 73;
pub const nl80211_attrs_NL80211_ATTR_CIPHER_SUITE_GROUP: nl80211_attrs = 74;
pub const nl80211_attrs_NL80211_ATTR_WPA_VERSIONS: nl80211_attrs = 75;
pub const nl80211_attrs_NL80211_ATTR_AKM_SUITES: nl80211_attrs = 76;
pub const nl80211_attrs_NL80211_ATTR_REQ_IE: nl80211_attrs = 77;
pub const nl80211_attrs_NL80211_ATTR_RESP_IE: nl80211_attrs = 78;
pub const nl80211_attrs_NL80211_ATTR_PREV_BSSID: nl80211_attrs = 79;
pub const nl80211_attrs_NL80211_ATTR_KEY: nl80211_attrs = 80;
pub const nl80211_attrs_NL80211_ATTR_KEYS: nl80211_attrs = 81;
pub const nl80211_attrs_NL80211_ATTR_PID: nl80211_attrs = 82;
pub const nl80211_attrs_NL80211_ATTR_4ADDR: nl80211_attrs = 83;
pub const nl80211_attrs_NL80211_ATTR_SURVEY_INFO: nl80211_attrs = 84;
pub const nl80211_attrs_NL80211_ATTR_PMKID: nl80211_attrs = 85;
pub const nl80211_attrs_NL80211_ATTR_MAX_NUM_PMKIDS: nl80211_attrs = 86;
pub const nl80211_attrs_NL80211_ATTR_DURATION: nl80211_attrs = 87;
pub const nl80211_attrs_NL80211_ATTR_COOKIE: nl80211_attrs = 88;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_COVERAGE_CLASS: nl80211_attrs = 89;
pub const nl80211_attrs_NL80211_ATTR_TX_RATES: nl80211_attrs = 90;
pub const nl80211_attrs_NL80211_ATTR_FRAME_MATCH: nl80211_attrs = 91;
pub const nl80211_attrs_NL80211_ATTR_ACK: nl80211_attrs = 92;
pub const nl80211_attrs_NL80211_ATTR_PS_STATE: nl80211_attrs = 93;
pub const nl80211_attrs_NL80211_ATTR_CQM: nl80211_attrs = 94;
pub const nl80211_attrs_NL80211_ATTR_LOCAL_STATE_CHANGE: nl80211_attrs = 95;
pub const nl80211_attrs_NL80211_ATTR_AP_ISOLATE: nl80211_attrs = 96;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_TX_POWER_SETTING: nl80211_attrs = 97;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_TX_POWER_LEVEL: nl80211_attrs = 98;
pub const nl80211_attrs_NL80211_ATTR_TX_FRAME_TYPES: nl80211_attrs = 99;
pub const nl80211_attrs_NL80211_ATTR_RX_FRAME_TYPES: nl80211_attrs = 100;
pub const nl80211_attrs_NL80211_ATTR_FRAME_TYPE: nl80211_attrs = 101;
pub const nl80211_attrs_NL80211_ATTR_CONTROL_PORT_ETHERTYPE: nl80211_attrs = 102;
pub const nl80211_attrs_NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT: nl80211_attrs = 103;
pub const nl80211_attrs_NL80211_ATTR_SUPPORT_IBSS_RSN: nl80211_attrs = 104;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_ANTENNA_TX: nl80211_attrs = 105;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_ANTENNA_RX: nl80211_attrs = 106;
pub const nl80211_attrs_NL80211_ATTR_MCAST_RATE: nl80211_attrs = 107;
pub const nl80211_attrs_NL80211_ATTR_OFFCHANNEL_TX_OK: nl80211_attrs = 108;
pub const nl80211_attrs_NL80211_ATTR_BSS_HT_OPMODE: nl80211_attrs = 109;
pub const nl80211_attrs_NL80211_ATTR_KEY_DEFAULT_TYPES: nl80211_attrs = 110;
pub const nl80211_attrs_NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION: nl80211_attrs = 111;
pub const nl80211_attrs_NL80211_ATTR_MESH_SETUP: nl80211_attrs = 112;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX: nl80211_attrs = 113;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX: nl80211_attrs = 114;
pub const nl80211_attrs_NL80211_ATTR_SUPPORT_MESH_AUTH: nl80211_attrs = 115;
pub const nl80211_attrs_NL80211_ATTR_STA_PLINK_STATE: nl80211_attrs = 116;
pub const nl80211_attrs_NL80211_ATTR_WOWLAN_TRIGGERS: nl80211_attrs = 117;
pub const nl80211_attrs_NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED: nl80211_attrs = 118;
pub const nl80211_attrs_NL80211_ATTR_SCHED_SCAN_INTERVAL: nl80211_attrs = 119;
pub const nl80211_attrs_NL80211_ATTR_INTERFACE_COMBINATIONS: nl80211_attrs = 120;
pub const nl80211_attrs_NL80211_ATTR_SOFTWARE_IFTYPES: nl80211_attrs = 121;
pub const nl80211_attrs_NL80211_ATTR_REKEY_DATA: nl80211_attrs = 122;
pub const nl80211_attrs_NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS: nl80211_attrs = 123;
pub const nl80211_attrs_NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN: nl80211_attrs = 124;
pub const nl80211_attrs_NL80211_ATTR_SCAN_SUPP_RATES: nl80211_attrs = 125;
pub const nl80211_attrs_NL80211_ATTR_HIDDEN_SSID: nl80211_attrs = 126;
pub const nl80211_attrs_NL80211_ATTR_IE_PROBE_RESP: nl80211_attrs = 127;
pub const nl80211_attrs_NL80211_ATTR_IE_ASSOC_RESP: nl80211_attrs = 128;
pub const nl80211_attrs_NL80211_ATTR_STA_WME: nl80211_attrs = 129;
pub const nl80211_attrs_NL80211_ATTR_SUPPORT_AP_UAPSD: nl80211_attrs = 130;
pub const nl80211_attrs_NL80211_ATTR_ROAM_SUPPORT: nl80211_attrs = 131;
pub const nl80211_attrs_NL80211_ATTR_SCHED_SCAN_MATCH: nl80211_attrs = 132;
pub const nl80211_attrs_NL80211_ATTR_MAX_MATCH_SETS: nl80211_attrs = 133;
pub const nl80211_attrs_NL80211_ATTR_PMKSA_CANDIDATE: nl80211_attrs = 134;
pub const nl80211_attrs_NL80211_ATTR_TX_NO_CCK_RATE: nl80211_attrs = 135;
pub const nl80211_attrs_NL80211_ATTR_TDLS_ACTION: nl80211_attrs = 136;
pub const nl80211_attrs_NL80211_ATTR_TDLS_DIALOG_TOKEN: nl80211_attrs = 137;
pub const nl80211_attrs_NL80211_ATTR_TDLS_OPERATION: nl80211_attrs = 138;
pub const nl80211_attrs_NL80211_ATTR_TDLS_SUPPORT: nl80211_attrs = 139;
pub const nl80211_attrs_NL80211_ATTR_TDLS_EXTERNAL_SETUP: nl80211_attrs = 140;
pub const nl80211_attrs_NL80211_ATTR_DEVICE_AP_SME: nl80211_attrs = 141;
pub const nl80211_attrs_NL80211_ATTR_DONT_WAIT_FOR_ACK: nl80211_attrs = 142;
pub const nl80211_attrs_NL80211_ATTR_FEATURE_FLAGS: nl80211_attrs = 143;
pub const nl80211_attrs_NL80211_ATTR_PROBE_RESP_OFFLOAD: nl80211_attrs = 144;
pub const nl80211_attrs_NL80211_ATTR_PROBE_RESP: nl80211_attrs = 145;
pub const nl80211_attrs_NL80211_ATTR_DFS_REGION: nl80211_attrs = 146;
pub const nl80211_attrs_NL80211_ATTR_DISABLE_HT: nl80211_attrs = 147;
pub const nl80211_attrs_NL80211_ATTR_HT_CAPABILITY_MASK: nl80211_attrs = 148;
pub const nl80211_attrs_NL80211_ATTR_NOACK_MAP: nl80211_attrs = 149;
pub const nl80211_attrs_NL80211_ATTR_INACTIVITY_TIMEOUT: nl80211_attrs = 150;
pub const nl80211_attrs_NL80211_ATTR_RX_SIGNAL_DBM: nl80211_attrs = 151;
pub const nl80211_attrs_NL80211_ATTR_BG_SCAN_PERIOD: nl80211_attrs = 152;
pub const nl80211_attrs_NL80211_ATTR_WDEV: nl80211_attrs = 153;
pub const nl80211_attrs_NL80211_ATTR_USER_REG_HINT_TYPE: nl80211_attrs = 154;
pub const nl80211_attrs_NL80211_ATTR_CONN_FAILED_REASON: nl80211_attrs = 155;
pub const nl80211_attrs_NL80211_ATTR_AUTH_DATA: nl80211_attrs = 156;
pub const nl80211_attrs_NL80211_ATTR_VHT_CAPABILITY: nl80211_attrs = 157;
pub const nl80211_attrs_NL80211_ATTR_SCAN_FLAGS: nl80211_attrs = 158;
pub const nl80211_attrs_NL80211_ATTR_CHANNEL_WIDTH: nl80211_attrs = 159;
pub const nl80211_attrs_NL80211_ATTR_CENTER_FREQ1: nl80211_attrs = 160;
pub const nl80211_attrs_NL80211_ATTR_CENTER_FREQ2: nl80211_attrs = 161;
pub const nl80211_attrs_NL80211_ATTR_P2P_CTWINDOW: nl80211_attrs = 162;
pub const nl80211_attrs_NL80211_ATTR_P2P_OPPPS: nl80211_attrs = 163;
pub const nl80211_attrs_NL80211_ATTR_LOCAL_MESH_POWER_MODE: nl80211_attrs = 164;
pub const nl80211_attrs_NL80211_ATTR_ACL_POLICY: nl80211_attrs = 165;
pub const nl80211_attrs_NL80211_ATTR_MAC_ADDRS: nl80211_attrs = 166;
pub const nl80211_attrs_NL80211_ATTR_MAC_ACL_MAX: nl80211_attrs = 167;
pub const nl80211_attrs_NL80211_ATTR_RADAR_EVENT: nl80211_attrs = 168;
pub const nl80211_attrs_NL80211_ATTR_EXT_CAPA: nl80211_attrs = 169;
pub const nl80211_attrs_NL80211_ATTR_EXT_CAPA_MASK: nl80211_attrs = 170;
pub const nl80211_attrs_NL80211_ATTR_STA_CAPABILITY: nl80211_attrs = 171;
pub const nl80211_attrs_NL80211_ATTR_STA_EXT_CAPABILITY: nl80211_attrs = 172;
pub const nl80211_attrs_NL80211_ATTR_PROTOCOL_FEATURES: nl80211_attrs = 173;
pub const nl80211_attrs_NL80211_ATTR_SPLIT_WIPHY_DUMP: nl80211_attrs = 174;
pub const nl80211_attrs_NL80211_ATTR_DISABLE_VHT: nl80211_attrs = 175;
pub const nl80211_attrs_NL80211_ATTR_VHT_CAPABILITY_MASK: nl80211_attrs = 176;
pub const nl80211_attrs_NL80211_ATTR_MDID: nl80211_attrs = 177;
pub const nl80211_attrs_NL80211_ATTR_IE_RIC: nl80211_attrs = 178;
pub const nl80211_attrs_NL80211_ATTR_CRIT_PROT_ID: nl80211_attrs = 179;
pub const nl80211_attrs_NL80211_ATTR_MAX_CRIT_PROT_DURATION: nl80211_attrs = 180;
pub const nl80211_attrs_NL80211_ATTR_PEER_AID: nl80211_attrs = 181;
pub const nl80211_attrs_NL80211_ATTR_COALESCE_RULE: nl80211_attrs = 182;
pub const nl80211_attrs_NL80211_ATTR_CH_SWITCH_COUNT: nl80211_attrs = 183;
pub const nl80211_attrs_NL80211_ATTR_CH_SWITCH_BLOCK_TX: nl80211_attrs = 184;
pub const nl80211_attrs_NL80211_ATTR_CSA_IES: nl80211_attrs = 185;
pub const nl80211_attrs_NL80211_ATTR_CNTDWN_OFFS_BEACON: nl80211_attrs = 186;
pub const nl80211_attrs_NL80211_ATTR_CNTDWN_OFFS_PRESP: nl80211_attrs = 187;
pub const nl80211_attrs_NL80211_ATTR_RXMGMT_FLAGS: nl80211_attrs = 188;
pub const nl80211_attrs_NL80211_ATTR_STA_SUPPORTED_CHANNELS: nl80211_attrs = 189;
pub const nl80211_attrs_NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES: nl80211_attrs = 190;
pub const nl80211_attrs_NL80211_ATTR_HANDLE_DFS: nl80211_attrs = 191;
pub const nl80211_attrs_NL80211_ATTR_SUPPORT_5_MHZ: nl80211_attrs = 192;
pub const nl80211_attrs_NL80211_ATTR_SUPPORT_10_MHZ: nl80211_attrs = 193;
pub const nl80211_attrs_NL80211_ATTR_OPMODE_NOTIF: nl80211_attrs = 194;
pub const nl80211_attrs_NL80211_ATTR_VENDOR_ID: nl80211_attrs = 195;
pub const nl80211_attrs_NL80211_ATTR_VENDOR_SUBCMD: nl80211_attrs = 196;
pub const nl80211_attrs_NL80211_ATTR_VENDOR_DATA: nl80211_attrs = 197;
pub const nl80211_attrs_NL80211_ATTR_VENDOR_EVENTS: nl80211_attrs = 198;
pub const nl80211_attrs_NL80211_ATTR_QOS_MAP: nl80211_attrs = 199;
pub const nl80211_attrs_NL80211_ATTR_MAC_HINT: nl80211_attrs = 200;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_FREQ_HINT: nl80211_attrs = 201;
pub const nl80211_attrs_NL80211_ATTR_MAX_AP_ASSOC_STA: nl80211_attrs = 202;
pub const nl80211_attrs_NL80211_ATTR_TDLS_PEER_CAPABILITY: nl80211_attrs = 203;
pub const nl80211_attrs_NL80211_ATTR_SOCKET_OWNER: nl80211_attrs = 204;
pub const nl80211_attrs_NL80211_ATTR_CSA_C_OFFSETS_TX: nl80211_attrs = 205;
pub const nl80211_attrs_NL80211_ATTR_MAX_CSA_COUNTERS: nl80211_attrs = 206;
pub const nl80211_attrs_NL80211_ATTR_TDLS_INITIATOR: nl80211_attrs = 207;
pub const nl80211_attrs_NL80211_ATTR_USE_RRM: nl80211_attrs = 208;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_DYN_ACK: nl80211_attrs = 209;
pub const nl80211_attrs_NL80211_ATTR_TSID: nl80211_attrs = 210;
pub const nl80211_attrs_NL80211_ATTR_USER_PRIO: nl80211_attrs = 211;
pub const nl80211_attrs_NL80211_ATTR_ADMITTED_TIME: nl80211_attrs = 212;
pub const nl80211_attrs_NL80211_ATTR_SMPS_MODE: nl80211_attrs = 213;
pub const nl80211_attrs_NL80211_ATTR_OPER_CLASS: nl80211_attrs = 214;
pub const nl80211_attrs_NL80211_ATTR_MAC_MASK: nl80211_attrs = 215;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_SELF_MANAGED_REG: nl80211_attrs = 216;
pub const nl80211_attrs_NL80211_ATTR_EXT_FEATURES: nl80211_attrs = 217;
pub const nl80211_attrs_NL80211_ATTR_SURVEY_RADIO_STATS: nl80211_attrs = 218;
pub const nl80211_attrs_NL80211_ATTR_NETNS_FD: nl80211_attrs = 219;
pub const nl80211_attrs_NL80211_ATTR_SCHED_SCAN_DELAY: nl80211_attrs = 220;
pub const nl80211_attrs_NL80211_ATTR_REG_INDOOR: nl80211_attrs = 221;
pub const nl80211_attrs_NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS: nl80211_attrs = 222;
pub const nl80211_attrs_NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL: nl80211_attrs = 223;
pub const nl80211_attrs_NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS: nl80211_attrs = 224;
pub const nl80211_attrs_NL80211_ATTR_SCHED_SCAN_PLANS: nl80211_attrs = 225;
pub const nl80211_attrs_NL80211_ATTR_PBSS: nl80211_attrs = 226;
pub const nl80211_attrs_NL80211_ATTR_BSS_SELECT: nl80211_attrs = 227;
pub const nl80211_attrs_NL80211_ATTR_STA_SUPPORT_P2P_PS: nl80211_attrs = 228;
pub const nl80211_attrs_NL80211_ATTR_PAD: nl80211_attrs = 229;
pub const nl80211_attrs_NL80211_ATTR_IFTYPE_EXT_CAPA: nl80211_attrs = 230;
pub const nl80211_attrs_NL80211_ATTR_MU_MIMO_GROUP_DATA: nl80211_attrs = 231;
pub const nl80211_attrs_NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR: nl80211_attrs = 232;
pub const nl80211_attrs_NL80211_ATTR_SCAN_START_TIME_TSF: nl80211_attrs = 233;
pub const nl80211_attrs_NL80211_ATTR_SCAN_START_TIME_TSF_BSSID: nl80211_attrs = 234;
pub const nl80211_attrs_NL80211_ATTR_MEASUREMENT_DURATION: nl80211_attrs = 235;
pub const nl80211_attrs_NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY: nl80211_attrs = 236;
pub const nl80211_attrs_NL80211_ATTR_MESH_PEER_AID: nl80211_attrs = 237;
pub const nl80211_attrs_NL80211_ATTR_NAN_MASTER_PREF: nl80211_attrs = 238;
pub const nl80211_attrs_NL80211_ATTR_BANDS: nl80211_attrs = 239;
pub const nl80211_attrs_NL80211_ATTR_NAN_FUNC: nl80211_attrs = 240;
pub const nl80211_attrs_NL80211_ATTR_NAN_MATCH: nl80211_attrs = 241;
pub const nl80211_attrs_NL80211_ATTR_FILS_KEK: nl80211_attrs = 242;
pub const nl80211_attrs_NL80211_ATTR_FILS_NONCES: nl80211_attrs = 243;
pub const nl80211_attrs_NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED: nl80211_attrs = 244;
pub const nl80211_attrs_NL80211_ATTR_BSSID: nl80211_attrs = 245;
pub const nl80211_attrs_NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI: nl80211_attrs = 246;
pub const nl80211_attrs_NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST: nl80211_attrs = 247;
pub const nl80211_attrs_NL80211_ATTR_TIMEOUT_REASON: nl80211_attrs = 248;
pub const nl80211_attrs_NL80211_ATTR_FILS_ERP_USERNAME: nl80211_attrs = 249;
pub const nl80211_attrs_NL80211_ATTR_FILS_ERP_REALM: nl80211_attrs = 250;
pub const nl80211_attrs_NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM: nl80211_attrs = 251;
pub const nl80211_attrs_NL80211_ATTR_FILS_ERP_RRK: nl80211_attrs = 252;
pub const nl80211_attrs_NL80211_ATTR_FILS_CACHE_ID: nl80211_attrs = 253;
pub const nl80211_attrs_NL80211_ATTR_PMK: nl80211_attrs = 254;
pub const nl80211_attrs_NL80211_ATTR_SCHED_SCAN_MULTI: nl80211_attrs = 255;
pub const nl80211_attrs_NL80211_ATTR_SCHED_SCAN_MAX_REQS: nl80211_attrs = 256;
pub const nl80211_attrs_NL80211_ATTR_WANT_1X_4WAY_HS: nl80211_attrs = 257;
pub const nl80211_attrs_NL80211_ATTR_PMKR0_NAME: nl80211_attrs = 258;
pub const nl80211_attrs_NL80211_ATTR_PORT_AUTHORIZED: nl80211_attrs = 259;
pub const nl80211_attrs_NL80211_ATTR_EXTERNAL_AUTH_ACTION: nl80211_attrs = 260;
pub const nl80211_attrs_NL80211_ATTR_EXTERNAL_AUTH_SUPPORT: nl80211_attrs = 261;
pub const nl80211_attrs_NL80211_ATTR_NSS: nl80211_attrs = 262;
pub const nl80211_attrs_NL80211_ATTR_ACK_SIGNAL: nl80211_attrs = 263;
pub const nl80211_attrs_NL80211_ATTR_CONTROL_PORT_OVER_NL80211: nl80211_attrs = 264;
pub const nl80211_attrs_NL80211_ATTR_TXQ_STATS: nl80211_attrs = 265;
pub const nl80211_attrs_NL80211_ATTR_TXQ_LIMIT: nl80211_attrs = 266;
pub const nl80211_attrs_NL80211_ATTR_TXQ_MEMORY_LIMIT: nl80211_attrs = 267;
pub const nl80211_attrs_NL80211_ATTR_TXQ_QUANTUM: nl80211_attrs = 268;
pub const nl80211_attrs_NL80211_ATTR_HE_CAPABILITY: nl80211_attrs = 269;
pub const nl80211_attrs_NL80211_ATTR_FTM_RESPONDER: nl80211_attrs = 270;
pub const nl80211_attrs_NL80211_ATTR_FTM_RESPONDER_STATS: nl80211_attrs = 271;
pub const nl80211_attrs_NL80211_ATTR_TIMEOUT: nl80211_attrs = 272;
pub const nl80211_attrs_NL80211_ATTR_PEER_MEASUREMENTS: nl80211_attrs = 273;
pub const nl80211_attrs_NL80211_ATTR_AIRTIME_WEIGHT: nl80211_attrs = 274;
pub const nl80211_attrs_NL80211_ATTR_STA_TX_POWER_SETTING: nl80211_attrs = 275;
pub const nl80211_attrs_NL80211_ATTR_STA_TX_POWER: nl80211_attrs = 276;
pub const nl80211_attrs_NL80211_ATTR_SAE_PASSWORD: nl80211_attrs = 277;
pub const nl80211_attrs_NL80211_ATTR_TWT_RESPONDER: nl80211_attrs = 278;
pub const nl80211_attrs_NL80211_ATTR_HE_OBSS_PD: nl80211_attrs = 279;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_EDMG_CHANNELS: nl80211_attrs = 280;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_EDMG_BW_CONFIG: nl80211_attrs = 281;
pub const nl80211_attrs_NL80211_ATTR_VLAN_ID: nl80211_attrs = 282;
pub const nl80211_attrs_NL80211_ATTR_HE_BSS_COLOR: nl80211_attrs = 283;
pub const nl80211_attrs_NL80211_ATTR_IFTYPE_AKM_SUITES: nl80211_attrs = 284;
pub const nl80211_attrs_NL80211_ATTR_TID_CONFIG: nl80211_attrs = 285;
pub const nl80211_attrs_NL80211_ATTR_CONTROL_PORT_NO_PREAUTH: nl80211_attrs = 286;
pub const nl80211_attrs_NL80211_ATTR_PMK_LIFETIME: nl80211_attrs = 287;
pub const nl80211_attrs_NL80211_ATTR_PMK_REAUTH_THRESHOLD: nl80211_attrs = 288;
pub const nl80211_attrs_NL80211_ATTR_RECEIVE_MULTICAST: nl80211_attrs = 289;
pub const nl80211_attrs_NL80211_ATTR_WIPHY_FREQ_OFFSET: nl80211_attrs = 290;
pub const nl80211_attrs_NL80211_ATTR_CENTER_FREQ1_OFFSET: nl80211_attrs = 291;
pub const nl80211_attrs_NL80211_ATTR_SCAN_FREQ_KHZ: nl80211_attrs = 292;
pub const nl80211_attrs_NL80211_ATTR_HE_6GHZ_CAPABILITY: nl80211_attrs = 293;
pub const nl80211_attrs_NL80211_ATTR_FILS_DISCOVERY: nl80211_attrs = 294;
pub const nl80211_attrs_NL80211_ATTR_UNSOL_BCAST_PROBE_RESP: nl80211_attrs = 295;
pub const nl80211_attrs_NL80211_ATTR_S1G_CAPABILITY: nl80211_attrs = 296;
pub const nl80211_attrs_NL80211_ATTR_S1G_CAPABILITY_MASK: nl80211_attrs = 297;
pub const nl80211_attrs_NL80211_ATTR_SAE_PWE: nl80211_attrs = 298;
pub const nl80211_attrs_NL80211_ATTR_RECONNECT_REQUESTED: nl80211_attrs = 299;
pub const nl80211_attrs_NL80211_ATTR_SAR_SPEC: nl80211_attrs = 300;
pub const nl80211_attrs_NL80211_ATTR_DISABLE_HE: nl80211_attrs = 301;
pub const nl80211_attrs___NL80211_ATTR_AFTER_LAST: nl80211_attrs = 302;
pub const nl80211_attrs_NUM_NL80211_ATTR: nl80211_attrs = 302;
pub const nl80211_attrs_NL80211_ATTR_MAX: nl80211_attrs = 301;
#[doc = " enum nl80211_attrs - nl80211 netlink attributes"]
#[doc = ""]
#[doc = " @NL80211_ATTR_UNSPEC: unspecified attribute to catch errors"]
#[doc = ""]
#[doc = " @NL80211_ATTR_WIPHY: index of wiphy to operate on, cf."]
#[doc = "\t/sys/class/ieee80211/<phyname>/index"]
#[doc = " @NL80211_ATTR_WIPHY_NAME: wiphy name (used for renaming)"]
#[doc = " @NL80211_ATTR_WIPHY_TXQ_PARAMS: a nested array of TX queue parameters"]
#[doc = " @NL80211_ATTR_WIPHY_FREQ: frequency of the selected channel in MHz,"]
#[doc = "\tdefines the channel together with the (deprecated)"]
#[doc = "\t%NL80211_ATTR_WIPHY_CHANNEL_TYPE attribute or the attributes"]
#[doc = "\t%NL80211_ATTR_CHANNEL_WIDTH and if needed %NL80211_ATTR_CENTER_FREQ1"]
#[doc = "\tand %NL80211_ATTR_CENTER_FREQ2"]
#[doc = " @NL80211_ATTR_CHANNEL_WIDTH: u32 attribute containing one of the values"]
#[doc = "\tof &enum nl80211_chan_width, describing the channel width. See the"]
#[doc = "\tdocumentation of the enum for more information."]
#[doc = " @NL80211_ATTR_CENTER_FREQ1: Center frequency of the first part of the"]
#[doc = "\tchannel, used for anything but 20 MHz bandwidth. In S1G this is the"]
#[doc = "\toperating channel center frequency."]
#[doc = " @NL80211_ATTR_CENTER_FREQ2: Center frequency of the second part of the"]
#[doc = "\tchannel, used only for 80+80 MHz bandwidth"]
#[doc = " @NL80211_ATTR_WIPHY_CHANNEL_TYPE: included with NL80211_ATTR_WIPHY_FREQ"]
#[doc = "\tif HT20 or HT40 are to be used (i.e., HT disabled if not included):"]
#[doc = "\tNL80211_CHAN_NO_HT = HT not allowed (i.e., same as not including"]
#[doc = "\t\tthis attribute)"]
#[doc = "\tNL80211_CHAN_HT20 = HT20 only"]
#[doc = "\tNL80211_CHAN_HT40MINUS = secondary channel is below the primary channel"]
#[doc = "\tNL80211_CHAN_HT40PLUS = secondary channel is above the primary channel"]
#[doc = "\tThis attribute is now deprecated."]
#[doc = " @NL80211_ATTR_WIPHY_RETRY_SHORT: TX retry limit for frames whose length is"]
#[doc = "\tless than or equal to the RTS threshold; allowed range: 1..255;"]
#[doc = "\tdot11ShortRetryLimit; u8"]
#[doc = " @NL80211_ATTR_WIPHY_RETRY_LONG: TX retry limit for frames whose length is"]
#[doc = "\tgreater than the RTS threshold; allowed range: 1..255;"]
#[doc = "\tdot11ShortLongLimit; u8"]
#[doc = " @NL80211_ATTR_WIPHY_FRAG_THRESHOLD: fragmentation threshold, i.e., maximum"]
#[doc = "\tlength in octets for frames; allowed range: 256..8000, disable"]
#[doc = "\tfragmentation with (u32)-1; dot11FragmentationThreshold; u32"]
#[doc = " @NL80211_ATTR_WIPHY_RTS_THRESHOLD: RTS threshold (TX frames with length"]
#[doc = "\tlarger than or equal to this use RTS/CTS handshake); allowed range:"]
#[doc = "\t0..65536, disable with (u32)-1; dot11RTSThreshold; u32"]
#[doc = " @NL80211_ATTR_WIPHY_COVERAGE_CLASS: Coverage Class as defined by IEEE 802.11"]
#[doc = "\tsection 7.3.2.9; dot11CoverageClass; u8"]
#[doc = ""]
#[doc = " @NL80211_ATTR_IFINDEX: network interface index of the device to operate on"]
#[doc = " @NL80211_ATTR_IFNAME: network interface name"]
#[doc = " @NL80211_ATTR_IFTYPE: type of virtual interface, see &enum nl80211_iftype"]
#[doc = ""]
#[doc = " @NL80211_ATTR_WDEV: wireless device identifier, used for pseudo-devices"]
#[doc = "\tthat don't have a netdev (u64)"]
#[doc = ""]
#[doc = " @NL80211_ATTR_MAC: MAC address (various uses)"]
#[doc = ""]
#[doc = " @NL80211_ATTR_KEY_DATA: (temporal) key data; for TKIP this consists of"]
#[doc = "\t16 bytes encryption key followed by 8 bytes each for TX and RX MIC"]
#[doc = "\tkeys"]
#[doc = " @NL80211_ATTR_KEY_IDX: key ID (u8, 0-3)"]
#[doc = " @NL80211_ATTR_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11"]
#[doc = "\tsection 7.3.2.25.1, e.g. 0x000FAC04)"]
#[doc = " @NL80211_ATTR_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and"]
#[doc = "\tCCMP keys, each six bytes in little endian"]
#[doc = " @NL80211_ATTR_KEY_DEFAULT: Flag attribute indicating the key is default key"]
#[doc = " @NL80211_ATTR_KEY_DEFAULT_MGMT: Flag attribute indicating the key is the"]
#[doc = "\tdefault management key"]
#[doc = " @NL80211_ATTR_CIPHER_SUITES_PAIRWISE: For crypto settings for connect or"]
#[doc = "\tother commands, indicates which pairwise cipher suites are used"]
#[doc = " @NL80211_ATTR_CIPHER_SUITE_GROUP: For crypto settings for connect or"]
#[doc = "\tother commands, indicates which group cipher suite is used"]
#[doc = ""]
#[doc = " @NL80211_ATTR_BEACON_INTERVAL: beacon interval in TU"]
#[doc = " @NL80211_ATTR_DTIM_PERIOD: DTIM period for beaconing"]
#[doc = " @NL80211_ATTR_BEACON_HEAD: portion of the beacon before the TIM IE"]
#[doc = " @NL80211_ATTR_BEACON_TAIL: portion of the beacon after the TIM IE"]
#[doc = ""]
#[doc = " @NL80211_ATTR_STA_AID: Association ID for the station (u16)"]
#[doc = " @NL80211_ATTR_STA_FLAGS: flags, nested element with NLA_FLAG attributes of"]
#[doc = "\t&enum nl80211_sta_flags (deprecated, use %NL80211_ATTR_STA_FLAGS2)"]
#[doc = " @NL80211_ATTR_STA_LISTEN_INTERVAL: listen interval as defined by"]
#[doc = "\tIEEE 802.11 7.3.1.6 (u16)."]
#[doc = " @NL80211_ATTR_STA_SUPPORTED_RATES: supported rates, array of supported"]
#[doc = "\trates as defined by IEEE 802.11 7.3.2.2 but without the length"]
#[doc = "\trestriction (at most %NL80211_MAX_SUPP_RATES)."]
#[doc = " @NL80211_ATTR_STA_VLAN: interface index of VLAN interface to move station"]
#[doc = "\tto, or the AP interface the station was originally added to."]
#[doc = " @NL80211_ATTR_STA_INFO: information about a station, part of station info"]
#[doc = "\tgiven for %NL80211_CMD_GET_STATION, nested attribute containing"]
#[doc = "\tinfo as possible, see &enum nl80211_sta_info."]
#[doc = ""]
#[doc = " @NL80211_ATTR_WIPHY_BANDS: Information about an operating bands,"]
#[doc = "\tconsisting of a nested array."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MESH_ID: mesh id (1-32 bytes)."]
#[doc = " @NL80211_ATTR_STA_PLINK_ACTION: action to perform on the mesh peer link"]
#[doc = "\t(see &enum nl80211_plink_action)."]
#[doc = " @NL80211_ATTR_MPATH_NEXT_HOP: MAC address of the next hop for a mesh path."]
#[doc = " @NL80211_ATTR_MPATH_INFO: information about a mesh_path, part of mesh path"]
#[doc = " \tinfo given for %NL80211_CMD_GET_MPATH, nested attribute described at"]
#[doc = "\t&enum nl80211_mpath_info."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MNTR_FLAGS: flags, nested element with NLA_FLAG attributes of"]
#[doc = "      &enum nl80211_mntr_flags."]
#[doc = ""]
#[doc = " @NL80211_ATTR_REG_ALPHA2: an ISO-3166-alpha2 country code for which the"]
#[doc = " \tcurrent regulatory domain should be set to or is already set to."]
#[doc = " \tFor example, 'CR', for Costa Rica. This attribute is used by the kernel"]
#[doc = " \tto query the CRDA to retrieve one regulatory domain. This attribute can"]
#[doc = " \talso be used by userspace to query the kernel for the currently set"]
#[doc = " \tregulatory domain. We chose an alpha2 as that is also used by the"]
#[doc = " \tIEEE-802.11 country information element to identify a country."]
#[doc = " \tUsers can also simply ask the wireless core to set regulatory domain"]
#[doc = " \tto a specific alpha2."]
#[doc = " @NL80211_ATTR_REG_RULES: a nested array of regulatory domain regulatory"]
#[doc = "\trules."]
#[doc = ""]
#[doc = " @NL80211_ATTR_BSS_CTS_PROT: whether CTS protection is enabled (u8, 0 or 1)"]
#[doc = " @NL80211_ATTR_BSS_SHORT_PREAMBLE: whether short preamble is enabled"]
#[doc = "\t(u8, 0 or 1)"]
#[doc = " @NL80211_ATTR_BSS_SHORT_SLOT_TIME: whether short slot time enabled"]
#[doc = "\t(u8, 0 or 1)"]
#[doc = " @NL80211_ATTR_BSS_BASIC_RATES: basic rates, array of basic"]
#[doc = "\trates in format defined by IEEE 802.11 7.3.2.2 but without the length"]
#[doc = "\trestriction (at most %NL80211_MAX_SUPP_RATES)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_HT_CAPABILITY: HT Capability information element (from"]
#[doc = "\tassociation request when used with NL80211_CMD_NEW_STATION)"]
#[doc = ""]
#[doc = " @NL80211_ATTR_SUPPORTED_IFTYPES: nested attribute containing all"]
#[doc = "\tsupported interface types, each a flag attribute with the number"]
#[doc = "\tof the interface mode."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MGMT_SUBTYPE: Management frame subtype for"]
#[doc = "\t%NL80211_CMD_SET_MGMT_EXTRA_IE."]
#[doc = ""]
#[doc = " @NL80211_ATTR_IE: Information element(s) data (used, e.g., with"]
#[doc = "\t%NL80211_CMD_SET_MGMT_EXTRA_IE)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MAX_NUM_SCAN_SSIDS: number of SSIDs you can scan with"]
#[doc = "\ta single scan request, a wiphy attribute."]
#[doc = " @NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS: number of SSIDs you can"]
#[doc = "\tscan with a single scheduled scan request, a wiphy attribute."]
#[doc = " @NL80211_ATTR_MAX_SCAN_IE_LEN: maximum length of information elements"]
#[doc = "\tthat can be added to a scan request"]
#[doc = " @NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN: maximum length of information"]
#[doc = "\telements that can be added to a scheduled scan request"]
#[doc = " @NL80211_ATTR_MAX_MATCH_SETS: maximum number of sets that can be"]
#[doc = "\tused with @NL80211_ATTR_SCHED_SCAN_MATCH, a wiphy attribute."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SCAN_FREQUENCIES: nested attribute with frequencies (in MHz)"]
#[doc = " @NL80211_ATTR_SCAN_SSIDS: nested attribute with SSIDs, leave out for passive"]
#[doc = "\tscanning and include a zero-length SSID (wildcard) for wildcard scan"]
#[doc = " @NL80211_ATTR_BSS: scan result BSS"]
#[doc = ""]
#[doc = " @NL80211_ATTR_REG_INITIATOR: indicates who requested the regulatory domain"]
#[doc = " \tcurrently in effect. This could be any of the %NL80211_REGDOM_SET_BY_*"]
#[doc = " @NL80211_ATTR_REG_TYPE: indicates the type of the regulatory domain currently"]
#[doc = " \tset. This can be one of the nl80211_reg_type (%NL80211_REGDOM_TYPE_*)"]
#[doc = ""]
#[doc = " @NL80211_ATTR_SUPPORTED_COMMANDS: wiphy attribute that specifies"]
#[doc = "\tan array of command numbers (i.e. a mapping index to command number)"]
#[doc = "\tthat the driver for the given wiphy supports."]
#[doc = ""]
#[doc = " @NL80211_ATTR_FRAME: frame data (binary attribute), including frame header"]
#[doc = "\tand body, but not FCS; used, e.g., with NL80211_CMD_AUTHENTICATE and"]
#[doc = "\tNL80211_CMD_ASSOCIATE events"]
#[doc = " @NL80211_ATTR_SSID: SSID (binary attribute, 0..32 octets)"]
#[doc = " @NL80211_ATTR_AUTH_TYPE: AuthenticationType, see &enum nl80211_auth_type,"]
#[doc = "\trepresented as a u32"]
#[doc = " @NL80211_ATTR_REASON_CODE: ReasonCode for %NL80211_CMD_DEAUTHENTICATE and"]
#[doc = "\t%NL80211_CMD_DISASSOCIATE, u16"]
#[doc = ""]
#[doc = " @NL80211_ATTR_KEY_TYPE: Key Type, see &enum nl80211_key_type, represented as"]
#[doc = "\ta u32"]
#[doc = ""]
#[doc = " @NL80211_ATTR_FREQ_BEFORE: A channel which has suffered a regulatory change"]
#[doc = " \tdue to considerations from a beacon hint. This attribute reflects"]
#[doc = " \tthe state of the channel _before_ the beacon hint processing. This"]
#[doc = " \tattributes consists of a nested attribute containing"]
#[doc = " \tNL80211_FREQUENCY_ATTR_*"]
#[doc = " @NL80211_ATTR_FREQ_AFTER: A channel which has suffered a regulatory change"]
#[doc = " \tdue to considerations from a beacon hint. This attribute reflects"]
#[doc = " \tthe state of the channel _after_ the beacon hint processing. This"]
#[doc = " \tattributes consists of a nested attribute containing"]
#[doc = " \tNL80211_FREQUENCY_ATTR_*"]
#[doc = ""]
#[doc = " @NL80211_ATTR_CIPHER_SUITES: a set of u32 values indicating the supported"]
#[doc = "\tcipher suites"]
#[doc = ""]
#[doc = " @NL80211_ATTR_FREQ_FIXED: a flag indicating the IBSS should not try to look"]
#[doc = "\tfor other networks on different channels"]
#[doc = ""]
#[doc = " @NL80211_ATTR_TIMED_OUT: a flag indicating than an operation timed out; this"]
#[doc = "\tis used, e.g., with %NL80211_CMD_AUTHENTICATE event"]
#[doc = ""]
#[doc = " @NL80211_ATTR_USE_MFP: Whether management frame protection (IEEE 802.11w) is"]
#[doc = "\tused for the association (&enum nl80211_mfp, represented as a u32);"]
#[doc = "\tthis attribute can be used with %NL80211_CMD_ASSOCIATE and"]
#[doc = "\t%NL80211_CMD_CONNECT requests. %NL80211_MFP_OPTIONAL is not allowed for"]
#[doc = "\t%NL80211_CMD_ASSOCIATE since user space SME is expected and hence, it"]
#[doc = "\tmust have decided whether to use management frame protection or not."]
#[doc = "\tSetting %NL80211_MFP_OPTIONAL with a %NL80211_CMD_CONNECT request will"]
#[doc = "\tlet the driver (or the firmware) decide whether to use MFP or not."]
#[doc = ""]
#[doc = " @NL80211_ATTR_STA_FLAGS2: Attribute containing a"]
#[doc = "\t&struct nl80211_sta_flag_update."]
#[doc = ""]
#[doc = " @NL80211_ATTR_CONTROL_PORT: A flag indicating whether user space controls"]
#[doc = "\tIEEE 802.1X port, i.e., sets/clears %NL80211_STA_FLAG_AUTHORIZED, in"]
#[doc = "\tstation mode. If the flag is included in %NL80211_CMD_ASSOCIATE"]
#[doc = "\trequest, the driver will assume that the port is unauthorized until"]
#[doc = "\tauthorized by user space. Otherwise, port is marked authorized by"]
#[doc = "\tdefault in station mode."]
#[doc = " @NL80211_ATTR_CONTROL_PORT_ETHERTYPE: A 16-bit value indicating the"]
#[doc = "\tethertype that will be used for key negotiation. It can be"]
#[doc = "\tspecified with the associate and connect commands. If it is not"]
#[doc = "\tspecified, the value defaults to 0x888E (PAE, 802.1X). This"]
#[doc = "\tattribute is also used as a flag in the wiphy information to"]
#[doc = "\tindicate that protocols other than PAE are supported."]
#[doc = " @NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT: When included along with"]
#[doc = "\t%NL80211_ATTR_CONTROL_PORT_ETHERTYPE, indicates that the custom"]
#[doc = "\tethertype frames used for key negotiation must not be encrypted."]
#[doc = " @NL80211_ATTR_CONTROL_PORT_OVER_NL80211: A flag indicating whether control"]
#[doc = "\tport frames (e.g. of type given in %NL80211_ATTR_CONTROL_PORT_ETHERTYPE)"]
#[doc = "\twill be sent directly to the network interface or sent via the NL80211"]
#[doc = "\tsocket.  If this attribute is missing, then legacy behavior of sending"]
#[doc = "\tcontrol port frames directly to the network interface is used.  If the"]
#[doc = "\tflag is included, then control port frames are sent over NL80211 instead"]
#[doc = "\tusing %CMD_CONTROL_PORT_FRAME.  If control port routing over NL80211 is"]
#[doc = "\tto be used then userspace must also use the %NL80211_ATTR_SOCKET_OWNER"]
#[doc = "\tflag. When used with %NL80211_ATTR_CONTROL_PORT_NO_PREAUTH, pre-auth"]
#[doc = "\tframes are not forwared over the control port."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TESTDATA: Testmode data blob, passed through to the driver."]
#[doc = "\tWe recommend using nested, driver-specific attributes within this."]
#[doc = ""]
#[doc = " @NL80211_ATTR_DISCONNECTED_BY_AP: A flag indicating that the DISCONNECT"]
#[doc = "\tevent was due to the AP disconnecting the station, and not due to"]
#[doc = "\ta local disconnect request."]
#[doc = " @NL80211_ATTR_STATUS_CODE: StatusCode for the %NL80211_CMD_CONNECT"]
#[doc = "\tevent (u16)"]
#[doc = " @NL80211_ATTR_PRIVACY: Flag attribute, used with connect(), indicating"]
#[doc = "\tthat protected APs should be used. This is also used with NEW_BEACON to"]
#[doc = "\tindicate that the BSS is to use protection."]
#[doc = ""]
#[doc = " @NL80211_ATTR_CIPHERS_PAIRWISE: Used with CONNECT, ASSOCIATE, and NEW_BEACON"]
#[doc = "\tto indicate which unicast key ciphers will be used with the connection"]
#[doc = "\t(an array of u32)."]
#[doc = " @NL80211_ATTR_CIPHER_GROUP: Used with CONNECT, ASSOCIATE, and NEW_BEACON to"]
#[doc = "\tindicate which group key cipher will be used with the connection (a"]
#[doc = "\tu32)."]
#[doc = " @NL80211_ATTR_WPA_VERSIONS: Used with CONNECT, ASSOCIATE, and NEW_BEACON to"]
#[doc = "\tindicate which WPA version(s) the AP we want to associate with is using"]
#[doc = "\t(a u32 with flags from &enum nl80211_wpa_versions)."]
#[doc = " @NL80211_ATTR_AKM_SUITES: Used with CONNECT, ASSOCIATE, and NEW_BEACON to"]
#[doc = "\tindicate which key management algorithm(s) to use (an array of u32)."]
#[doc = "\tThis attribute is also sent in response to @NL80211_CMD_GET_WIPHY,"]
#[doc = "\tindicating the supported AKM suites, intended for specific drivers which"]
#[doc = "\timplement SME and have constraints on which AKMs are supported and also"]
#[doc = "\tthe cases where an AKM support is offloaded to the driver/firmware."]
#[doc = "\tIf there is no such notification from the driver, user space should"]
#[doc = "\tassume the driver supports all the AKM suites."]
#[doc = ""]
#[doc = " @NL80211_ATTR_REQ_IE: (Re)association request information elements as"]
#[doc = "\tsent out by the card, for ROAM and successful CONNECT events."]
#[doc = " @NL80211_ATTR_RESP_IE: (Re)association response information elements as"]
#[doc = "\tsent by peer, for ROAM and successful CONNECT events."]
#[doc = ""]
#[doc = " @NL80211_ATTR_PREV_BSSID: previous BSSID, to be used in ASSOCIATE and CONNECT"]
#[doc = "\tcommands to specify a request to reassociate within an ESS, i.e., to use"]
#[doc = "\tReassociate Request frame (with the value of this attribute in the"]
#[doc = "\tCurrent AP address field) instead of Association Request frame which is"]
#[doc = "\tused for the initial association to an ESS."]
#[doc = ""]
#[doc = " @NL80211_ATTR_KEY: key information in a nested attribute with"]
#[doc = "\t%NL80211_KEY_* sub-attributes"]
#[doc = " @NL80211_ATTR_KEYS: array of keys for static WEP keys for connect()"]
#[doc = "\tand join_ibss(), key information is in a nested attribute each"]
#[doc = "\twith %NL80211_KEY_* sub-attributes"]
#[doc = ""]
#[doc = " @NL80211_ATTR_PID: Process ID of a network namespace."]
#[doc = ""]
#[doc = " @NL80211_ATTR_GENERATION: Used to indicate consistent snapshots for"]
#[doc = "\tdumps. This number increases whenever the object list being"]
#[doc = "\tdumped changes, and as such userspace can verify that it has"]
#[doc = "\tobtained a complete and consistent snapshot by verifying that"]
#[doc = "\tall dump messages contain the same generation number. If it"]
#[doc = "\tchanged then the list changed and the dump should be repeated"]
#[doc = "\tcompletely from scratch."]
#[doc = ""]
#[doc = " @NL80211_ATTR_4ADDR: Use 4-address frames on a virtual interface"]
#[doc = ""]
#[doc = " @NL80211_ATTR_SURVEY_INFO: survey information about a channel, part of"]
#[doc = "      the survey response for %NL80211_CMD_GET_SURVEY, nested attribute"]
#[doc = "      containing info as possible, see &enum survey_info."]
#[doc = ""]
#[doc = " @NL80211_ATTR_PMKID: PMK material for PMKSA caching."]
#[doc = " @NL80211_ATTR_MAX_NUM_PMKIDS: maximum number of PMKIDs a firmware can"]
#[doc = "\tcache, a wiphy attribute."]
#[doc = ""]
#[doc = " @NL80211_ATTR_DURATION: Duration of an operation in milliseconds, u32."]
#[doc = " @NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION: Device attribute that"]
#[doc = "\tspecifies the maximum duration that can be requested with the"]
#[doc = "\tremain-on-channel operation, in milliseconds, u32."]
#[doc = ""]
#[doc = " @NL80211_ATTR_COOKIE: Generic 64-bit cookie to identify objects."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TX_RATES: Nested set of attributes"]
#[doc = "\t(enum nl80211_tx_rate_attributes) describing TX rates per band. The"]
#[doc = "\tenum nl80211_band value is used as the index (nla_type() of the nested"]
#[doc = "\tdata. If a band is not included, it will be configured to allow all"]
#[doc = "\trates based on negotiated supported rates information. This attribute"]
#[doc = "\tis used with %NL80211_CMD_SET_TX_BITRATE_MASK and with starting AP,"]
#[doc = "\tand joining mesh networks (not IBSS yet). In the later case, it must"]
#[doc = "\tspecify just a single bitrate, which is to be used for the beacon."]
#[doc = "\tThe driver must also specify support for this with the extended"]
#[doc = "\tfeatures NL80211_EXT_FEATURE_BEACON_RATE_LEGACY,"]
#[doc = "\tNL80211_EXT_FEATURE_BEACON_RATE_HT,"]
#[doc = "\tNL80211_EXT_FEATURE_BEACON_RATE_VHT and"]
#[doc = "\tNL80211_EXT_FEATURE_BEACON_RATE_HE."]
#[doc = ""]
#[doc = " @NL80211_ATTR_FRAME_MATCH: A binary attribute which typically must contain"]
#[doc = "\tat least one byte, currently used with @NL80211_CMD_REGISTER_FRAME."]
#[doc = " @NL80211_ATTR_FRAME_TYPE: A u16 indicating the frame type/subtype for the"]
#[doc = "\t@NL80211_CMD_REGISTER_FRAME command."]
#[doc = " @NL80211_ATTR_TX_FRAME_TYPES: wiphy capability attribute, which is a"]
#[doc = "\tnested attribute of %NL80211_ATTR_FRAME_TYPE attributes, containing"]
#[doc = "\tinformation about which frame types can be transmitted with"]
#[doc = "\t%NL80211_CMD_FRAME."]
#[doc = " @NL80211_ATTR_RX_FRAME_TYPES: wiphy capability attribute, which is a"]
#[doc = "\tnested attribute of %NL80211_ATTR_FRAME_TYPE attributes, containing"]
#[doc = "\tinformation about which frame types can be registered for RX."]
#[doc = ""]
#[doc = " @NL80211_ATTR_ACK: Flag attribute indicating that the frame was"]
#[doc = "\tacknowledged by the recipient."]
#[doc = ""]
#[doc = " @NL80211_ATTR_PS_STATE: powersave state, using &enum nl80211_ps_state values."]
#[doc = ""]
#[doc = " @NL80211_ATTR_CQM: connection quality monitor configuration in a"]
#[doc = "\tnested attribute with %NL80211_ATTR_CQM_* sub-attributes."]
#[doc = ""]
#[doc = " @NL80211_ATTR_LOCAL_STATE_CHANGE: Flag attribute to indicate that a command"]
#[doc = "\tis requesting a local authentication/association state change without"]
#[doc = "\tinvoking actual management frame exchange. This can be used with"]
#[doc = "\tNL80211_CMD_AUTHENTICATE, NL80211_CMD_DEAUTHENTICATE,"]
#[doc = "\tNL80211_CMD_DISASSOCIATE."]
#[doc = ""]
#[doc = " @NL80211_ATTR_AP_ISOLATE: (AP mode) Do not forward traffic between stations"]
#[doc = "\tconnected to this BSS."]
#[doc = ""]
#[doc = " @NL80211_ATTR_WIPHY_TX_POWER_SETTING: Transmit power setting type. See"]
#[doc = "      &enum nl80211_tx_power_setting for possible values."]
#[doc = " @NL80211_ATTR_WIPHY_TX_POWER_LEVEL: Transmit power level in signed mBm units."]
#[doc = "      This is used in association with @NL80211_ATTR_WIPHY_TX_POWER_SETTING"]
#[doc = "      for non-automatic settings."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SUPPORT_IBSS_RSN: The device supports IBSS RSN, which mostly"]
#[doc = "\tmeans support for per-station GTKs."]
#[doc = ""]
#[doc = " @NL80211_ATTR_WIPHY_ANTENNA_TX: Bitmap of allowed antennas for transmitting."]
#[doc = "\tThis can be used to mask out antennas which are not attached or should"]
#[doc = "\tnot be used for transmitting. If an antenna is not selected in this"]
#[doc = "\tbitmap the hardware is not allowed to transmit on this antenna."]
#[doc = ""]
#[doc = "\tEach bit represents one antenna, starting with antenna 1 at the first"]
#[doc = "\tbit. Depending on which antennas are selected in the bitmap, 802.11n"]
#[doc = "\tdrivers can derive which chainmasks to use (if all antennas belonging to"]
#[doc = "\ta particular chain are disabled this chain should be disabled) and if"]
#[doc = "\ta chain has diversity antennas wether diversity should be used or not."]
#[doc = "\tHT capabilities (STBC, TX Beamforming, Antenna selection) can be"]
#[doc = "\tderived from the available chains after applying the antenna mask."]
#[doc = "\tNon-802.11n drivers can derive wether to use diversity or not."]
#[doc = "\tDrivers may reject configurations or RX/TX mask combinations they cannot"]
#[doc = "\tsupport by returning -EINVAL."]
#[doc = ""]
#[doc = " @NL80211_ATTR_WIPHY_ANTENNA_RX: Bitmap of allowed antennas for receiving."]
#[doc = "\tThis can be used to mask out antennas which are not attached or should"]
#[doc = "\tnot be used for receiving. If an antenna is not selected in this bitmap"]
#[doc = "\tthe hardware should not be configured to receive on this antenna."]
#[doc = "\tFor a more detailed description see @NL80211_ATTR_WIPHY_ANTENNA_TX."]
#[doc = ""]
#[doc = " @NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX: Bitmap of antennas which are available"]
#[doc = "\tfor configuration as TX antennas via the above parameters."]
#[doc = ""]
#[doc = " @NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX: Bitmap of antennas which are available"]
#[doc = "\tfor configuration as RX antennas via the above parameters."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MCAST_RATE: Multicast tx rate (in 100 kbps) for IBSS"]
#[doc = ""]
#[doc = " @NL80211_ATTR_OFFCHANNEL_TX_OK: For management frame TX, the frame may be"]
#[doc = "\ttransmitted on another channel when the channel given doesn't match"]
#[doc = "\tthe current channel. If the current channel doesn't match and this"]
#[doc = "\tflag isn't set, the frame will be rejected. This is also used as an"]
#[doc = "\tnl80211 capability flag."]
#[doc = ""]
#[doc = " @NL80211_ATTR_BSS_HT_OPMODE: HT operation mode (u16)"]
#[doc = ""]
#[doc = " @NL80211_ATTR_KEY_DEFAULT_TYPES: A nested attribute containing flags"]
#[doc = "\tattributes, specifying what a key should be set as default as."]
#[doc = "\tSee &enum nl80211_key_default_types."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MESH_SETUP: Optional mesh setup parameters.  These cannot be"]
#[doc = "\tchanged once the mesh is active."]
#[doc = " @NL80211_ATTR_MESH_CONFIG: Mesh configuration parameters, a nested attribute"]
#[doc = "\tcontaining attributes from &enum nl80211_meshconf_params."]
#[doc = " @NL80211_ATTR_SUPPORT_MESH_AUTH: Currently, this means the underlying driver"]
#[doc = "\tallows auth frames in a mesh to be passed to userspace for processing via"]
#[doc = "\tthe @NL80211_MESH_SETUP_USERSPACE_AUTH flag."]
#[doc = " @NL80211_ATTR_STA_PLINK_STATE: The state of a mesh peer link as defined in"]
#[doc = "\t&enum nl80211_plink_state. Used when userspace is driving the peer link"]
#[doc = "\tmanagement state machine.  @NL80211_MESH_SETUP_USERSPACE_AMPE or"]
#[doc = "\t@NL80211_MESH_SETUP_USERSPACE_MPM must be enabled."]
#[doc = ""]
#[doc = " @NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED: indicates, as part of the wiphy"]
#[doc = "\tcapabilities, the supported WoWLAN triggers"]
#[doc = " @NL80211_ATTR_WOWLAN_TRIGGERS: used by %NL80211_CMD_SET_WOWLAN to"]
#[doc = "\tindicate which WoW triggers should be enabled. This is also"]
#[doc = "\tused by %NL80211_CMD_GET_WOWLAN to get the currently enabled WoWLAN"]
#[doc = "\ttriggers."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SCHED_SCAN_INTERVAL: Interval between scheduled scan"]
#[doc = "\tcycles, in msecs."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SCHED_SCAN_MATCH: Nested attribute with one or more"]
#[doc = "\tsets of attributes to match during scheduled scans.  Only BSSs"]
#[doc = "\tthat match any of the sets will be reported.  These are"]
#[doc = "\tpass-thru filter rules."]
#[doc = "\tFor a match to succeed, the BSS must match all attributes of a"]
#[doc = "\tset.  Since not every hardware supports matching all types of"]
#[doc = "\tattributes, there is no guarantee that the reported BSSs are"]
#[doc = "\tfully complying with the match sets and userspace needs to be"]
#[doc = "\table to ignore them by itself."]
#[doc = "\tThus, the implementation is somewhat hardware-dependent, but"]
#[doc = "\tthis is only an optimization and the userspace application"]
#[doc = "\tneeds to handle all the non-filtered results anyway."]
#[doc = "\tIf the match attributes don't make sense when combined with"]
#[doc = "\tthe values passed in @NL80211_ATTR_SCAN_SSIDS (eg. if an SSID"]
#[doc = "\tis included in the probe request, but the match attributes"]
#[doc = "\twill never let it go through), -EINVAL may be returned."]
#[doc = "\tIf omitted, no filtering is done."]
#[doc = ""]
#[doc = " @NL80211_ATTR_INTERFACE_COMBINATIONS: Nested attribute listing the supported"]
#[doc = "\tinterface combinations. In each nested item, it contains attributes"]
#[doc = "\tdefined in &enum nl80211_if_combination_attrs."]
#[doc = " @NL80211_ATTR_SOFTWARE_IFTYPES: Nested attribute (just like"]
#[doc = "\t%NL80211_ATTR_SUPPORTED_IFTYPES) containing the interface types that"]
#[doc = "\tare managed in software: interfaces of these types aren't subject to"]
#[doc = "\tany restrictions in their number or combinations."]
#[doc = ""]
#[doc = " @NL80211_ATTR_REKEY_DATA: nested attribute containing the information"]
#[doc = "\tnecessary for GTK rekeying in the device, see &enum nl80211_rekey_data."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SCAN_SUPP_RATES: rates per to be advertised as supported in scan,"]
#[doc = "\tnested array attribute containing an entry for each band, with the entry"]
#[doc = "\tbeing a list of supported rates as defined by IEEE 802.11 7.3.2.2 but"]
#[doc = "\twithout the length restriction (at most %NL80211_MAX_SUPP_RATES)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_HIDDEN_SSID: indicates whether SSID is to be hidden from Beacon"]
#[doc = "\tand Probe Response (when response to wildcard Probe Request); see"]
#[doc = "\t&enum nl80211_hidden_ssid, represented as a u32"]
#[doc = ""]
#[doc = " @NL80211_ATTR_IE_PROBE_RESP: Information element(s) for Probe Response frame."]
#[doc = "\tThis is used with %NL80211_CMD_NEW_BEACON and %NL80211_CMD_SET_BEACON to"]
#[doc = "\tprovide extra IEs (e.g., WPS/P2P IE) into Probe Response frames when the"]
#[doc = "\tdriver (or firmware) replies to Probe Request frames."]
#[doc = " @NL80211_ATTR_IE_ASSOC_RESP: Information element(s) for (Re)Association"]
#[doc = "\tResponse frames. This is used with %NL80211_CMD_NEW_BEACON and"]
#[doc = "\t%NL80211_CMD_SET_BEACON to provide extra IEs (e.g., WPS/P2P IE) into"]
#[doc = "\t(Re)Association Response frames when the driver (or firmware) replies to"]
#[doc = "\t(Re)Association Request frames."]
#[doc = ""]
#[doc = " @NL80211_ATTR_STA_WME: Nested attribute containing the wme configuration"]
#[doc = "\tof the station, see &enum nl80211_sta_wme_attr."]
#[doc = " @NL80211_ATTR_SUPPORT_AP_UAPSD: the device supports uapsd when working"]
#[doc = "\tas AP."]
#[doc = ""]
#[doc = " @NL80211_ATTR_ROAM_SUPPORT: Indicates whether the firmware is capable of"]
#[doc = "\troaming to another AP in the same ESS if the signal lever is low."]
#[doc = ""]
#[doc = " @NL80211_ATTR_PMKSA_CANDIDATE: Nested attribute containing the PMKSA caching"]
#[doc = "\tcandidate information, see &enum nl80211_pmksa_candidate_attr."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TX_NO_CCK_RATE: Indicates whether to use CCK rate or not"]
#[doc = "\tfor management frames transmission. In order to avoid p2p probe/action"]
#[doc = "\tframes are being transmitted at CCK rate in 2GHz band, the user space"]
#[doc = "\tapplications use this attribute."]
#[doc = "\tThis attribute is used with %NL80211_CMD_TRIGGER_SCAN and"]
#[doc = "\t%NL80211_CMD_FRAME commands."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TDLS_ACTION: Low level TDLS action code (e.g. link setup"]
#[doc = "\trequest, link setup confirm, link teardown, etc.). Values are"]
#[doc = "\tdescribed in the TDLS (802.11z) specification."]
#[doc = " @NL80211_ATTR_TDLS_DIALOG_TOKEN: Non-zero token for uniquely identifying a"]
#[doc = "\tTDLS conversation between two devices."]
#[doc = " @NL80211_ATTR_TDLS_OPERATION: High level TDLS operation; see"]
#[doc = "\t&enum nl80211_tdls_operation, represented as a u8."]
#[doc = " @NL80211_ATTR_TDLS_SUPPORT: A flag indicating the device can operate"]
#[doc = "\tas a TDLS peer sta."]
#[doc = " @NL80211_ATTR_TDLS_EXTERNAL_SETUP: The TDLS discovery/setup and teardown"]
#[doc = "\tprocedures should be performed by sending TDLS packets via"]
#[doc = "\t%NL80211_CMD_TDLS_MGMT. Otherwise %NL80211_CMD_TDLS_OPER should be"]
#[doc = "\tused for asking the driver to perform a TDLS operation."]
#[doc = ""]
#[doc = " @NL80211_ATTR_DEVICE_AP_SME: This u32 attribute may be listed for devices"]
#[doc = "\tthat have AP support to indicate that they have the AP SME integrated"]
#[doc = "\twith support for the features listed in this attribute, see"]
#[doc = "\t&enum nl80211_ap_sme_features."]
#[doc = ""]
#[doc = " @NL80211_ATTR_DONT_WAIT_FOR_ACK: Used with %NL80211_CMD_FRAME, this tells"]
#[doc = "\tthe driver to not wait for an acknowledgement. Note that due to this,"]
#[doc = "\tit will also not give a status callback nor return a cookie. This is"]
#[doc = "\tmostly useful for probe responses to save airtime."]
#[doc = ""]
#[doc = " @NL80211_ATTR_FEATURE_FLAGS: This u32 attribute contains flags from"]
#[doc = "\t&enum nl80211_feature_flags and is advertised in wiphy information."]
#[doc = " @NL80211_ATTR_PROBE_RESP_OFFLOAD: Indicates that the HW responds to probe"]
#[doc = "\trequests while operating in AP-mode."]
#[doc = "\tThis attribute holds a bitmap of the supported protocols for"]
#[doc = "\toffloading (see &enum nl80211_probe_resp_offload_support_attr)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_PROBE_RESP: Probe Response template data. Contains the entire"]
#[doc = "\tprobe-response frame. The DA field in the 802.11 header is zero-ed out,"]
#[doc = "\tto be filled by the FW."]
#[doc = " @NL80211_ATTR_DISABLE_HT: Force HT capable interfaces to disable"]
#[doc = "      this feature during association. This is a flag attribute."]
#[doc = "\tCurrently only supported in mac80211 drivers."]
#[doc = " @NL80211_ATTR_DISABLE_VHT: Force VHT capable interfaces to disable"]
#[doc = "      this feature during association. This is a flag attribute."]
#[doc = "\tCurrently only supported in mac80211 drivers."]
#[doc = " @NL80211_ATTR_DISABLE_HE: Force HE capable interfaces to disable"]
#[doc = "      this feature during association. This is a flag attribute."]
#[doc = "\tCurrently only supported in mac80211 drivers."]
#[doc = " @NL80211_ATTR_HT_CAPABILITY_MASK: Specify which bits of the"]
#[doc = "      ATTR_HT_CAPABILITY to which attention should be paid."]
#[doc = "      Currently, only mac80211 NICs support this feature."]
#[doc = "      The values that may be configured are:"]
#[doc = "       MCS rates, MAX-AMSDU, HT-20-40 and HT_CAP_SGI_40"]
#[doc = "       AMPDU density and AMPDU factor."]
#[doc = "      All values are treated as suggestions and may be ignored"]
#[doc = "      by the driver as required.  The actual values may be seen in"]
#[doc = "      the station debugfs ht_caps file."]
#[doc = ""]
#[doc = " @NL80211_ATTR_DFS_REGION: region for regulatory rules which this country"]
#[doc = "    abides to when initiating radiation on DFS channels. A country maps"]
#[doc = "    to one DFS region."]
#[doc = ""]
#[doc = " @NL80211_ATTR_NOACK_MAP: This u16 bitmap contains the No Ack Policy of"]
#[doc = "      up to 16 TIDs."]
#[doc = ""]
#[doc = " @NL80211_ATTR_INACTIVITY_TIMEOUT: timeout value in seconds, this can be"]
#[doc = "\tused by the drivers which has MLME in firmware and does not have support"]
#[doc = "\tto report per station tx/rx activity to free up the station entry from"]
#[doc = "\tthe list. This needs to be used when the driver advertises the"]
#[doc = "\tcapability to timeout the stations."]
#[doc = ""]
#[doc = " @NL80211_ATTR_RX_SIGNAL_DBM: signal strength in dBm (as a 32-bit int);"]
#[doc = "\tthis attribute is (depending on the driver capabilities) added to"]
#[doc = "\treceived frames indicated with %NL80211_CMD_FRAME."]
#[doc = ""]
#[doc = " @NL80211_ATTR_BG_SCAN_PERIOD: Background scan period in seconds"]
#[doc = "      or 0 to disable background scan."]
#[doc = ""]
#[doc = " @NL80211_ATTR_USER_REG_HINT_TYPE: type of regulatory hint passed from"]
#[doc = "\tuserspace. If unset it is assumed the hint comes directly from"]
#[doc = "\ta user. If set code could specify exactly what type of source"]
#[doc = "\twas used to provide the hint. For the different types of"]
#[doc = "\tallowed user regulatory hints see nl80211_user_reg_hint_type."]
#[doc = ""]
#[doc = " @NL80211_ATTR_CONN_FAILED_REASON: The reason for which AP has rejected"]
#[doc = "\tthe connection request from a station. nl80211_connect_failed_reason"]
#[doc = "\tenum has different reasons of connection failure."]
#[doc = ""]
#[doc = " @NL80211_ATTR_AUTH_DATA: Fields and elements in Authentication frames."]
#[doc = "\tThis contains the authentication frame body (non-IE and IE data),"]
#[doc = "\texcluding the Authentication algorithm number, i.e., starting at the"]
#[doc = "\tAuthentication transaction sequence number field. It is used with"]
#[doc = "\tauthentication algorithms that need special fields to be added into"]
#[doc = "\tthe frames (SAE and FILS). Currently, only the SAE cases use the"]
#[doc = "\tinitial two fields (Authentication transaction sequence number and"]
#[doc = "\tStatus code). However, those fields are included in the attribute data"]
#[doc = "\tfor all authentication algorithms to keep the attribute definition"]
#[doc = "\tconsistent."]
#[doc = ""]
#[doc = " @NL80211_ATTR_VHT_CAPABILITY: VHT Capability information element (from"]
#[doc = "\tassociation request when used with NL80211_CMD_NEW_STATION)"]
#[doc = ""]
#[doc = " @NL80211_ATTR_SCAN_FLAGS: scan request control flags (u32)"]
#[doc = ""]
#[doc = " @NL80211_ATTR_P2P_CTWINDOW: P2P GO Client Traffic Window (u8), used with"]
#[doc = "\tthe START_AP and SET_BSS commands"]
#[doc = " @NL80211_ATTR_P2P_OPPPS: P2P GO opportunistic PS (u8), used with the"]
#[doc = "\tSTART_AP and SET_BSS commands. This can have the values 0 or 1;"]
#[doc = "\tif not given in START_AP 0 is assumed, if not given in SET_BSS"]
#[doc = "\tno change is made."]
#[doc = ""]
#[doc = " @NL80211_ATTR_LOCAL_MESH_POWER_MODE: local mesh STA link-specific power mode"]
#[doc = "\tdefined in &enum nl80211_mesh_power_mode."]
#[doc = ""]
#[doc = " @NL80211_ATTR_ACL_POLICY: ACL policy, see &enum nl80211_acl_policy,"]
#[doc = "\tcarried in a u32 attribute"]
#[doc = ""]
#[doc = " @NL80211_ATTR_MAC_ADDRS: Array of nested MAC addresses, used for"]
#[doc = "\tMAC ACL."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MAC_ACL_MAX: u32 attribute to advertise the maximum"]
#[doc = "\tnumber of MAC addresses that a device can support for MAC"]
#[doc = "\tACL."]
#[doc = ""]
#[doc = " @NL80211_ATTR_RADAR_EVENT: Type of radar event for notification to userspace,"]
#[doc = "\tcontains a value of enum nl80211_radar_event (u32)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_EXT_CAPA: 802.11 extended capabilities that the kernel driver"]
#[doc = "\thas and handles. The format is the same as the IE contents. See"]
#[doc = "\t802.11-2012 8.4.2.29 for more information."]
#[doc = " @NL80211_ATTR_EXT_CAPA_MASK: Extended capabilities that the kernel driver"]
#[doc = "\thas set in the %NL80211_ATTR_EXT_CAPA value, for multibit fields."]
#[doc = ""]
#[doc = " @NL80211_ATTR_STA_CAPABILITY: Station capabilities (u16) are advertised to"]
#[doc = "\tthe driver, e.g., to enable TDLS power save (PU-APSD)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_STA_EXT_CAPABILITY: Station extended capabilities are"]
#[doc = "\tadvertised to the driver, e.g., to enable TDLS off channel operations"]
#[doc = "\tand PU-APSD."]
#[doc = ""]
#[doc = " @NL80211_ATTR_PROTOCOL_FEATURES: global nl80211 feature flags, see"]
#[doc = "\t&enum nl80211_protocol_features, the attribute is a u32."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SPLIT_WIPHY_DUMP: flag attribute, userspace supports"]
#[doc = "\treceiving the data for a single wiphy split across multiple"]
#[doc = "\tmessages, given with wiphy dump message"]
#[doc = ""]
#[doc = " @NL80211_ATTR_MDID: Mobility Domain Identifier"]
#[doc = ""]
#[doc = " @NL80211_ATTR_IE_RIC: Resource Information Container Information"]
#[doc = "\tElement"]
#[doc = ""]
#[doc = " @NL80211_ATTR_CRIT_PROT_ID: critical protocol identifier requiring increased"]
#[doc = "\treliability, see &enum nl80211_crit_proto_id (u16)."]
#[doc = " @NL80211_ATTR_MAX_CRIT_PROT_DURATION: duration in milliseconds in which"]
#[doc = "      the connection should have increased reliability (u16)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_PEER_AID: Association ID for the peer TDLS station (u16)."]
#[doc = "\tThis is similar to @NL80211_ATTR_STA_AID but with a difference of being"]
#[doc = "\tallowed to be used with the first @NL80211_CMD_SET_STATION command to"]
#[doc = "\tupdate a TDLS peer STA entry."]
#[doc = ""]
#[doc = " @NL80211_ATTR_COALESCE_RULE: Coalesce rule information."]
#[doc = ""]
#[doc = " @NL80211_ATTR_CH_SWITCH_COUNT: u32 attribute specifying the number of TBTT's"]
#[doc = "\tuntil the channel switch event."]
#[doc = " @NL80211_ATTR_CH_SWITCH_BLOCK_TX: flag attribute specifying that transmission"]
#[doc = "\tmust be blocked on the current channel (before the channel switch"]
#[doc = "\toperation). Also included in the channel switch started event if quiet"]
#[doc = "\twas requested by the AP."]
#[doc = " @NL80211_ATTR_CSA_IES: Nested set of attributes containing the IE information"]
#[doc = "\tfor the time while performing a channel switch."]
#[doc = " @NL80211_ATTR_CNTDWN_OFFS_BEACON: An array of offsets (u16) to the channel"]
#[doc = "\tswitch or color change counters in the beacons tail (%NL80211_ATTR_BEACON_TAIL)."]
#[doc = " @NL80211_ATTR_CNTDWN_OFFS_PRESP: An array of offsets (u16) to the channel"]
#[doc = "\tswitch or color change counters in the probe response (%NL80211_ATTR_PROBE_RESP)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_RXMGMT_FLAGS: flags for nl80211_send_mgmt(), u32."]
#[doc = "\tAs specified in the &enum nl80211_rxmgmt_flags."]
#[doc = ""]
#[doc = " @NL80211_ATTR_STA_SUPPORTED_CHANNELS: array of supported channels."]
#[doc = ""]
#[doc = " @NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES: array of supported"]
#[doc = "      operating classes."]
#[doc = ""]
#[doc = " @NL80211_ATTR_HANDLE_DFS: A flag indicating whether user space"]
#[doc = "\tcontrols DFS operation in IBSS mode. If the flag is included in"]
#[doc = "\t%NL80211_CMD_JOIN_IBSS request, the driver will allow use of DFS"]
#[doc = "\tchannels and reports radar events to userspace. Userspace is required"]
#[doc = "\tto react to radar events, e.g. initiate a channel switch or leave the"]
#[doc = "\tIBSS network."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SUPPORT_5_MHZ: A flag indicating that the device supports"]
#[doc = "\t5 MHz channel bandwidth."]
#[doc = " @NL80211_ATTR_SUPPORT_10_MHZ: A flag indicating that the device supports"]
#[doc = "\t10 MHz channel bandwidth."]
#[doc = ""]
#[doc = " @NL80211_ATTR_OPMODE_NOTIF: Operating mode field from Operating Mode"]
#[doc = "\tNotification Element based on association request when used with"]
#[doc = "\t%NL80211_CMD_NEW_STATION or %NL80211_CMD_SET_STATION (only when"]
#[doc = "\t%NL80211_FEATURE_FULL_AP_CLIENT_STATE is supported, or with TDLS);"]
#[doc = "\tu8 attribute."]
#[doc = ""]
#[doc = " @NL80211_ATTR_VENDOR_ID: The vendor ID, either a 24-bit OUI or, if"]
#[doc = "\t%NL80211_VENDOR_ID_IS_LINUX is set, a special Linux ID (not used yet)"]
#[doc = " @NL80211_ATTR_VENDOR_SUBCMD: vendor sub-command"]
#[doc = " @NL80211_ATTR_VENDOR_DATA: data for the vendor command, if any; this"]
#[doc = "\tattribute is also used for vendor command feature advertisement"]
#[doc = " @NL80211_ATTR_VENDOR_EVENTS: used for event list advertising in the wiphy"]
#[doc = "\tinfo, containing a nested array of possible events"]
#[doc = ""]
#[doc = " @NL80211_ATTR_QOS_MAP: IP DSCP mapping for Interworking QoS mapping. This"]
#[doc = "\tdata is in the format defined for the payload of the QoS Map Set element"]
#[doc = "\tin IEEE Std 802.11-2012, 8.4.2.97."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MAC_HINT: MAC address recommendation as initial BSS"]
#[doc = " @NL80211_ATTR_WIPHY_FREQ_HINT: frequency of the recommended initial BSS"]
#[doc = ""]
#[doc = " @NL80211_ATTR_MAX_AP_ASSOC_STA: Device attribute that indicates how many"]
#[doc = "\tassociated stations are supported in AP mode (including P2P GO); u32."]
#[doc = "\tSince drivers may not have a fixed limit on the maximum number (e.g.,"]
#[doc = "\tother concurrent operations may affect this), drivers are allowed to"]
#[doc = "\tadvertise values that cannot always be met. In such cases, an attempt"]
#[doc = "\tto add a new station entry with @NL80211_CMD_NEW_STATION may fail."]
#[doc = ""]
#[doc = " @NL80211_ATTR_CSA_C_OFFSETS_TX: An array of csa counter offsets (u16) which"]
#[doc = "\tshould be updated when the frame is transmitted."]
#[doc = " @NL80211_ATTR_MAX_CSA_COUNTERS: U8 attribute used to advertise the maximum"]
#[doc = "\tsupported number of csa counters."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TDLS_PEER_CAPABILITY: flags for TDLS peer capabilities, u32."]
#[doc = "\tAs specified in the &enum nl80211_tdls_peer_capability."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SOCKET_OWNER: Flag attribute, if set during interface"]
#[doc = "\tcreation then the new interface will be owned by the netlink socket"]
#[doc = "\tthat created it and will be destroyed when the socket is closed."]
#[doc = "\tIf set during scheduled scan start then the new scan req will be"]
#[doc = "\towned by the netlink socket that created it and the scheduled scan will"]
#[doc = "\tbe stopped when the socket is closed."]
#[doc = "\tIf set during configuration of regulatory indoor operation then the"]
#[doc = "\tregulatory indoor configuration would be owned by the netlink socket"]
#[doc = "\tthat configured the indoor setting, and the indoor operation would be"]
#[doc = "\tcleared when the socket is closed."]
#[doc = "\tIf set during NAN interface creation, the interface will be destroyed"]
#[doc = "\tif the socket is closed just like any other interface. Moreover, NAN"]
#[doc = "\tnotifications will be sent in unicast to that socket. Without this"]
#[doc = "\tattribute, the notifications will be sent to the %NL80211_MCGRP_NAN"]
#[doc = "\tmulticast group."]
#[doc = "\tIf set during %NL80211_CMD_ASSOCIATE or %NL80211_CMD_CONNECT the"]
#[doc = "\tstation will deauthenticate when the socket is closed."]
#[doc = "\tIf set during %NL80211_CMD_JOIN_IBSS the IBSS will be automatically"]
#[doc = "\ttorn down when the socket is closed."]
#[doc = "\tIf set during %NL80211_CMD_JOIN_MESH the mesh setup will be"]
#[doc = "\tautomatically torn down when the socket is closed."]
#[doc = "\tIf set during %NL80211_CMD_START_AP the AP will be automatically"]
#[doc = "\tdisabled when the socket is closed."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TDLS_INITIATOR: flag attribute indicating the current end is"]
#[doc = "\tthe TDLS link initiator."]
#[doc = ""]
#[doc = " @NL80211_ATTR_USE_RRM: flag for indicating whether the current connection"]
#[doc = "\tshall support Radio Resource Measurements (11k). This attribute can be"]
#[doc = "\tused with %NL80211_CMD_ASSOCIATE and %NL80211_CMD_CONNECT requests."]
#[doc = "\tUser space applications are expected to use this flag only if the"]
#[doc = "\tunderlying device supports these minimal RRM features:"]
#[doc = "\t\t%NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES,"]
#[doc = "\t\t%NL80211_FEATURE_QUIET,"]
#[doc = "\tOr, if global RRM is supported, see:"]
#[doc = "\t\t%NL80211_EXT_FEATURE_RRM"]
#[doc = "\tIf this flag is used, driver must add the Power Capabilities IE to the"]
#[doc = "\tassociation request. In addition, it must also set the RRM capability"]
#[doc = "\tflag in the association request's Capability Info field."]
#[doc = ""]
#[doc = " @NL80211_ATTR_WIPHY_DYN_ACK: flag attribute used to enable ACK timeout"]
#[doc = "\testimation algorithm (dynack). In order to activate dynack"]
#[doc = "\t%NL80211_FEATURE_ACKTO_ESTIMATION feature flag must be set by lower"]
#[doc = "\tdrivers to indicate dynack capability. Dynack is automatically disabled"]
#[doc = "\tsetting valid value for coverage class."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TSID: a TSID value (u8 attribute)"]
#[doc = " @NL80211_ATTR_USER_PRIO: user priority value (u8 attribute)"]
#[doc = " @NL80211_ATTR_ADMITTED_TIME: admitted time in units of 32 microseconds"]
#[doc = "\t(per second) (u16 attribute)"]
#[doc = ""]
#[doc = " @NL80211_ATTR_SMPS_MODE: SMPS mode to use (ap mode). see"]
#[doc = "\t&enum nl80211_smps_mode."]
#[doc = ""]
#[doc = " @NL80211_ATTR_OPER_CLASS: operating class"]
#[doc = ""]
#[doc = " @NL80211_ATTR_MAC_MASK: MAC address mask"]
#[doc = ""]
#[doc = " @NL80211_ATTR_WIPHY_SELF_MANAGED_REG: flag attribute indicating this device"]
#[doc = "\tis self-managing its regulatory information and any regulatory domain"]
#[doc = "\tobtained from it is coming from the device's wiphy and not the global"]
#[doc = "\tcfg80211 regdomain."]
#[doc = ""]
#[doc = " @NL80211_ATTR_EXT_FEATURES: extended feature flags contained in a byte"]
#[doc = "\tarray. The feature flags are identified by their bit index (see &enum"]
#[doc = "\tnl80211_ext_feature_index). The bit index is ordered starting at the"]
#[doc = "\tleast-significant bit of the first byte in the array, ie. bit index 0"]
#[doc = "\tis located at bit 0 of byte 0. bit index 25 would be located at bit 1"]
#[doc = "\tof byte 3 (u8 array)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SURVEY_RADIO_STATS: Request overall radio statistics to be"]
#[doc = "\treturned along with other survey data. If set, @NL80211_CMD_GET_SURVEY"]
#[doc = "\tmay return a survey entry without a channel indicating global radio"]
#[doc = "\tstatistics (only some values are valid and make sense.)"]
#[doc = "\tFor devices that don't return such an entry even then, the information"]
#[doc = "\tshould be contained in the result as the sum of the respective counters"]
#[doc = "\tover all channels."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SCHED_SCAN_DELAY: delay before the first cycle of a"]
#[doc = "\tscheduled scan is started.  Or the delay before a WoWLAN"]
#[doc = "\tnet-detect scan is started, counting from the moment the"]
#[doc = "\tsystem is suspended.  This value is a u32, in seconds."]
#[doc = ""]
#[doc = " @NL80211_ATTR_REG_INDOOR: flag attribute, if set indicates that the device"]
#[doc = "      is operating in an indoor environment."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS: maximum number of scan plans for"]
#[doc = "\tscheduled scan supported by the device (u32), a wiphy attribute."]
#[doc = " @NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL: maximum interval (in seconds) for"]
#[doc = "\ta scan plan (u32), a wiphy attribute."]
#[doc = " @NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS: maximum number of iterations in"]
#[doc = "\ta scan plan (u32), a wiphy attribute."]
#[doc = " @NL80211_ATTR_SCHED_SCAN_PLANS: a list of scan plans for scheduled scan."]
#[doc = "\tEach scan plan defines the number of scan iterations and the interval"]
#[doc = "\tbetween scans. The last scan plan will always run infinitely,"]
#[doc = "\tthus it must not specify the number of iterations, only the interval"]
#[doc = "\tbetween scans. The scan plans are executed sequentially."]
#[doc = "\tEach scan plan is a nested attribute of &enum nl80211_sched_scan_plan."]
#[doc = " @NL80211_ATTR_PBSS: flag attribute. If set it means operate"]
#[doc = "\tin a PBSS. Specified in %NL80211_CMD_CONNECT to request"]
#[doc = "\tconnecting to a PCP, and in %NL80211_CMD_START_AP to start"]
#[doc = "\ta PCP instead of AP. Relevant for DMG networks only."]
#[doc = " @NL80211_ATTR_BSS_SELECT: nested attribute for driver supporting the"]
#[doc = "\tBSS selection feature. When used with %NL80211_CMD_GET_WIPHY it contains"]
#[doc = "\tattributes according &enum nl80211_bss_select_attr to indicate what"]
#[doc = "\tBSS selection behaviours are supported. When used with %NL80211_CMD_CONNECT"]
#[doc = "\tit contains the behaviour-specific attribute containing the parameters for"]
#[doc = "\tBSS selection to be done by driver and/or firmware."]
#[doc = ""]
#[doc = " @NL80211_ATTR_STA_SUPPORT_P2P_PS: whether P2P PS mechanism supported"]
#[doc = "\tor not. u8, one of the values of &enum nl80211_sta_p2p_ps_status"]
#[doc = ""]
#[doc = " @NL80211_ATTR_PAD: attribute used for padding for 64-bit alignment"]
#[doc = ""]
#[doc = " @NL80211_ATTR_IFTYPE_EXT_CAPA: Nested attribute of the following attributes:"]
#[doc = "\t%NL80211_ATTR_IFTYPE, %NL80211_ATTR_EXT_CAPA,"]
#[doc = "\t%NL80211_ATTR_EXT_CAPA_MASK, to specify the extended capabilities per"]
#[doc = "\tinterface type."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MU_MIMO_GROUP_DATA: array of 24 bytes that defines a MU-MIMO"]
#[doc = "\tgroupID for monitor mode."]
#[doc = "\tThe first 8 bytes are a mask that defines the membership in each"]
#[doc = "\tgroup (there are 64 groups, group 0 and 63 are reserved),"]
#[doc = "\teach bit represents a group and set to 1 for being a member in"]
#[doc = "\tthat group and 0 for not being a member."]
#[doc = "\tThe remaining 16 bytes define the position in each group: 2 bits for"]
#[doc = "\teach group."]
#[doc = "\t(smaller group numbers represented on most significant bits and bigger"]
#[doc = "\tgroup numbers on least significant bits.)"]
#[doc = "\tThis attribute is used only if all interfaces are in monitor mode."]
#[doc = "\tSet this attribute in order to monitor packets using the given MU-MIMO"]
#[doc = "\tgroupID data."]
#[doc = "\tto turn off that feature set all the bits of the groupID to zero."]
#[doc = " @NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR: mac address for the sniffer to follow"]
#[doc = "\twhen using MU-MIMO air sniffer."]
#[doc = "\tto turn that feature off set an invalid mac address"]
#[doc = "\t(e.g. FF:FF:FF:FF:FF:FF)"]
#[doc = ""]
#[doc = " @NL80211_ATTR_SCAN_START_TIME_TSF: The time at which the scan was actually"]
#[doc = "\tstarted (u64). The time is the TSF of the BSS the interface that"]
#[doc = "\trequested the scan is connected to (if available, otherwise this"]
#[doc = "\tattribute must not be included)."]
#[doc = " @NL80211_ATTR_SCAN_START_TIME_TSF_BSSID: The BSS according to which"]
#[doc = "\t%NL80211_ATTR_SCAN_START_TIME_TSF is set."]
#[doc = " @NL80211_ATTR_MEASUREMENT_DURATION: measurement duration in TUs (u16). If"]
#[doc = "\t%NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY is not set, this is the"]
#[doc = "\tmaximum measurement duration allowed. This attribute is used with"]
#[doc = "\tmeasurement requests. It can also be used with %NL80211_CMD_TRIGGER_SCAN"]
#[doc = "\tif the scan is used for beacon report radio measurement."]
#[doc = " @NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY: flag attribute that indicates"]
#[doc = "\tthat the duration specified with %NL80211_ATTR_MEASUREMENT_DURATION is"]
#[doc = "\tmandatory. If this flag is not set, the duration is the maximum duration"]
#[doc = "\tand the actual measurement duration may be shorter."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MESH_PEER_AID: Association ID for the mesh peer (u16). This is"]
#[doc = "\tused to pull the stored data for mesh peer in power save state."]
#[doc = ""]
#[doc = " @NL80211_ATTR_NAN_MASTER_PREF: the master preference to be used by"]
#[doc = "\t%NL80211_CMD_START_NAN and optionally with"]
#[doc = "\t%NL80211_CMD_CHANGE_NAN_CONFIG. Its type is u8 and it can't be 0."]
#[doc = "\tAlso, values 1 and 255 are reserved for certification purposes and"]
#[doc = "\tshould not be used during a normal device operation."]
#[doc = " @NL80211_ATTR_BANDS: operating bands configuration.  This is a u32"]
#[doc = "\tbitmask of BIT(NL80211_BAND_*) as described in %enum"]
#[doc = "\tnl80211_band.  For instance, for NL80211_BAND_2GHZ, bit 0"]
#[doc = "\twould be set.  This attribute is used with"]
#[doc = "\t%NL80211_CMD_START_NAN and %NL80211_CMD_CHANGE_NAN_CONFIG, and"]
#[doc = "\tit is optional.  If no bands are set, it means don't-care and"]
#[doc = "\tthe device will decide what to use."]
#[doc = " @NL80211_ATTR_NAN_FUNC: a function that can be added to NAN. See"]
#[doc = "\t&enum nl80211_nan_func_attributes for description of this nested"]
#[doc = "\tattribute."]
#[doc = " @NL80211_ATTR_NAN_MATCH: used to report a match. This is a nested attribute."]
#[doc = "\tSee &enum nl80211_nan_match_attributes."]
#[doc = " @NL80211_ATTR_FILS_KEK: KEK for FILS (Re)Association Request/Response frame"]
#[doc = "\tprotection."]
#[doc = " @NL80211_ATTR_FILS_NONCES: Nonces (part of AAD) for FILS (Re)Association"]
#[doc = "\tRequest/Response frame protection. This attribute contains the 16 octet"]
#[doc = "\tSTA Nonce followed by 16 octets of AP Nonce."]
#[doc = ""]
#[doc = " @NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED: Indicates whether or not multicast"]
#[doc = "\tpackets should be send out as unicast to all stations (flag attribute)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_BSSID: The BSSID of the AP. Note that %NL80211_ATTR_MAC is also"]
#[doc = "\tused in various commands/events for specifying the BSSID."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI: Relative RSSI threshold by which"]
#[doc = "\tother BSSs has to be better or slightly worse than the current"]
#[doc = "\tconnected BSS so that they get reported to user space."]
#[doc = "\tThis will give an opportunity to userspace to consider connecting to"]
#[doc = "\tother matching BSSs which have better or slightly worse RSSI than"]
#[doc = "\tthe current connected BSS by using an offloaded operation to avoid"]
#[doc = "\tunnecessary wakeups."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST: When present the RSSI level for BSSs in"]
#[doc = "\tthe specified band is to be adjusted before doing"]
#[doc = "\t%NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI based comparison to figure out"]
#[doc = "\tbetter BSSs. The attribute value is a packed structure"]
#[doc = "\tvalue as specified by &struct nl80211_bss_select_rssi_adjust."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TIMEOUT_REASON: The reason for which an operation timed out."]
#[doc = "\tu32 attribute with an &enum nl80211_timeout_reason value. This is used,"]
#[doc = "\te.g., with %NL80211_CMD_CONNECT event."]
#[doc = ""]
#[doc = " @NL80211_ATTR_FILS_ERP_USERNAME: EAP Re-authentication Protocol (ERP)"]
#[doc = "\tusername part of NAI used to refer keys rRK and rIK. This is used with"]
#[doc = "\t%NL80211_CMD_CONNECT."]
#[doc = ""]
#[doc = " @NL80211_ATTR_FILS_ERP_REALM: EAP Re-authentication Protocol (ERP) realm part"]
#[doc = "\tof NAI specifying the domain name of the ER server. This is used with"]
#[doc = "\t%NL80211_CMD_CONNECT."]
#[doc = ""]
#[doc = " @NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM: Unsigned 16-bit ERP next sequence number"]
#[doc = "\tto use in ERP messages. This is used in generating the FILS wrapped data"]
#[doc = "\tfor FILS authentication and is used with %NL80211_CMD_CONNECT."]
#[doc = ""]
#[doc = " @NL80211_ATTR_FILS_ERP_RRK: ERP re-authentication Root Key (rRK) for the"]
#[doc = "\tNAI specified by %NL80211_ATTR_FILS_ERP_USERNAME and"]
#[doc = "\t%NL80211_ATTR_FILS_ERP_REALM. This is used for generating rIK and rMSK"]
#[doc = "\tfrom successful FILS authentication and is used with"]
#[doc = "\t%NL80211_CMD_CONNECT."]
#[doc = ""]
#[doc = " @NL80211_ATTR_FILS_CACHE_ID: A 2-octet identifier advertized by a FILS AP"]
#[doc = "\tidentifying the scope of PMKSAs. This is used with"]
#[doc = "\t@NL80211_CMD_SET_PMKSA and @NL80211_CMD_DEL_PMKSA."]
#[doc = ""]
#[doc = " @NL80211_ATTR_PMK: attribute for passing PMK key material. Used with"]
#[doc = "\t%NL80211_CMD_SET_PMKSA for the PMKSA identified by %NL80211_ATTR_PMKID."]
#[doc = "\tFor %NL80211_CMD_CONNECT and %NL80211_CMD_START_AP it is used to provide"]
#[doc = "\tPSK for offloading 4-way handshake for WPA/WPA2-PSK networks. For 802.1X"]
#[doc = "\tauthentication it is used with %NL80211_CMD_SET_PMK. For offloaded FT"]
#[doc = "\tsupport this attribute specifies the PMK-R0 if NL80211_ATTR_PMKR0_NAME"]
#[doc = "\tis included as well."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SCHED_SCAN_MULTI: flag attribute which user-space shall use to"]
#[doc = "\tindicate that it supports multiple active scheduled scan requests."]
#[doc = " @NL80211_ATTR_SCHED_SCAN_MAX_REQS: indicates maximum number of scheduled"]
#[doc = "\tscan request that may be active for the device (u32)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_WANT_1X_4WAY_HS: flag attribute which user-space can include"]
#[doc = "\tin %NL80211_CMD_CONNECT to indicate that for 802.1X authentication it"]
#[doc = "\twants to use the supported offload of the 4-way handshake."]
#[doc = " @NL80211_ATTR_PMKR0_NAME: PMK-R0 Name for offloaded FT."]
#[doc = " @NL80211_ATTR_PORT_AUTHORIZED: (reserved)"]
#[doc = ""]
#[doc = " @NL80211_ATTR_EXTERNAL_AUTH_ACTION: Identify the requested external"]
#[doc = "     authentication operation (u32 attribute with an"]
#[doc = "     &enum nl80211_external_auth_action value). This is used with the"]
#[doc = "     %NL80211_CMD_EXTERNAL_AUTH request event."]
#[doc = " @NL80211_ATTR_EXTERNAL_AUTH_SUPPORT: Flag attribute indicating that the user"]
#[doc = "\tspace supports external authentication. This attribute shall be used"]
#[doc = "\twith %NL80211_CMD_CONNECT and %NL80211_CMD_START_AP request. The driver"]
#[doc = "\tmay offload authentication processing to user space if this capability"]
#[doc = "\tis indicated in the respective requests from the user space."]
#[doc = ""]
#[doc = " @NL80211_ATTR_NSS: Station's New/updated  RX_NSS value notified using this"]
#[doc = "\tu8 attribute. This is used with %NL80211_CMD_STA_OPMODE_CHANGED."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TXQ_STATS: TXQ statistics (nested attribute, see &enum"]
#[doc = "      nl80211_txq_stats)"]
#[doc = " @NL80211_ATTR_TXQ_LIMIT: Total packet limit for the TXQ queues for this phy."]
#[doc = "      The smaller of this and the memory limit is enforced."]
#[doc = " @NL80211_ATTR_TXQ_MEMORY_LIMIT: Total memory limit (in bytes) for the"]
#[doc = "      TXQ queues for this phy. The smaller of this and the packet limit is"]
#[doc = "      enforced."]
#[doc = " @NL80211_ATTR_TXQ_QUANTUM: TXQ scheduler quantum (bytes). Number of bytes"]
#[doc = "      a flow is assigned on each round of the DRR scheduler."]
#[doc = " @NL80211_ATTR_HE_CAPABILITY: HE Capability information element (from"]
#[doc = "\tassociation request when used with NL80211_CMD_NEW_STATION). Can be set"]
#[doc = "\tonly if %NL80211_STA_FLAG_WME is set."]
#[doc = ""]
#[doc = " @NL80211_ATTR_FTM_RESPONDER: nested attribute which user-space can include"]
#[doc = "\tin %NL80211_CMD_START_AP or %NL80211_CMD_SET_BEACON for fine timing"]
#[doc = "\tmeasurement (FTM) responder functionality and containing parameters as"]
#[doc = "\tpossible, see &enum nl80211_ftm_responder_attr"]
#[doc = ""]
#[doc = " @NL80211_ATTR_FTM_RESPONDER_STATS: Nested attribute with FTM responder"]
#[doc = "\tstatistics, see &enum nl80211_ftm_responder_stats."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TIMEOUT: Timeout for the given operation in milliseconds (u32),"]
#[doc = "\tif the attribute is not given no timeout is requested. Note that 0 is an"]
#[doc = "\tinvalid value."]
#[doc = ""]
#[doc = " @NL80211_ATTR_PEER_MEASUREMENTS: peer measurements request (and result)"]
#[doc = "\tdata, uses nested attributes specified in"]
#[doc = "\t&enum nl80211_peer_measurement_attrs."]
#[doc = "\tThis is also used for capability advertisement in the wiphy information,"]
#[doc = "\twith the appropriate sub-attributes."]
#[doc = ""]
#[doc = " @NL80211_ATTR_AIRTIME_WEIGHT: Station's weight when scheduled by the airtime"]
#[doc = "\tscheduler."]
#[doc = ""]
#[doc = " @NL80211_ATTR_STA_TX_POWER_SETTING: Transmit power setting type (u8) for"]
#[doc = "\tstation associated with the AP. See &enum nl80211_tx_power_setting for"]
#[doc = "\tpossible values."]
#[doc = " @NL80211_ATTR_STA_TX_POWER: Transmit power level (s16) in dBm units. This"]
#[doc = "\tallows to set Tx power for a station. If this attribute is not included,"]
#[doc = "\tthe default per-interface tx power setting will be overriding. Driver"]
#[doc = "\tshould be picking up the lowest tx power, either tx power per-interface"]
#[doc = "\tor per-station."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SAE_PASSWORD: attribute for passing SAE password material. It"]
#[doc = "\tis used with %NL80211_CMD_CONNECT to provide password for offloading"]
#[doc = "\tSAE authentication for WPA3-Personal networks."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TWT_RESPONDER: Enable target wait time responder support."]
#[doc = ""]
#[doc = " @NL80211_ATTR_HE_OBSS_PD: nested attribute for OBSS Packet Detection"]
#[doc = "\tfunctionality."]
#[doc = ""]
#[doc = " @NL80211_ATTR_WIPHY_EDMG_CHANNELS: bitmap that indicates the 2.16 GHz"]
#[doc = "\tchannel(s) that are allowed to be used for EDMG transmissions."]
#[doc = "\tDefined by IEEE P802.11ay/D4.0 section 9.4.2.251. (u8 attribute)"]
#[doc = " @NL80211_ATTR_WIPHY_EDMG_BW_CONFIG: Channel BW Configuration subfield encodes"]
#[doc = "\tthe allowed channel bandwidth configurations. (u8 attribute)"]
#[doc = "\tDefined by IEEE P802.11ay/D4.0 section 9.4.2.251, Table 13."]
#[doc = ""]
#[doc = " @NL80211_ATTR_VLAN_ID: VLAN ID (1..4094) for the station and VLAN group key"]
#[doc = "\t(u16)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_HE_BSS_COLOR: nested attribute for BSS Color Settings."]
#[doc = ""]
#[doc = " @NL80211_ATTR_IFTYPE_AKM_SUITES: nested array attribute, with each entry"]
#[doc = "\tusing attributes from &enum nl80211_iftype_akm_attributes. This"]
#[doc = "\tattribute is sent in a response to %NL80211_CMD_GET_WIPHY indicating"]
#[doc = "\tsupported AKM suites capability per interface. AKMs advertised in"]
#[doc = "\t%NL80211_ATTR_AKM_SUITES are default capabilities if AKM suites not"]
#[doc = "\tadvertised for a specific interface type."]
#[doc = ""]
#[doc = " @NL80211_ATTR_TID_CONFIG: TID specific configuration in a"]
#[doc = "\tnested attribute with &enum nl80211_tid_config_attr sub-attributes;"]
#[doc = "\ton output (in wiphy attributes) it contains only the feature sub-"]
#[doc = "\tattributes."]
#[doc = ""]
#[doc = " @NL80211_ATTR_CONTROL_PORT_NO_PREAUTH: disable preauth frame rx on control"]
#[doc = "\tport in order to forward/receive them as ordinary data frames."]
#[doc = ""]
#[doc = " @NL80211_ATTR_PMK_LIFETIME: Maximum lifetime for PMKSA in seconds (u32,"]
#[doc = "\tdot11RSNAConfigPMKReauthThreshold; 0 is not a valid value)."]
#[doc = "\tAn optional parameter configured through %NL80211_CMD_SET_PMKSA."]
#[doc = "\tDrivers that trigger roaming need to know the lifetime of the"]
#[doc = "\tconfigured PMKSA for triggering the full vs. PMKSA caching based"]
#[doc = "\tauthentication. This timeout helps authentication methods like SAE,"]
#[doc = "\twhere PMK gets updated only by going through a full (new SAE)"]
#[doc = "\tauthentication instead of getting updated during an association for EAP"]
#[doc = "\tauthentication. No new full authentication within the PMK expiry shall"]
#[doc = "\tresult in a disassociation at the end of the lifetime."]
#[doc = ""]
#[doc = " @NL80211_ATTR_PMK_REAUTH_THRESHOLD: Reauthentication threshold time, in"]
#[doc = "\tterms of percentage of %NL80211_ATTR_PMK_LIFETIME"]
#[doc = "\t(u8, dot11RSNAConfigPMKReauthThreshold, 1..100). This is an optional"]
#[doc = "\tparameter configured through %NL80211_CMD_SET_PMKSA. Requests the"]
#[doc = "\tdriver to trigger a full authentication roam (without PMKSA caching)"]
#[doc = "\tafter the reauthentication threshold time, but before the PMK lifetime"]
#[doc = "\thas expired."]
#[doc = ""]
#[doc = "\tAuthentication methods like SAE need to be able to generate a new PMKSA"]
#[doc = "\tentry without having to force a disconnection after the PMK timeout. If"]
#[doc = "\tno roaming occurs between the reauth threshold and PMK expiration,"]
#[doc = "\tdisassociation is still forced."]
#[doc = " @NL80211_ATTR_RECEIVE_MULTICAST: multicast flag for the"]
#[doc = "\t%NL80211_CMD_REGISTER_FRAME command, see the description there."]
#[doc = " @NL80211_ATTR_WIPHY_FREQ_OFFSET: offset of the associated"]
#[doc = "\t%NL80211_ATTR_WIPHY_FREQ in positive KHz. Only valid when supplied with"]
#[doc = "\tan %NL80211_ATTR_WIPHY_FREQ_OFFSET."]
#[doc = " @NL80211_ATTR_CENTER_FREQ1_OFFSET: Center frequency offset in KHz for the"]
#[doc = "\tfirst channel segment specified in %NL80211_ATTR_CENTER_FREQ1."]
#[doc = " @NL80211_ATTR_SCAN_FREQ_KHZ: nested attribute with KHz frequencies"]
#[doc = ""]
#[doc = " @NL80211_ATTR_HE_6GHZ_CAPABILITY: HE 6 GHz Band Capability element (from"]
#[doc = "\tassociation request when used with NL80211_CMD_NEW_STATION)."]
#[doc = ""]
#[doc = " @NL80211_ATTR_FILS_DISCOVERY: Optional parameter to configure FILS"]
#[doc = "\tdiscovery. It is a nested attribute, see"]
#[doc = "\t&enum nl80211_fils_discovery_attributes."]
#[doc = ""]
#[doc = " @NL80211_ATTR_UNSOL_BCAST_PROBE_RESP: Optional parameter to configure"]
#[doc = "\tunsolicited broadcast probe response. It is a nested attribute, see"]
#[doc = "\t&enum nl80211_unsol_bcast_probe_resp_attributes."]
#[doc = ""]
#[doc = " @NL80211_ATTR_S1G_CAPABILITY: S1G Capability information element (from"]
#[doc = "\tassociation request when used with NL80211_CMD_NEW_STATION)"]
#[doc = " @NL80211_ATTR_S1G_CAPABILITY_MASK: S1G Capability Information element"]
#[doc = "\toverride mask. Used with NL80211_ATTR_S1G_CAPABILITY in"]
#[doc = "\tNL80211_CMD_ASSOCIATE or NL80211_CMD_CONNECT."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SAE_PWE: Indicates the mechanism(s) allowed for SAE PWE"]
#[doc = "\tderivation in WPA3-Personal networks which are using SAE authentication."]
#[doc = "\tThis is a u8 attribute that encapsulates one of the values from"]
#[doc = "\t&enum nl80211_sae_pwe_mechanism."]
#[doc = ""]
#[doc = " @NL80211_ATTR_SAR_SPEC: SAR power limitation specification when"]
#[doc = "\tused with %NL80211_CMD_SET_SAR_SPECS. The message contains fields"]
#[doc = "\tof %nl80211_sar_attrs which specifies the sar type and related"]
#[doc = "\tsar specs. Sar specs contains array of %nl80211_sar_specs_attrs."]
#[doc = ""]
#[doc = " @NL80211_ATTR_RECONNECT_REQUESTED: flag attribute, used with deauth and"]
#[doc = "\tdisassoc events to indicate that an immediate reconnect to the AP"]
#[doc = "\tis desired."]
#[doc = ""]
#[doc = " @NUM_NL80211_ATTR: total number of nl80211_attrs available"]
#[doc = " @NL80211_ATTR_MAX: highest attribute number currently defined"]
#[doc = " @__NL80211_ATTR_AFTER_LAST: internal use"]
pub type nl80211_attrs = ::std::os::raw::c_uint;
pub const nl80211_iftype_NL80211_IFTYPE_UNSPECIFIED: nl80211_iftype = 0;
pub const nl80211_iftype_NL80211_IFTYPE_ADHOC: nl80211_iftype = 1;
pub const nl80211_iftype_NL80211_IFTYPE_STATION: nl80211_iftype = 2;
pub const nl80211_iftype_NL80211_IFTYPE_AP: nl80211_iftype = 3;
pub const nl80211_iftype_NL80211_IFTYPE_AP_VLAN: nl80211_iftype = 4;
pub const nl80211_iftype_NL80211_IFTYPE_WDS: nl80211_iftype = 5;
pub const nl80211_iftype_NL80211_IFTYPE_MONITOR: nl80211_iftype = 6;
pub const nl80211_iftype_NL80211_IFTYPE_MESH_POINT: nl80211_iftype = 7;
pub const nl80211_iftype_NL80211_IFTYPE_P2P_CLIENT: nl80211_iftype = 8;
pub const nl80211_iftype_NL80211_IFTYPE_P2P_GO: nl80211_iftype = 9;
pub const nl80211_iftype_NL80211_IFTYPE_P2P_DEVICE: nl80211_iftype = 10;
pub const nl80211_iftype_NL80211_IFTYPE_OCB: nl80211_iftype = 11;
pub const nl80211_iftype_NL80211_IFTYPE_NAN: nl80211_iftype = 12;
pub const nl80211_iftype_NUM_NL80211_IFTYPES: nl80211_iftype = 13;
pub const nl80211_iftype_NL80211_IFTYPE_MAX: nl80211_iftype = 12;
#[doc = " enum nl80211_iftype - (virtual) interface types"]
#[doc = ""]
#[doc = " @NL80211_IFTYPE_UNSPECIFIED: unspecified type, driver decides"]
#[doc = " @NL80211_IFTYPE_ADHOC: independent BSS member"]
#[doc = " @NL80211_IFTYPE_STATION: managed BSS member"]
#[doc = " @NL80211_IFTYPE_AP: access point"]
#[doc = " @NL80211_IFTYPE_AP_VLAN: VLAN interface for access points; VLAN interfaces"]
#[doc = "\tare a bit special in that they must always be tied to a pre-existing"]
#[doc = "\tAP type interface."]
#[doc = " @NL80211_IFTYPE_WDS: wireless distribution interface"]
#[doc = " @NL80211_IFTYPE_MONITOR: monitor interface receiving all frames"]
#[doc = " @NL80211_IFTYPE_MESH_POINT: mesh point"]
#[doc = " @NL80211_IFTYPE_P2P_CLIENT: P2P client"]
#[doc = " @NL80211_IFTYPE_P2P_GO: P2P group owner"]
#[doc = " @NL80211_IFTYPE_P2P_DEVICE: P2P device interface type, this is not a netdev"]
#[doc = "\tand therefore can't be created in the normal ways, use the"]
#[doc = "\t%NL80211_CMD_START_P2P_DEVICE and %NL80211_CMD_STOP_P2P_DEVICE"]
#[doc = "\tcommands to create and destroy one"]
#[doc = " @NL80211_IF_TYPE_OCB: Outside Context of a BSS"]
#[doc = "\tThis mode corresponds to the MIB variable dot11OCBActivated=true"]
#[doc = " @NL80211_IFTYPE_NAN: NAN device interface type (not a netdev)"]
#[doc = " @NL80211_IFTYPE_MAX: highest interface type number currently defined"]
#[doc = " @NUM_NL80211_IFTYPES: number of defined interface types"]
#[doc = ""]
#[doc = " These values are used with the %NL80211_ATTR_IFTYPE"]
#[doc = " to set the type of an interface."]
#[doc = ""]
pub type nl80211_iftype = ::std::os::raw::c_uint;
pub const nl80211_sta_flags___NL80211_STA_FLAG_INVALID: nl80211_sta_flags = 0;
pub const nl80211_sta_flags_NL80211_STA_FLAG_AUTHORIZED: nl80211_sta_flags = 1;
pub const nl80211_sta_flags_NL80211_STA_FLAG_SHORT_PREAMBLE: nl80211_sta_flags = 2;
pub const nl80211_sta_flags_NL80211_STA_FLAG_WME: nl80211_sta_flags = 3;
pub const nl80211_sta_flags_NL80211_STA_FLAG_MFP: nl80211_sta_flags = 4;
pub const nl80211_sta_flags_NL80211_STA_FLAG_AUTHENTICATED: nl80211_sta_flags = 5;
pub const nl80211_sta_flags_NL80211_STA_FLAG_TDLS_PEER: nl80211_sta_flags = 6;
pub const nl80211_sta_flags_NL80211_STA_FLAG_ASSOCIATED: nl80211_sta_flags = 7;
pub const nl80211_sta_flags___NL80211_STA_FLAG_AFTER_LAST: nl80211_sta_flags = 8;
pub const nl80211_sta_flags_NL80211_STA_FLAG_MAX: nl80211_sta_flags = 7;
#[doc = " enum nl80211_sta_flags - station flags"]
#[doc = ""]
#[doc = " Station flags. When a station is added to an AP interface, it is"]
#[doc = " assumed to be already associated (and hence authenticated.)"]
#[doc = ""]
#[doc = " @__NL80211_STA_FLAG_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_STA_FLAG_AUTHORIZED: station is authorized (802.1X)"]
#[doc = " @NL80211_STA_FLAG_SHORT_PREAMBLE: station is capable of receiving frames"]
#[doc = "\twith short barker preamble"]
#[doc = " @NL80211_STA_FLAG_WME: station is WME/QoS capable"]
#[doc = " @NL80211_STA_FLAG_MFP: station uses management frame protection"]
#[doc = " @NL80211_STA_FLAG_AUTHENTICATED: station is authenticated"]
#[doc = " @NL80211_STA_FLAG_TDLS_PEER: station is a TDLS peer -- this flag should"]
#[doc = "\tonly be used in managed mode (even in the flags mask). Note that the"]
#[doc = "\tflag can't be changed, it is only valid while adding a station, and"]
#[doc = "\tattempts to change it will silently be ignored (rather than rejected"]
#[doc = "\tas errors.)"]
#[doc = " @NL80211_STA_FLAG_ASSOCIATED: station is associated; used with drivers"]
#[doc = "\tthat support %NL80211_FEATURE_FULL_AP_CLIENT_STATE to transition a"]
#[doc = "\tpreviously added station into associated state"]
#[doc = " @NL80211_STA_FLAG_MAX: highest station flag number currently defined"]
#[doc = " @__NL80211_STA_FLAG_AFTER_LAST: internal use"]
pub type nl80211_sta_flags = ::std::os::raw::c_uint;
pub const nl80211_sta_p2p_ps_status_NL80211_P2P_PS_UNSUPPORTED: nl80211_sta_p2p_ps_status = 0;
pub const nl80211_sta_p2p_ps_status_NL80211_P2P_PS_SUPPORTED: nl80211_sta_p2p_ps_status = 1;
pub const nl80211_sta_p2p_ps_status_NUM_NL80211_P2P_PS_STATUS: nl80211_sta_p2p_ps_status = 2;
#[doc = " enum nl80211_sta_p2p_ps_status - station support of P2P PS"]
#[doc = ""]
#[doc = " @NL80211_P2P_PS_UNSUPPORTED: station doesn't support P2P PS mechanism"]
#[doc = " @@NL80211_P2P_PS_SUPPORTED: station supports P2P PS mechanism"]
#[doc = " @NUM_NL80211_P2P_PS_STATUS: number of values"]
pub type nl80211_sta_p2p_ps_status = ::std::os::raw::c_uint;
#[doc = " struct nl80211_sta_flag_update - station flags mask/set"]
#[doc = " @mask: mask of station flags to set"]
#[doc = " @set: which values to set them to"]
#[doc = ""]
#[doc = " Both mask and set contain bits as per &enum nl80211_sta_flags."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_sta_flag_update {
    pub mask: __u32,
    pub set: __u32,
}
#[test]
fn bindgen_test_layout_nl80211_sta_flag_update() {
    assert_eq!(
        ::std::mem::size_of::<nl80211_sta_flag_update>(),
        8usize,
        concat!("Size of: ", stringify!(nl80211_sta_flag_update))
    );
    assert_eq!(
        ::std::mem::align_of::<nl80211_sta_flag_update>(),
        1usize,
        concat!("Alignment of ", stringify!(nl80211_sta_flag_update))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl80211_sta_flag_update>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_sta_flag_update),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl80211_sta_flag_update>())).set as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_sta_flag_update),
            "::",
            stringify!(set)
        )
    );
}
pub const nl80211_he_gi_NL80211_RATE_INFO_HE_GI_0_8: nl80211_he_gi = 0;
pub const nl80211_he_gi_NL80211_RATE_INFO_HE_GI_1_6: nl80211_he_gi = 1;
pub const nl80211_he_gi_NL80211_RATE_INFO_HE_GI_3_2: nl80211_he_gi = 2;
#[doc = " enum nl80211_he_gi - HE guard interval"]
#[doc = " @NL80211_RATE_INFO_HE_GI_0_8: 0.8 usec"]
#[doc = " @NL80211_RATE_INFO_HE_GI_1_6: 1.6 usec"]
#[doc = " @NL80211_RATE_INFO_HE_GI_3_2: 3.2 usec"]
pub type nl80211_he_gi = ::std::os::raw::c_uint;
pub const nl80211_he_ltf_NL80211_RATE_INFO_HE_1XLTF: nl80211_he_ltf = 0;
pub const nl80211_he_ltf_NL80211_RATE_INFO_HE_2XLTF: nl80211_he_ltf = 1;
pub const nl80211_he_ltf_NL80211_RATE_INFO_HE_4XLTF: nl80211_he_ltf = 2;
#[doc = " enum nl80211_he_ltf - HE long training field"]
#[doc = " @NL80211_RATE_INFO_HE_1xLTF: 3.2 usec"]
#[doc = " @NL80211_RATE_INFO_HE_2xLTF: 6.4 usec"]
#[doc = " @NL80211_RATE_INFO_HE_4xLTF: 12.8 usec"]
pub type nl80211_he_ltf = ::std::os::raw::c_uint;
pub const nl80211_he_ru_alloc_NL80211_RATE_INFO_HE_RU_ALLOC_26: nl80211_he_ru_alloc = 0;
pub const nl80211_he_ru_alloc_NL80211_RATE_INFO_HE_RU_ALLOC_52: nl80211_he_ru_alloc = 1;
pub const nl80211_he_ru_alloc_NL80211_RATE_INFO_HE_RU_ALLOC_106: nl80211_he_ru_alloc = 2;
pub const nl80211_he_ru_alloc_NL80211_RATE_INFO_HE_RU_ALLOC_242: nl80211_he_ru_alloc = 3;
pub const nl80211_he_ru_alloc_NL80211_RATE_INFO_HE_RU_ALLOC_484: nl80211_he_ru_alloc = 4;
pub const nl80211_he_ru_alloc_NL80211_RATE_INFO_HE_RU_ALLOC_996: nl80211_he_ru_alloc = 5;
pub const nl80211_he_ru_alloc_NL80211_RATE_INFO_HE_RU_ALLOC_2x996: nl80211_he_ru_alloc = 6;
#[doc = " enum nl80211_he_ru_alloc - HE RU allocation values"]
#[doc = " @NL80211_RATE_INFO_HE_RU_ALLOC_26: 26-tone RU allocation"]
#[doc = " @NL80211_RATE_INFO_HE_RU_ALLOC_52: 52-tone RU allocation"]
#[doc = " @NL80211_RATE_INFO_HE_RU_ALLOC_106: 106-tone RU allocation"]
#[doc = " @NL80211_RATE_INFO_HE_RU_ALLOC_242: 242-tone RU allocation"]
#[doc = " @NL80211_RATE_INFO_HE_RU_ALLOC_484: 484-tone RU allocation"]
#[doc = " @NL80211_RATE_INFO_HE_RU_ALLOC_996: 996-tone RU allocation"]
#[doc = " @NL80211_RATE_INFO_HE_RU_ALLOC_2x996: 2x996-tone RU allocation"]
pub type nl80211_he_ru_alloc = ::std::os::raw::c_uint;
pub const nl80211_rate_info___NL80211_RATE_INFO_INVALID: nl80211_rate_info = 0;
pub const nl80211_rate_info_NL80211_RATE_INFO_BITRATE: nl80211_rate_info = 1;
pub const nl80211_rate_info_NL80211_RATE_INFO_MCS: nl80211_rate_info = 2;
pub const nl80211_rate_info_NL80211_RATE_INFO_40_MHZ_WIDTH: nl80211_rate_info = 3;
pub const nl80211_rate_info_NL80211_RATE_INFO_SHORT_GI: nl80211_rate_info = 4;
pub const nl80211_rate_info_NL80211_RATE_INFO_BITRATE32: nl80211_rate_info = 5;
pub const nl80211_rate_info_NL80211_RATE_INFO_VHT_MCS: nl80211_rate_info = 6;
pub const nl80211_rate_info_NL80211_RATE_INFO_VHT_NSS: nl80211_rate_info = 7;
pub const nl80211_rate_info_NL80211_RATE_INFO_80_MHZ_WIDTH: nl80211_rate_info = 8;
pub const nl80211_rate_info_NL80211_RATE_INFO_80P80_MHZ_WIDTH: nl80211_rate_info = 9;
pub const nl80211_rate_info_NL80211_RATE_INFO_160_MHZ_WIDTH: nl80211_rate_info = 10;
pub const nl80211_rate_info_NL80211_RATE_INFO_10_MHZ_WIDTH: nl80211_rate_info = 11;
pub const nl80211_rate_info_NL80211_RATE_INFO_5_MHZ_WIDTH: nl80211_rate_info = 12;
pub const nl80211_rate_info_NL80211_RATE_INFO_HE_MCS: nl80211_rate_info = 13;
pub const nl80211_rate_info_NL80211_RATE_INFO_HE_NSS: nl80211_rate_info = 14;
pub const nl80211_rate_info_NL80211_RATE_INFO_HE_GI: nl80211_rate_info = 15;
pub const nl80211_rate_info_NL80211_RATE_INFO_HE_DCM: nl80211_rate_info = 16;
pub const nl80211_rate_info_NL80211_RATE_INFO_HE_RU_ALLOC: nl80211_rate_info = 17;
pub const nl80211_rate_info___NL80211_RATE_INFO_AFTER_LAST: nl80211_rate_info = 18;
pub const nl80211_rate_info_NL80211_RATE_INFO_MAX: nl80211_rate_info = 17;
#[doc = " enum nl80211_rate_info - bitrate information"]
#[doc = ""]
#[doc = " These attribute types are used with %NL80211_STA_INFO_TXRATE"]
#[doc = " when getting information about the bitrate of a station."]
#[doc = " There are 2 attributes for bitrate, a legacy one that represents"]
#[doc = " a 16-bit value, and new one that represents a 32-bit value."]
#[doc = " If the rate value fits into 16 bit, both attributes are reported"]
#[doc = " with the same value. If the rate is too high to fit into 16 bits"]
#[doc = " (>6.5535Gbps) only 32-bit attribute is included."]
#[doc = " User space tools encouraged to use the 32-bit attribute and fall"]
#[doc = " back to the 16-bit one for compatibility with older kernels."]
#[doc = ""]
#[doc = " @__NL80211_RATE_INFO_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_RATE_INFO_BITRATE: total bitrate (u16, 100kbit/s)"]
#[doc = " @NL80211_RATE_INFO_MCS: mcs index for 802.11n (u8)"]
#[doc = " @NL80211_RATE_INFO_40_MHZ_WIDTH: 40 MHz dualchannel bitrate"]
#[doc = " @NL80211_RATE_INFO_SHORT_GI: 400ns guard interval"]
#[doc = " @NL80211_RATE_INFO_BITRATE32: total bitrate (u32, 100kbit/s)"]
#[doc = " @NL80211_RATE_INFO_MAX: highest rate_info number currently defined"]
#[doc = " @NL80211_RATE_INFO_VHT_MCS: MCS index for VHT (u8)"]
#[doc = " @NL80211_RATE_INFO_VHT_NSS: number of streams in VHT (u8)"]
#[doc = " @NL80211_RATE_INFO_80_MHZ_WIDTH: 80 MHz VHT rate"]
#[doc = " @NL80211_RATE_INFO_80P80_MHZ_WIDTH: unused - 80+80 is treated the"]
#[doc = "\tsame as 160 for purposes of the bitrates"]
#[doc = " @NL80211_RATE_INFO_160_MHZ_WIDTH: 160 MHz VHT rate"]
#[doc = " @NL80211_RATE_INFO_10_MHZ_WIDTH: 10 MHz width - note that this is"]
#[doc = "\ta legacy rate and will be reported as the actual bitrate, i.e."]
#[doc = "\thalf the base (20 MHz) rate"]
#[doc = " @NL80211_RATE_INFO_5_MHZ_WIDTH: 5 MHz width - note that this is"]
#[doc = "\ta legacy rate and will be reported as the actual bitrate, i.e."]
#[doc = "\ta quarter of the base (20 MHz) rate"]
#[doc = " @NL80211_RATE_INFO_HE_MCS: HE MCS index (u8, 0-11)"]
#[doc = " @NL80211_RATE_INFO_HE_NSS: HE NSS value (u8, 1-8)"]
#[doc = " @NL80211_RATE_INFO_HE_GI: HE guard interval identifier"]
#[doc = "\t(u8, see &enum nl80211_he_gi)"]
#[doc = " @NL80211_RATE_INFO_HE_DCM: HE DCM value (u8, 0/1)"]
#[doc = " @NL80211_RATE_INFO_RU_ALLOC: HE RU allocation, if not present then"]
#[doc = "\tnon-OFDMA was used (u8, see &enum nl80211_he_ru_alloc)"]
#[doc = " @__NL80211_RATE_INFO_AFTER_LAST: internal use"]
pub type nl80211_rate_info = ::std::os::raw::c_uint;
pub const nl80211_sta_bss_param___NL80211_STA_BSS_PARAM_INVALID: nl80211_sta_bss_param = 0;
pub const nl80211_sta_bss_param_NL80211_STA_BSS_PARAM_CTS_PROT: nl80211_sta_bss_param = 1;
pub const nl80211_sta_bss_param_NL80211_STA_BSS_PARAM_SHORT_PREAMBLE: nl80211_sta_bss_param = 2;
pub const nl80211_sta_bss_param_NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME: nl80211_sta_bss_param = 3;
pub const nl80211_sta_bss_param_NL80211_STA_BSS_PARAM_DTIM_PERIOD: nl80211_sta_bss_param = 4;
pub const nl80211_sta_bss_param_NL80211_STA_BSS_PARAM_BEACON_INTERVAL: nl80211_sta_bss_param = 5;
pub const nl80211_sta_bss_param___NL80211_STA_BSS_PARAM_AFTER_LAST: nl80211_sta_bss_param = 6;
pub const nl80211_sta_bss_param_NL80211_STA_BSS_PARAM_MAX: nl80211_sta_bss_param = 5;
#[doc = " enum nl80211_sta_bss_param - BSS information collected by STA"]
#[doc = ""]
#[doc = " These attribute types are used with %NL80211_STA_INFO_BSS_PARAM"]
#[doc = " when getting information about the bitrate of a station."]
#[doc = ""]
#[doc = " @__NL80211_STA_BSS_PARAM_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_STA_BSS_PARAM_CTS_PROT: whether CTS protection is enabled (flag)"]
#[doc = " @NL80211_STA_BSS_PARAM_SHORT_PREAMBLE:  whether short preamble is enabled"]
#[doc = "\t(flag)"]
#[doc = " @NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME:  whether short slot time is enabled"]
#[doc = "\t(flag)"]
#[doc = " @NL80211_STA_BSS_PARAM_DTIM_PERIOD: DTIM period for beaconing (u8)"]
#[doc = " @NL80211_STA_BSS_PARAM_BEACON_INTERVAL: Beacon interval (u16)"]
#[doc = " @NL80211_STA_BSS_PARAM_MAX: highest sta_bss_param number currently defined"]
#[doc = " @__NL80211_STA_BSS_PARAM_AFTER_LAST: internal use"]
pub type nl80211_sta_bss_param = ::std::os::raw::c_uint;
pub const nl80211_sta_info___NL80211_STA_INFO_INVALID: nl80211_sta_info = 0;
pub const nl80211_sta_info_NL80211_STA_INFO_INACTIVE_TIME: nl80211_sta_info = 1;
pub const nl80211_sta_info_NL80211_STA_INFO_RX_BYTES: nl80211_sta_info = 2;
pub const nl80211_sta_info_NL80211_STA_INFO_TX_BYTES: nl80211_sta_info = 3;
pub const nl80211_sta_info_NL80211_STA_INFO_LLID: nl80211_sta_info = 4;
pub const nl80211_sta_info_NL80211_STA_INFO_PLID: nl80211_sta_info = 5;
pub const nl80211_sta_info_NL80211_STA_INFO_PLINK_STATE: nl80211_sta_info = 6;
pub const nl80211_sta_info_NL80211_STA_INFO_SIGNAL: nl80211_sta_info = 7;
pub const nl80211_sta_info_NL80211_STA_INFO_TX_BITRATE: nl80211_sta_info = 8;
pub const nl80211_sta_info_NL80211_STA_INFO_RX_PACKETS: nl80211_sta_info = 9;
pub const nl80211_sta_info_NL80211_STA_INFO_TX_PACKETS: nl80211_sta_info = 10;
pub const nl80211_sta_info_NL80211_STA_INFO_TX_RETRIES: nl80211_sta_info = 11;
pub const nl80211_sta_info_NL80211_STA_INFO_TX_FAILED: nl80211_sta_info = 12;
pub const nl80211_sta_info_NL80211_STA_INFO_SIGNAL_AVG: nl80211_sta_info = 13;
pub const nl80211_sta_info_NL80211_STA_INFO_RX_BITRATE: nl80211_sta_info = 14;
pub const nl80211_sta_info_NL80211_STA_INFO_BSS_PARAM: nl80211_sta_info = 15;
pub const nl80211_sta_info_NL80211_STA_INFO_CONNECTED_TIME: nl80211_sta_info = 16;
pub const nl80211_sta_info_NL80211_STA_INFO_STA_FLAGS: nl80211_sta_info = 17;
pub const nl80211_sta_info_NL80211_STA_INFO_BEACON_LOSS: nl80211_sta_info = 18;
pub const nl80211_sta_info_NL80211_STA_INFO_T_OFFSET: nl80211_sta_info = 19;
pub const nl80211_sta_info_NL80211_STA_INFO_LOCAL_PM: nl80211_sta_info = 20;
pub const nl80211_sta_info_NL80211_STA_INFO_PEER_PM: nl80211_sta_info = 21;
pub const nl80211_sta_info_NL80211_STA_INFO_NONPEER_PM: nl80211_sta_info = 22;
pub const nl80211_sta_info_NL80211_STA_INFO_RX_BYTES64: nl80211_sta_info = 23;
pub const nl80211_sta_info_NL80211_STA_INFO_TX_BYTES64: nl80211_sta_info = 24;
pub const nl80211_sta_info_NL80211_STA_INFO_CHAIN_SIGNAL: nl80211_sta_info = 25;
pub const nl80211_sta_info_NL80211_STA_INFO_CHAIN_SIGNAL_AVG: nl80211_sta_info = 26;
pub const nl80211_sta_info_NL80211_STA_INFO_EXPECTED_THROUGHPUT: nl80211_sta_info = 27;
pub const nl80211_sta_info_NL80211_STA_INFO_RX_DROP_MISC: nl80211_sta_info = 28;
pub const nl80211_sta_info_NL80211_STA_INFO_BEACON_RX: nl80211_sta_info = 29;
pub const nl80211_sta_info_NL80211_STA_INFO_BEACON_SIGNAL_AVG: nl80211_sta_info = 30;
pub const nl80211_sta_info_NL80211_STA_INFO_TID_STATS: nl80211_sta_info = 31;
pub const nl80211_sta_info_NL80211_STA_INFO_RX_DURATION: nl80211_sta_info = 32;
pub const nl80211_sta_info_NL80211_STA_INFO_PAD: nl80211_sta_info = 33;
pub const nl80211_sta_info_NL80211_STA_INFO_ACK_SIGNAL: nl80211_sta_info = 34;
pub const nl80211_sta_info_NL80211_STA_INFO_ACK_SIGNAL_AVG: nl80211_sta_info = 35;
pub const nl80211_sta_info_NL80211_STA_INFO_RX_MPDUS: nl80211_sta_info = 36;
pub const nl80211_sta_info_NL80211_STA_INFO_FCS_ERROR_COUNT: nl80211_sta_info = 37;
pub const nl80211_sta_info_NL80211_STA_INFO_CONNECTED_TO_GATE: nl80211_sta_info = 38;
pub const nl80211_sta_info_NL80211_STA_INFO_TX_DURATION: nl80211_sta_info = 39;
pub const nl80211_sta_info_NL80211_STA_INFO_AIRTIME_WEIGHT: nl80211_sta_info = 40;
pub const nl80211_sta_info_NL80211_STA_INFO_AIRTIME_LINK_METRIC: nl80211_sta_info = 41;
pub const nl80211_sta_info_NL80211_STA_INFO_ASSOC_AT_BOOTTIME: nl80211_sta_info = 42;
pub const nl80211_sta_info_NL80211_STA_INFO_CONNECTED_TO_AS: nl80211_sta_info = 43;
pub const nl80211_sta_info___NL80211_STA_INFO_AFTER_LAST: nl80211_sta_info = 44;
pub const nl80211_sta_info_NL80211_STA_INFO_MAX: nl80211_sta_info = 43;
#[doc = " enum nl80211_sta_info - station information"]
#[doc = ""]
#[doc = " These attribute types are used with %NL80211_ATTR_STA_INFO"]
#[doc = " when getting information about a station."]
#[doc = ""]
#[doc = " @__NL80211_STA_INFO_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_STA_INFO_INACTIVE_TIME: time since last activity (u32, msecs)"]
#[doc = " @NL80211_STA_INFO_RX_BYTES: total received bytes (MPDU length)"]
#[doc = "\t(u32, from this station)"]
#[doc = " @NL80211_STA_INFO_TX_BYTES: total transmitted bytes (MPDU length)"]
#[doc = "\t(u32, to this station)"]
#[doc = " @NL80211_STA_INFO_RX_BYTES64: total received bytes (MPDU length)"]
#[doc = "\t(u64, from this station)"]
#[doc = " @NL80211_STA_INFO_TX_BYTES64: total transmitted bytes (MPDU length)"]
#[doc = "\t(u64, to this station)"]
#[doc = " @NL80211_STA_INFO_SIGNAL: signal strength of last received PPDU (u8, dBm)"]
#[doc = " @NL80211_STA_INFO_TX_BITRATE: current unicast tx rate, nested attribute"]
#[doc = " \tcontaining info as possible, see &enum nl80211_rate_info"]
#[doc = " @NL80211_STA_INFO_RX_PACKETS: total received packet (MSDUs and MMPDUs)"]
#[doc = "\t(u32, from this station)"]
#[doc = " @NL80211_STA_INFO_TX_PACKETS: total transmitted packets (MSDUs and MMPDUs)"]
#[doc = "\t(u32, to this station)"]
#[doc = " @NL80211_STA_INFO_TX_RETRIES: total retries (MPDUs) (u32, to this station)"]
#[doc = " @NL80211_STA_INFO_TX_FAILED: total failed packets (MPDUs)"]
#[doc = "\t(u32, to this station)"]
#[doc = " @NL80211_STA_INFO_SIGNAL_AVG: signal strength average (u8, dBm)"]
#[doc = " @NL80211_STA_INFO_LLID: the station's mesh LLID"]
#[doc = " @NL80211_STA_INFO_PLID: the station's mesh PLID"]
#[doc = " @NL80211_STA_INFO_PLINK_STATE: peer link state for the station"]
#[doc = "\t(see %enum nl80211_plink_state)"]
#[doc = " @NL80211_STA_INFO_RX_BITRATE: last unicast data frame rx rate, nested"]
#[doc = "\tattribute, like NL80211_STA_INFO_TX_BITRATE."]
#[doc = " @NL80211_STA_INFO_BSS_PARAM: current station's view of BSS, nested attribute"]
#[doc = "     containing info as possible, see &enum nl80211_sta_bss_param"]
#[doc = " @NL80211_STA_INFO_CONNECTED_TIME: time since the station is last connected"]
#[doc = " @NL80211_STA_INFO_STA_FLAGS: Contains a struct nl80211_sta_flag_update."]
#[doc = " @NL80211_STA_INFO_BEACON_LOSS: count of times beacon loss was detected (u32)"]
#[doc = " @NL80211_STA_INFO_T_OFFSET: timing offset with respect to this STA (s64)"]
#[doc = " @NL80211_STA_INFO_LOCAL_PM: local mesh STA link-specific power mode"]
#[doc = " @NL80211_STA_INFO_PEER_PM: peer mesh STA link-specific power mode"]
#[doc = " @NL80211_STA_INFO_NONPEER_PM: neighbor mesh STA power save mode towards"]
#[doc = "\tnon-peer STA"]
#[doc = " @NL80211_STA_INFO_CHAIN_SIGNAL: per-chain signal strength of last PPDU"]
#[doc = "\tContains a nested array of signal strength attributes (u8, dBm)"]
#[doc = " @NL80211_STA_INFO_CHAIN_SIGNAL_AVG: per-chain signal strength average"]
#[doc = "\tSame format as NL80211_STA_INFO_CHAIN_SIGNAL."]
#[doc = " @NL80211_STA_EXPECTED_THROUGHPUT: expected throughput considering also the"]
#[doc = "\t802.11 header (u32, kbps)"]
#[doc = " @NL80211_STA_INFO_RX_DROP_MISC: RX packets dropped for unspecified reasons"]
#[doc = "\t(u64)"]
#[doc = " @NL80211_STA_INFO_BEACON_RX: number of beacons received from this peer (u64)"]
#[doc = " @NL80211_STA_INFO_BEACON_SIGNAL_AVG: signal strength average"]
#[doc = "\tfor beacons only (u8, dBm)"]
#[doc = " @NL80211_STA_INFO_TID_STATS: per-TID statistics (see &enum nl80211_tid_stats)"]
#[doc = "\tThis is a nested attribute where each the inner attribute number is the"]
#[doc = "\tTID+1 and the special TID 16 (i.e. value 17) is used for non-QoS frames;"]
#[doc = "\teach one of those is again nested with &enum nl80211_tid_stats"]
#[doc = "\tattributes carrying the actual values."]
#[doc = " @NL80211_STA_INFO_RX_DURATION: aggregate PPDU duration for all frames"]
#[doc = "\treceived from the station (u64, usec)"]
#[doc = " @NL80211_STA_INFO_PAD: attribute used for padding for 64-bit alignment"]
#[doc = " @NL80211_STA_INFO_ACK_SIGNAL: signal strength of the last ACK frame(u8, dBm)"]
#[doc = " @NL80211_STA_INFO_ACK_SIGNAL_AVG: avg signal strength of ACK frames (s8, dBm)"]
#[doc = " @NL80211_STA_INFO_RX_MPDUS: total number of received packets (MPDUs)"]
#[doc = "\t(u32, from this station)"]
#[doc = " @NL80211_STA_INFO_FCS_ERROR_COUNT: total number of packets (MPDUs) received"]
#[doc = "\twith an FCS error (u32, from this station). This count may not include"]
#[doc = "\tsome packets with an FCS error due to TA corruption. Hence this counter"]
#[doc = "\tmight not be fully accurate."]
#[doc = " @NL80211_STA_INFO_CONNECTED_TO_GATE: set to true if STA has a path to a"]
#[doc = "\tmesh gate (u8, 0 or 1)"]
#[doc = " @NL80211_STA_INFO_TX_DURATION: aggregate PPDU duration for all frames"]
#[doc = "\tsent to the station (u64, usec)"]
#[doc = " @NL80211_STA_INFO_AIRTIME_WEIGHT: current airtime weight for station (u16)"]
#[doc = " @NL80211_STA_INFO_AIRTIME_LINK_METRIC: airtime link metric for mesh station"]
#[doc = " @NL80211_STA_INFO_ASSOC_AT_BOOTTIME: Timestamp (CLOCK_BOOTTIME, nanoseconds)"]
#[doc = "\tof STA's association"]
#[doc = " @NL80211_STA_INFO_CONNECTED_TO_AS: set to true if STA has a path to a"]
#[doc = "\tauthentication server (u8, 0 or 1)"]
#[doc = " @__NL80211_STA_INFO_AFTER_LAST: internal"]
#[doc = " @NL80211_STA_INFO_MAX: highest possible station info attribute"]
pub type nl80211_sta_info = ::std::os::raw::c_uint;
pub const nl80211_tid_stats___NL80211_TID_STATS_INVALID: nl80211_tid_stats = 0;
pub const nl80211_tid_stats_NL80211_TID_STATS_RX_MSDU: nl80211_tid_stats = 1;
pub const nl80211_tid_stats_NL80211_TID_STATS_TX_MSDU: nl80211_tid_stats = 2;
pub const nl80211_tid_stats_NL80211_TID_STATS_TX_MSDU_RETRIES: nl80211_tid_stats = 3;
pub const nl80211_tid_stats_NL80211_TID_STATS_TX_MSDU_FAILED: nl80211_tid_stats = 4;
pub const nl80211_tid_stats_NL80211_TID_STATS_PAD: nl80211_tid_stats = 5;
pub const nl80211_tid_stats_NL80211_TID_STATS_TXQ_STATS: nl80211_tid_stats = 6;
pub const nl80211_tid_stats_NUM_NL80211_TID_STATS: nl80211_tid_stats = 7;
pub const nl80211_tid_stats_NL80211_TID_STATS_MAX: nl80211_tid_stats = 6;
#[doc = " enum nl80211_tid_stats - per TID statistics attributes"]
#[doc = " @__NL80211_TID_STATS_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_TID_STATS_RX_MSDU: number of MSDUs received (u64)"]
#[doc = " @NL80211_TID_STATS_TX_MSDU: number of MSDUs transmitted (or"]
#[doc = "\tattempted to transmit; u64)"]
#[doc = " @NL80211_TID_STATS_TX_MSDU_RETRIES: number of retries for"]
#[doc = "\ttransmitted MSDUs (not counting the first attempt; u64)"]
#[doc = " @NL80211_TID_STATS_TX_MSDU_FAILED: number of failed transmitted"]
#[doc = "\tMSDUs (u64)"]
#[doc = " @NL80211_TID_STATS_PAD: attribute used for padding for 64-bit alignment"]
#[doc = " @NL80211_TID_STATS_TXQ_STATS: TXQ stats (nested attribute)"]
#[doc = " @NUM_NL80211_TID_STATS: number of attributes here"]
#[doc = " @NL80211_TID_STATS_MAX: highest numbered attribute here"]
pub type nl80211_tid_stats = ::std::os::raw::c_uint;
pub const nl80211_txq_stats___NL80211_TXQ_STATS_INVALID: nl80211_txq_stats = 0;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_BACKLOG_BYTES: nl80211_txq_stats = 1;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_BACKLOG_PACKETS: nl80211_txq_stats = 2;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_FLOWS: nl80211_txq_stats = 3;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_DROPS: nl80211_txq_stats = 4;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_ECN_MARKS: nl80211_txq_stats = 5;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_OVERLIMIT: nl80211_txq_stats = 6;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_OVERMEMORY: nl80211_txq_stats = 7;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_COLLISIONS: nl80211_txq_stats = 8;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_TX_BYTES: nl80211_txq_stats = 9;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_TX_PACKETS: nl80211_txq_stats = 10;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_MAX_FLOWS: nl80211_txq_stats = 11;
pub const nl80211_txq_stats_NUM_NL80211_TXQ_STATS: nl80211_txq_stats = 12;
pub const nl80211_txq_stats_NL80211_TXQ_STATS_MAX: nl80211_txq_stats = 11;
#[doc = " enum nl80211_txq_stats - per TXQ statistics attributes"]
#[doc = " @__NL80211_TXQ_STATS_INVALID: attribute number 0 is reserved"]
#[doc = " @NUM_NL80211_TXQ_STATS: number of attributes here"]
#[doc = " @NL80211_TXQ_STATS_BACKLOG_BYTES: number of bytes currently backlogged"]
#[doc = " @NL80211_TXQ_STATS_BACKLOG_PACKETS: number of packets currently"]
#[doc = "      backlogged"]
#[doc = " @NL80211_TXQ_STATS_FLOWS: total number of new flows seen"]
#[doc = " @NL80211_TXQ_STATS_DROPS: total number of packet drops"]
#[doc = " @NL80211_TXQ_STATS_ECN_MARKS: total number of packet ECN marks"]
#[doc = " @NL80211_TXQ_STATS_OVERLIMIT: number of drops due to queue space overflow"]
#[doc = " @NL80211_TXQ_STATS_OVERMEMORY: number of drops due to memory limit overflow"]
#[doc = "      (only for per-phy stats)"]
#[doc = " @NL80211_TXQ_STATS_COLLISIONS: number of hash collisions"]
#[doc = " @NL80211_TXQ_STATS_TX_BYTES: total number of bytes dequeued from TXQ"]
#[doc = " @NL80211_TXQ_STATS_TX_PACKETS: total number of packets dequeued from TXQ"]
#[doc = " @NL80211_TXQ_STATS_MAX_FLOWS: number of flow buckets for PHY"]
#[doc = " @NL80211_TXQ_STATS_MAX: highest numbered attribute here"]
pub type nl80211_txq_stats = ::std::os::raw::c_uint;
pub const nl80211_mpath_flags_NL80211_MPATH_FLAG_ACTIVE: nl80211_mpath_flags = 1;
pub const nl80211_mpath_flags_NL80211_MPATH_FLAG_RESOLVING: nl80211_mpath_flags = 2;
pub const nl80211_mpath_flags_NL80211_MPATH_FLAG_SN_VALID: nl80211_mpath_flags = 4;
pub const nl80211_mpath_flags_NL80211_MPATH_FLAG_FIXED: nl80211_mpath_flags = 8;
pub const nl80211_mpath_flags_NL80211_MPATH_FLAG_RESOLVED: nl80211_mpath_flags = 16;
#[doc = " enum nl80211_mpath_flags - nl80211 mesh path flags"]
#[doc = ""]
#[doc = " @NL80211_MPATH_FLAG_ACTIVE: the mesh path is active"]
#[doc = " @NL80211_MPATH_FLAG_RESOLVING: the mesh path discovery process is running"]
#[doc = " @NL80211_MPATH_FLAG_SN_VALID: the mesh path contains a valid SN"]
#[doc = " @NL80211_MPATH_FLAG_FIXED: the mesh path has been manually set"]
#[doc = " @NL80211_MPATH_FLAG_RESOLVED: the mesh path discovery process succeeded"]
pub type nl80211_mpath_flags = ::std::os::raw::c_uint;
pub const nl80211_mpath_info___NL80211_MPATH_INFO_INVALID: nl80211_mpath_info = 0;
pub const nl80211_mpath_info_NL80211_MPATH_INFO_FRAME_QLEN: nl80211_mpath_info = 1;
pub const nl80211_mpath_info_NL80211_MPATH_INFO_SN: nl80211_mpath_info = 2;
pub const nl80211_mpath_info_NL80211_MPATH_INFO_METRIC: nl80211_mpath_info = 3;
pub const nl80211_mpath_info_NL80211_MPATH_INFO_EXPTIME: nl80211_mpath_info = 4;
pub const nl80211_mpath_info_NL80211_MPATH_INFO_FLAGS: nl80211_mpath_info = 5;
pub const nl80211_mpath_info_NL80211_MPATH_INFO_DISCOVERY_TIMEOUT: nl80211_mpath_info = 6;
pub const nl80211_mpath_info_NL80211_MPATH_INFO_DISCOVERY_RETRIES: nl80211_mpath_info = 7;
pub const nl80211_mpath_info_NL80211_MPATH_INFO_HOP_COUNT: nl80211_mpath_info = 8;
pub const nl80211_mpath_info_NL80211_MPATH_INFO_PATH_CHANGE: nl80211_mpath_info = 9;
pub const nl80211_mpath_info___NL80211_MPATH_INFO_AFTER_LAST: nl80211_mpath_info = 10;
pub const nl80211_mpath_info_NL80211_MPATH_INFO_MAX: nl80211_mpath_info = 9;
#[doc = " enum nl80211_mpath_info - mesh path information"]
#[doc = ""]
#[doc = " These attribute types are used with %NL80211_ATTR_MPATH_INFO when getting"]
#[doc = " information about a mesh path."]
#[doc = ""]
#[doc = " @__NL80211_MPATH_INFO_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_MPATH_INFO_FRAME_QLEN: number of queued frames for this destination"]
#[doc = " @NL80211_MPATH_INFO_SN: destination sequence number"]
#[doc = " @NL80211_MPATH_INFO_METRIC: metric (cost) of this mesh path"]
#[doc = " @NL80211_MPATH_INFO_EXPTIME: expiration time for the path, in msec from now"]
#[doc = " @NL80211_MPATH_INFO_FLAGS: mesh path flags, enumerated in"]
#[doc = " \t&enum nl80211_mpath_flags;"]
#[doc = " @NL80211_MPATH_INFO_DISCOVERY_TIMEOUT: total path discovery timeout, in msec"]
#[doc = " @NL80211_MPATH_INFO_DISCOVERY_RETRIES: mesh path discovery retries"]
#[doc = " @NL80211_MPATH_INFO_HOP_COUNT: hop count to destination"]
#[doc = " @NL80211_MPATH_INFO_PATH_CHANGE: total number of path changes to destination"]
#[doc = " @NL80211_MPATH_INFO_MAX: highest mesh path information attribute number"]
#[doc = "\tcurrently defined"]
#[doc = " @__NL80211_MPATH_INFO_AFTER_LAST: internal use"]
pub type nl80211_mpath_info = ::std::os::raw::c_uint;
pub const nl80211_band_iftype_attr___NL80211_BAND_IFTYPE_ATTR_INVALID: nl80211_band_iftype_attr = 0;
pub const nl80211_band_iftype_attr_NL80211_BAND_IFTYPE_ATTR_IFTYPES: nl80211_band_iftype_attr = 1;
pub const nl80211_band_iftype_attr_NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC: nl80211_band_iftype_attr =
    2;
pub const nl80211_band_iftype_attr_NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY: nl80211_band_iftype_attr =
    3;
pub const nl80211_band_iftype_attr_NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET:
    nl80211_band_iftype_attr = 4;
pub const nl80211_band_iftype_attr_NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE: nl80211_band_iftype_attr =
    5;
pub const nl80211_band_iftype_attr_NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA: nl80211_band_iftype_attr =
    6;
pub const nl80211_band_iftype_attr___NL80211_BAND_IFTYPE_ATTR_AFTER_LAST: nl80211_band_iftype_attr =
    7;
pub const nl80211_band_iftype_attr_NL80211_BAND_IFTYPE_ATTR_MAX: nl80211_band_iftype_attr = 6;
#[doc = " enum nl80211_band_iftype_attr - Interface type data attributes"]
#[doc = ""]
#[doc = " @__NL80211_BAND_IFTYPE_ATTR_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_BAND_IFTYPE_ATTR_IFTYPES: nested attribute containing a flag attribute"]
#[doc = "     for each interface type that supports the band data"]
#[doc = " @NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC: HE MAC capabilities as in HE"]
#[doc = "     capabilities IE"]
#[doc = " @NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY: HE PHY capabilities as in HE"]
#[doc = "     capabilities IE"]
#[doc = " @NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET: HE supported NSS/MCS as in HE"]
#[doc = "     capabilities IE"]
#[doc = " @NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE: HE PPE thresholds information as"]
#[doc = "     defined in HE capabilities IE"]
#[doc = " @NL80211_BAND_IFTYPE_ATTR_MAX: highest band HE capability attribute currently"]
#[doc = "     defined"]
#[doc = " @NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA: HE 6GHz band capabilities (__le16),"]
#[doc = "\tgiven for all 6 GHz band channels"]
#[doc = " @__NL80211_BAND_IFTYPE_ATTR_AFTER_LAST: internal use"]
pub type nl80211_band_iftype_attr = ::std::os::raw::c_uint;
pub const nl80211_band_attr___NL80211_BAND_ATTR_INVALID: nl80211_band_attr = 0;
pub const nl80211_band_attr_NL80211_BAND_ATTR_FREQS: nl80211_band_attr = 1;
pub const nl80211_band_attr_NL80211_BAND_ATTR_RATES: nl80211_band_attr = 2;
pub const nl80211_band_attr_NL80211_BAND_ATTR_HT_MCS_SET: nl80211_band_attr = 3;
pub const nl80211_band_attr_NL80211_BAND_ATTR_HT_CAPA: nl80211_band_attr = 4;
pub const nl80211_band_attr_NL80211_BAND_ATTR_HT_AMPDU_FACTOR: nl80211_band_attr = 5;
pub const nl80211_band_attr_NL80211_BAND_ATTR_HT_AMPDU_DENSITY: nl80211_band_attr = 6;
pub const nl80211_band_attr_NL80211_BAND_ATTR_VHT_MCS_SET: nl80211_band_attr = 7;
pub const nl80211_band_attr_NL80211_BAND_ATTR_VHT_CAPA: nl80211_band_attr = 8;
pub const nl80211_band_attr_NL80211_BAND_ATTR_IFTYPE_DATA: nl80211_band_attr = 9;
pub const nl80211_band_attr_NL80211_BAND_ATTR_EDMG_CHANNELS: nl80211_band_attr = 10;
pub const nl80211_band_attr_NL80211_BAND_ATTR_EDMG_BW_CONFIG: nl80211_band_attr = 11;
pub const nl80211_band_attr___NL80211_BAND_ATTR_AFTER_LAST: nl80211_band_attr = 12;
pub const nl80211_band_attr_NL80211_BAND_ATTR_MAX: nl80211_band_attr = 11;
#[doc = " enum nl80211_band_attr - band attributes"]
#[doc = " @__NL80211_BAND_ATTR_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_BAND_ATTR_FREQS: supported frequencies in this band,"]
#[doc = "\tan array of nested frequency attributes"]
#[doc = " @NL80211_BAND_ATTR_RATES: supported bitrates in this band,"]
#[doc = "\tan array of nested bitrate attributes"]
#[doc = " @NL80211_BAND_ATTR_HT_MCS_SET: 16-byte attribute containing the MCS set as"]
#[doc = "\tdefined in 802.11n"]
#[doc = " @NL80211_BAND_ATTR_HT_CAPA: HT capabilities, as in the HT information IE"]
#[doc = " @NL80211_BAND_ATTR_HT_AMPDU_FACTOR: A-MPDU factor, as in 11n"]
#[doc = " @NL80211_BAND_ATTR_HT_AMPDU_DENSITY: A-MPDU density, as in 11n"]
#[doc = " @NL80211_BAND_ATTR_VHT_MCS_SET: 32-byte attribute containing the MCS set as"]
#[doc = "\tdefined in 802.11ac"]
#[doc = " @NL80211_BAND_ATTR_VHT_CAPA: VHT capabilities, as in the HT information IE"]
#[doc = " @NL80211_BAND_ATTR_IFTYPE_DATA: nested array attribute, with each entry using"]
#[doc = "\tattributes from &enum nl80211_band_iftype_attr"]
#[doc = " @NL80211_BAND_ATTR_EDMG_CHANNELS: bitmap that indicates the 2.16 GHz"]
#[doc = "\tchannel(s) that are allowed to be used for EDMG transmissions."]
#[doc = "\tDefined by IEEE P802.11ay/D4.0 section 9.4.2.251."]
#[doc = " @NL80211_BAND_ATTR_EDMG_BW_CONFIG: Channel BW Configuration subfield encodes"]
#[doc = "\tthe allowed channel bandwidth configurations."]
#[doc = "\tDefined by IEEE P802.11ay/D4.0 section 9.4.2.251, Table 13."]
#[doc = " @NL80211_BAND_ATTR_MAX: highest band attribute currently defined"]
#[doc = " @__NL80211_BAND_ATTR_AFTER_LAST: internal use"]
pub type nl80211_band_attr = ::std::os::raw::c_uint;
pub const nl80211_wmm_rule___NL80211_WMMR_INVALID: nl80211_wmm_rule = 0;
pub const nl80211_wmm_rule_NL80211_WMMR_CW_MIN: nl80211_wmm_rule = 1;
pub const nl80211_wmm_rule_NL80211_WMMR_CW_MAX: nl80211_wmm_rule = 2;
pub const nl80211_wmm_rule_NL80211_WMMR_AIFSN: nl80211_wmm_rule = 3;
pub const nl80211_wmm_rule_NL80211_WMMR_TXOP: nl80211_wmm_rule = 4;
pub const nl80211_wmm_rule___NL80211_WMMR_LAST: nl80211_wmm_rule = 5;
pub const nl80211_wmm_rule_NL80211_WMMR_MAX: nl80211_wmm_rule = 4;
#[doc = " enum nl80211_wmm_rule - regulatory wmm rule"]
#[doc = ""]
#[doc = " @__NL80211_WMMR_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_WMMR_CW_MIN: Minimum contention window slot."]
#[doc = " @NL80211_WMMR_CW_MAX: Maximum contention window slot."]
#[doc = " @NL80211_WMMR_AIFSN: Arbitration Inter Frame Space."]
#[doc = " @NL80211_WMMR_TXOP: Maximum allowed tx operation time."]
#[doc = " @nl80211_WMMR_MAX: highest possible wmm rule."]
#[doc = " @__NL80211_WMMR_LAST: Internal use."]
pub type nl80211_wmm_rule = ::std::os::raw::c_uint;
pub const nl80211_frequency_attr___NL80211_FREQUENCY_ATTR_INVALID: nl80211_frequency_attr = 0;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_FREQ: nl80211_frequency_attr = 1;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_DISABLED: nl80211_frequency_attr = 2;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_NO_IR: nl80211_frequency_attr = 3;
pub const nl80211_frequency_attr___NL80211_FREQUENCY_ATTR_NO_IBSS: nl80211_frequency_attr = 4;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_RADAR: nl80211_frequency_attr = 5;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_MAX_TX_POWER: nl80211_frequency_attr = 6;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_DFS_STATE: nl80211_frequency_attr = 7;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_DFS_TIME: nl80211_frequency_attr = 8;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_NO_HT40_MINUS: nl80211_frequency_attr = 9;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_NO_HT40_PLUS: nl80211_frequency_attr = 10;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_NO_80MHZ: nl80211_frequency_attr = 11;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_NO_160MHZ: nl80211_frequency_attr = 12;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_DFS_CAC_TIME: nl80211_frequency_attr = 13;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_INDOOR_ONLY: nl80211_frequency_attr = 14;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_IR_CONCURRENT: nl80211_frequency_attr = 15;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_NO_20MHZ: nl80211_frequency_attr = 16;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_NO_10MHZ: nl80211_frequency_attr = 17;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_WMM: nl80211_frequency_attr = 18;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_NO_HE: nl80211_frequency_attr = 19;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_OFFSET: nl80211_frequency_attr = 20;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_1MHZ: nl80211_frequency_attr = 21;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_2MHZ: nl80211_frequency_attr = 22;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_4MHZ: nl80211_frequency_attr = 23;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_8MHZ: nl80211_frequency_attr = 24;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_16MHZ: nl80211_frequency_attr = 25;
pub const nl80211_frequency_attr___NL80211_FREQUENCY_ATTR_AFTER_LAST: nl80211_frequency_attr = 26;
pub const nl80211_frequency_attr_NL80211_FREQUENCY_ATTR_MAX: nl80211_frequency_attr = 25;
#[doc = " enum nl80211_frequency_attr - frequency attributes"]
#[doc = " @__NL80211_FREQUENCY_ATTR_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_FREQUENCY_ATTR_FREQ: Frequency in MHz"]
#[doc = " @NL80211_FREQUENCY_ATTR_DISABLED: Channel is disabled in current"]
#[doc = "\tregulatory domain."]
#[doc = " @NL80211_FREQUENCY_ATTR_NO_IR: no mechanisms that initiate radiation"]
#[doc = " \tare permitted on this channel, this includes sending probe"]
#[doc = " \trequests, or modes of operation that require beaconing."]
#[doc = " @NL80211_FREQUENCY_ATTR_RADAR: Radar detection is mandatory"]
#[doc = "\ton this channel in current regulatory domain."]
#[doc = " @NL80211_FREQUENCY_ATTR_MAX_TX_POWER: Maximum transmission power in mBm"]
#[doc = "\t(100 * dBm)."]
#[doc = " @NL80211_FREQUENCY_ATTR_DFS_STATE: current state for DFS"]
#[doc = "\t(enum nl80211_dfs_state)"]
#[doc = " @NL80211_FREQUENCY_ATTR_DFS_TIME: time in miliseconds for how long"]
#[doc = "\tthis channel is in this DFS state."]
#[doc = " @NL80211_FREQUENCY_ATTR_NO_HT40_MINUS: HT40- isn't possible with this"]
#[doc = "\tchannel as the control channel"]
#[doc = " @NL80211_FREQUENCY_ATTR_NO_HT40_PLUS: HT40+ isn't possible with this"]
#[doc = "\tchannel as the control channel"]
#[doc = " @NL80211_FREQUENCY_ATTR_NO_80MHZ: any 80 MHz channel using this channel"]
#[doc = "\tas the primary or any of the secondary channels isn't possible,"]
#[doc = "\tthis includes 80+80 channels"]
#[doc = " @NL80211_FREQUENCY_ATTR_NO_160MHZ: any 160 MHz (but not 80+80) channel"]
#[doc = "\tusing this channel as the primary or any of the secondary channels"]
#[doc = "\tisn't possible"]
#[doc = " @NL80211_FREQUENCY_ATTR_DFS_CAC_TIME: DFS CAC time in milliseconds."]
#[doc = " @NL80211_FREQUENCY_ATTR_INDOOR_ONLY: Only indoor use is permitted on this"]
#[doc = "\tchannel. A channel that has the INDOOR_ONLY attribute can only be"]
#[doc = "\tused when there is a clear assessment that the device is operating in"]
#[doc = "\tan indoor surroundings, i.e., it is connected to AC power (and not"]
#[doc = "\tthrough portable DC inverters) or is under the control of a master"]
#[doc = "\tthat is acting as an AP and is connected to AC power."]
#[doc = " @NL80211_FREQUENCY_ATTR_IR_CONCURRENT: IR operation is allowed on this"]
#[doc = "\tchannel if it's connected concurrently to a BSS on the same channel on"]
#[doc = "\tthe 2 GHz band or to a channel in the same UNII band (on the 5 GHz"]
#[doc = "\tband), and IEEE80211_CHAN_RADAR is not set. Instantiating a GO or TDLS"]
#[doc = "\toff-channel on a channel that has the IR_CONCURRENT attribute set can be"]
#[doc = "\tdone when there is a clear assessment that the device is operating under"]
#[doc = "\tthe guidance of an authorized master, i.e., setting up a GO or TDLS"]
#[doc = "\toff-channel while the device is also connected to an AP with DFS and"]
#[doc = "\tradar detection on the UNII band (it is up to user-space, i.e.,"]
#[doc = "\twpa_supplicant to perform the required verifications). Using this"]
#[doc = "\tattribute for IR is disallowed for master interfaces (IBSS, AP)."]
#[doc = " @NL80211_FREQUENCY_ATTR_NO_20MHZ: 20 MHz operation is not allowed"]
#[doc = "\ton this channel in current regulatory domain."]
#[doc = " @NL80211_FREQUENCY_ATTR_NO_10MHZ: 10 MHz operation is not allowed"]
#[doc = "\ton this channel in current regulatory domain."]
#[doc = " @NL80211_FREQUENCY_ATTR_WMM: this channel has wmm limitations."]
#[doc = "\tThis is a nested attribute that contains the wmm limitation per AC."]
#[doc = "\t(see &enum nl80211_wmm_rule)"]
#[doc = " @NL80211_FREQUENCY_ATTR_NO_HE: HE operation is not allowed on this channel"]
#[doc = "\tin current regulatory domain."]
#[doc = " @NL80211_FREQUENCY_ATTR_OFFSET: frequency offset in KHz"]
#[doc = " @NL80211_FREQUENCY_ATTR_1MHZ: 1 MHz operation is allowed"]
#[doc = "\ton this channel in current regulatory domain."]
#[doc = " @NL80211_FREQUENCY_ATTR_2MHZ: 2 MHz operation is allowed"]
#[doc = "\ton this channel in current regulatory domain."]
#[doc = " @NL80211_FREQUENCY_ATTR_4MHZ: 4 MHz operation is allowed"]
#[doc = "\ton this channel in current regulatory domain."]
#[doc = " @NL80211_FREQUENCY_ATTR_8MHZ: 8 MHz operation is allowed"]
#[doc = "\ton this channel in current regulatory domain."]
#[doc = " @NL80211_FREQUENCY_ATTR_16MHZ: 16 MHz operation is allowed"]
#[doc = "\ton this channel in current regulatory domain."]
#[doc = " @NL80211_FREQUENCY_ATTR_MAX: highest frequency attribute number"]
#[doc = "\tcurrently defined"]
#[doc = " @__NL80211_FREQUENCY_ATTR_AFTER_LAST: internal use"]
#[doc = ""]
#[doc = " See https://apps.fcc.gov/eas/comments/GetPublishedDocument.html?id=327&tn=528122"]
#[doc = " for more information on the FCC description of the relaxations allowed"]
#[doc = " by NL80211_FREQUENCY_ATTR_INDOOR_ONLY and"]
#[doc = " NL80211_FREQUENCY_ATTR_IR_CONCURRENT."]
pub type nl80211_frequency_attr = ::std::os::raw::c_uint;
pub const nl80211_bitrate_attr___NL80211_BITRATE_ATTR_INVALID: nl80211_bitrate_attr = 0;
pub const nl80211_bitrate_attr_NL80211_BITRATE_ATTR_RATE: nl80211_bitrate_attr = 1;
pub const nl80211_bitrate_attr_NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE: nl80211_bitrate_attr = 2;
pub const nl80211_bitrate_attr___NL80211_BITRATE_ATTR_AFTER_LAST: nl80211_bitrate_attr = 3;
pub const nl80211_bitrate_attr_NL80211_BITRATE_ATTR_MAX: nl80211_bitrate_attr = 2;
#[doc = " enum nl80211_bitrate_attr - bitrate attributes"]
#[doc = " @__NL80211_BITRATE_ATTR_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_BITRATE_ATTR_RATE: Bitrate in units of 100 kbps"]
#[doc = " @NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE: Short preamble supported"]
#[doc = "\tin 2.4 GHz band."]
#[doc = " @NL80211_BITRATE_ATTR_MAX: highest bitrate attribute number"]
#[doc = "\tcurrently defined"]
#[doc = " @__NL80211_BITRATE_ATTR_AFTER_LAST: internal use"]
pub type nl80211_bitrate_attr = ::std::os::raw::c_uint;
pub const nl80211_reg_initiator_NL80211_REGDOM_SET_BY_CORE: nl80211_reg_initiator = 0;
pub const nl80211_reg_initiator_NL80211_REGDOM_SET_BY_USER: nl80211_reg_initiator = 1;
pub const nl80211_reg_initiator_NL80211_REGDOM_SET_BY_DRIVER: nl80211_reg_initiator = 2;
pub const nl80211_reg_initiator_NL80211_REGDOM_SET_BY_COUNTRY_IE: nl80211_reg_initiator = 3;
#[doc = " enum nl80211_initiator - Indicates the initiator of a reg domain request"]
#[doc = " @NL80211_REGDOM_SET_BY_CORE: Core queried CRDA for a dynamic world"]
#[doc = " \tregulatory domain."]
#[doc = " @NL80211_REGDOM_SET_BY_USER: User asked the wireless core to set the"]
#[doc = " \tregulatory domain."]
#[doc = " @NL80211_REGDOM_SET_BY_DRIVER: a wireless drivers has hinted to the"]
#[doc = " \twireless core it thinks its knows the regulatory domain we should be in."]
#[doc = " @NL80211_REGDOM_SET_BY_COUNTRY_IE: the wireless core has received an"]
#[doc = " \t802.11 country information element with regulatory information it"]
#[doc = " \tthinks we should consider. cfg80211 only processes the country"]
#[doc = "\tcode from the IE, and relies on the regulatory domain information"]
#[doc = "\tstructure passed by userspace (CRDA) from our wireless-regdb."]
#[doc = "\tIf a channel is enabled but the country code indicates it should"]
#[doc = "\tbe disabled we disable the channel and re-enable it upon disassociation."]
pub type nl80211_reg_initiator = ::std::os::raw::c_uint;
pub const nl80211_reg_type_NL80211_REGDOM_TYPE_COUNTRY: nl80211_reg_type = 0;
pub const nl80211_reg_type_NL80211_REGDOM_TYPE_WORLD: nl80211_reg_type = 1;
pub const nl80211_reg_type_NL80211_REGDOM_TYPE_CUSTOM_WORLD: nl80211_reg_type = 2;
pub const nl80211_reg_type_NL80211_REGDOM_TYPE_INTERSECTION: nl80211_reg_type = 3;
#[doc = " enum nl80211_reg_type - specifies the type of regulatory domain"]
#[doc = " @NL80211_REGDOM_TYPE_COUNTRY: the regulatory domain set is one that pertains"]
#[doc = "\tto a specific country. When this is set you can count on the"]
#[doc = "\tISO / IEC 3166 alpha2 country code being valid."]
#[doc = " @NL80211_REGDOM_TYPE_WORLD: the regulatory set domain is the world regulatory"]
#[doc = " \tdomain."]
#[doc = " @NL80211_REGDOM_TYPE_CUSTOM_WORLD: the regulatory domain set is a custom"]
#[doc = " \tdriver specific world regulatory domain. These do not apply system-wide"]
#[doc = " \tand are only applicable to the individual devices which have requested"]
#[doc = " \tthem to be applied."]
#[doc = " @NL80211_REGDOM_TYPE_INTERSECTION: the regulatory domain set is the product"]
#[doc = "\tof an intersection between two regulatory domains -- the previously"]
#[doc = "\tset regulatory domain on the system and the last accepted regulatory"]
#[doc = "\tdomain request to be processed."]
pub type nl80211_reg_type = ::std::os::raw::c_uint;
pub const nl80211_reg_rule_attr___NL80211_REG_RULE_ATTR_INVALID: nl80211_reg_rule_attr = 0;
pub const nl80211_reg_rule_attr_NL80211_ATTR_REG_RULE_FLAGS: nl80211_reg_rule_attr = 1;
pub const nl80211_reg_rule_attr_NL80211_ATTR_FREQ_RANGE_START: nl80211_reg_rule_attr = 2;
pub const nl80211_reg_rule_attr_NL80211_ATTR_FREQ_RANGE_END: nl80211_reg_rule_attr = 3;
pub const nl80211_reg_rule_attr_NL80211_ATTR_FREQ_RANGE_MAX_BW: nl80211_reg_rule_attr = 4;
pub const nl80211_reg_rule_attr_NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN: nl80211_reg_rule_attr = 5;
pub const nl80211_reg_rule_attr_NL80211_ATTR_POWER_RULE_MAX_EIRP: nl80211_reg_rule_attr = 6;
pub const nl80211_reg_rule_attr_NL80211_ATTR_DFS_CAC_TIME: nl80211_reg_rule_attr = 7;
pub const nl80211_reg_rule_attr___NL80211_REG_RULE_ATTR_AFTER_LAST: nl80211_reg_rule_attr = 8;
pub const nl80211_reg_rule_attr_NL80211_REG_RULE_ATTR_MAX: nl80211_reg_rule_attr = 7;
#[doc = " enum nl80211_reg_rule_attr - regulatory rule attributes"]
#[doc = " @__NL80211_REG_RULE_ATTR_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_ATTR_REG_RULE_FLAGS: a set of flags which specify additional"]
#[doc = " \tconsiderations for a given frequency range. These are the"]
#[doc = " \t&enum nl80211_reg_rule_flags."]
#[doc = " @NL80211_ATTR_FREQ_RANGE_START: starting frequencry for the regulatory"]
#[doc = " \trule in KHz. This is not a center of frequency but an actual regulatory"]
#[doc = " \tband edge."]
#[doc = " @NL80211_ATTR_FREQ_RANGE_END: ending frequency for the regulatory rule"]
#[doc = " \tin KHz. This is not a center a frequency but an actual regulatory"]
#[doc = " \tband edge."]
#[doc = " @NL80211_ATTR_FREQ_RANGE_MAX_BW: maximum allowed bandwidth for this"]
#[doc = "\tfrequency range, in KHz."]
#[doc = " @NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN: the maximum allowed antenna gain"]
#[doc = " \tfor a given frequency range. The value is in mBi (100 * dBi)."]
#[doc = " \tIf you don't have one then don't send this."]
#[doc = " @NL80211_ATTR_POWER_RULE_MAX_EIRP: the maximum allowed EIRP for"]
#[doc = " \ta given frequency range. The value is in mBm (100 * dBm)."]
#[doc = " @NL80211_ATTR_DFS_CAC_TIME: DFS CAC time in milliseconds."]
#[doc = "\tIf not present or 0 default CAC time will be used."]
#[doc = " @NL80211_REG_RULE_ATTR_MAX: highest regulatory rule attribute number"]
#[doc = "\tcurrently defined"]
#[doc = " @__NL80211_REG_RULE_ATTR_AFTER_LAST: internal use"]
pub type nl80211_reg_rule_attr = ::std::os::raw::c_uint;
pub const nl80211_sched_scan_match_attr___NL80211_SCHED_SCAN_MATCH_ATTR_INVALID:
    nl80211_sched_scan_match_attr = 0;
pub const nl80211_sched_scan_match_attr_NL80211_SCHED_SCAN_MATCH_ATTR_SSID:
    nl80211_sched_scan_match_attr = 1;
pub const nl80211_sched_scan_match_attr_NL80211_SCHED_SCAN_MATCH_ATTR_RSSI:
    nl80211_sched_scan_match_attr = 2;
pub const nl80211_sched_scan_match_attr_NL80211_SCHED_SCAN_MATCH_ATTR_RELATIVE_RSSI:
    nl80211_sched_scan_match_attr = 3;
pub const nl80211_sched_scan_match_attr_NL80211_SCHED_SCAN_MATCH_ATTR_RSSI_ADJUST:
    nl80211_sched_scan_match_attr = 4;
pub const nl80211_sched_scan_match_attr_NL80211_SCHED_SCAN_MATCH_ATTR_BSSID:
    nl80211_sched_scan_match_attr = 5;
pub const nl80211_sched_scan_match_attr_NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI:
    nl80211_sched_scan_match_attr = 6;
pub const nl80211_sched_scan_match_attr___NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST:
    nl80211_sched_scan_match_attr = 7;
pub const nl80211_sched_scan_match_attr_NL80211_SCHED_SCAN_MATCH_ATTR_MAX:
    nl80211_sched_scan_match_attr = 6;
#[doc = " enum nl80211_sched_scan_match_attr - scheduled scan match attributes"]
#[doc = " @__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_SCHED_SCAN_MATCH_ATTR_SSID: SSID to be used for matching,"]
#[doc = "\tonly report BSS with matching SSID."]
#[doc = "\t(This cannot be used together with BSSID.)"]
#[doc = " @NL80211_SCHED_SCAN_MATCH_ATTR_RSSI: RSSI threshold (in dBm) for reporting a"]
#[doc = "\tBSS in scan results. Filtering is turned off if not specified. Note that"]
#[doc = "\tif this attribute is in a match set of its own, then it is treated as"]
#[doc = "\tthe default value for all matchsets with an SSID, rather than being a"]
#[doc = "\tmatchset of its own without an RSSI filter. This is due to problems with"]
#[doc = "\thow this API was implemented in the past. Also, due to the same problem,"]
#[doc = "\tthe only way to create a matchset with only an RSSI filter (with this"]
#[doc = "\tattribute) is if there's only a single matchset with the RSSI attribute."]
#[doc = " @NL80211_SCHED_SCAN_MATCH_ATTR_RELATIVE_RSSI: Flag indicating whether"]
#[doc = "\t%NL80211_SCHED_SCAN_MATCH_ATTR_RSSI to be used as absolute RSSI or"]
#[doc = "\trelative to current bss's RSSI."]
#[doc = " @NL80211_SCHED_SCAN_MATCH_ATTR_RSSI_ADJUST: When present the RSSI level for"]
#[doc = "\tBSS-es in the specified band is to be adjusted before doing"]
#[doc = "\tRSSI-based BSS selection. The attribute value is a packed structure"]
#[doc = "\tvalue as specified by &struct nl80211_bss_select_rssi_adjust."]
#[doc = " @NL80211_SCHED_SCAN_MATCH_ATTR_BSSID: BSSID to be used for matching"]
#[doc = "\t(this cannot be used together with SSID)."]
#[doc = " @NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI: Nested attribute that carries the"]
#[doc = "\tband specific minimum rssi thresholds for the bands defined in"]
#[doc = "\tenum nl80211_band. The minimum rssi threshold value(s32) specific to a"]
#[doc = "\tband shall be encapsulated in attribute with type value equals to one"]
#[doc = "\tof the NL80211_BAND_* defined in enum nl80211_band. For example, the"]
#[doc = "\tminimum rssi threshold value for 2.4GHZ band shall be encapsulated"]
#[doc = "\twithin an attribute of type NL80211_BAND_2GHZ. And one or more of such"]
#[doc = "\tattributes will be nested within this attribute."]
#[doc = " @NL80211_SCHED_SCAN_MATCH_ATTR_MAX: highest scheduled scan filter"]
#[doc = "\tattribute number currently defined"]
#[doc = " @__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST: internal use"]
pub type nl80211_sched_scan_match_attr = ::std::os::raw::c_uint;
pub const nl80211_reg_rule_flags_NL80211_RRF_NO_OFDM: nl80211_reg_rule_flags = 1;
pub const nl80211_reg_rule_flags_NL80211_RRF_NO_CCK: nl80211_reg_rule_flags = 2;
pub const nl80211_reg_rule_flags_NL80211_RRF_NO_INDOOR: nl80211_reg_rule_flags = 4;
pub const nl80211_reg_rule_flags_NL80211_RRF_NO_OUTDOOR: nl80211_reg_rule_flags = 8;
pub const nl80211_reg_rule_flags_NL80211_RRF_DFS: nl80211_reg_rule_flags = 16;
pub const nl80211_reg_rule_flags_NL80211_RRF_PTP_ONLY: nl80211_reg_rule_flags = 32;
pub const nl80211_reg_rule_flags_NL80211_RRF_PTMP_ONLY: nl80211_reg_rule_flags = 64;
pub const nl80211_reg_rule_flags_NL80211_RRF_NO_IR: nl80211_reg_rule_flags = 128;
pub const nl80211_reg_rule_flags___NL80211_RRF_NO_IBSS: nl80211_reg_rule_flags = 256;
pub const nl80211_reg_rule_flags_NL80211_RRF_AUTO_BW: nl80211_reg_rule_flags = 2048;
pub const nl80211_reg_rule_flags_NL80211_RRF_IR_CONCURRENT: nl80211_reg_rule_flags = 4096;
pub const nl80211_reg_rule_flags_NL80211_RRF_NO_HT40MINUS: nl80211_reg_rule_flags = 8192;
pub const nl80211_reg_rule_flags_NL80211_RRF_NO_HT40PLUS: nl80211_reg_rule_flags = 16384;
pub const nl80211_reg_rule_flags_NL80211_RRF_NO_80MHZ: nl80211_reg_rule_flags = 32768;
pub const nl80211_reg_rule_flags_NL80211_RRF_NO_160MHZ: nl80211_reg_rule_flags = 65536;
pub const nl80211_reg_rule_flags_NL80211_RRF_NO_HE: nl80211_reg_rule_flags = 131072;
#[doc = " enum nl80211_reg_rule_flags - regulatory rule flags"]
#[doc = ""]
#[doc = " @NL80211_RRF_NO_OFDM: OFDM modulation not allowed"]
#[doc = " @NL80211_RRF_NO_CCK: CCK modulation not allowed"]
#[doc = " @NL80211_RRF_NO_INDOOR: indoor operation not allowed"]
#[doc = " @NL80211_RRF_NO_OUTDOOR: outdoor operation not allowed"]
#[doc = " @NL80211_RRF_DFS: DFS support is required to be used"]
#[doc = " @NL80211_RRF_PTP_ONLY: this is only for Point To Point links"]
#[doc = " @NL80211_RRF_PTMP_ONLY: this is only for Point To Multi Point links"]
#[doc = " @NL80211_RRF_NO_IR: no mechanisms that initiate radiation are allowed,"]
#[doc = " \tthis includes probe requests or modes of operation that require"]
#[doc = " \tbeaconing."]
#[doc = " @NL80211_RRF_AUTO_BW: maximum available bandwidth should be calculated"]
#[doc = "\tbase on contiguous rules and wider channels will be allowed to cross"]
#[doc = "\tmultiple contiguous/overlapping frequency ranges."]
#[doc = " @NL80211_RRF_IR_CONCURRENT: See %NL80211_FREQUENCY_ATTR_IR_CONCURRENT"]
#[doc = " @NL80211_RRF_NO_HT40MINUS: channels can't be used in HT40- operation"]
#[doc = " @NL80211_RRF_NO_HT40PLUS: channels can't be used in HT40+ operation"]
#[doc = " @NL80211_RRF_NO_80MHZ: 80MHz operation not allowed"]
#[doc = " @NL80211_RRF_NO_160MHZ: 160MHz operation not allowed"]
#[doc = " @NL80211_RRF_NO_HE: HE operation not allowed"]
pub type nl80211_reg_rule_flags = ::std::os::raw::c_uint;
pub const nl80211_dfs_regions_NL80211_DFS_UNSET: nl80211_dfs_regions = 0;
pub const nl80211_dfs_regions_NL80211_DFS_FCC: nl80211_dfs_regions = 1;
pub const nl80211_dfs_regions_NL80211_DFS_ETSI: nl80211_dfs_regions = 2;
pub const nl80211_dfs_regions_NL80211_DFS_JP: nl80211_dfs_regions = 3;
#[doc = " enum nl80211_dfs_regions - regulatory DFS regions"]
#[doc = ""]
#[doc = " @NL80211_DFS_UNSET: Country has no DFS master region specified"]
#[doc = " @NL80211_DFS_FCC: Country follows DFS master rules from FCC"]
#[doc = " @NL80211_DFS_ETSI: Country follows DFS master rules from ETSI"]
#[doc = " @NL80211_DFS_JP: Country follows DFS master rules from JP/MKK/Telec"]
pub type nl80211_dfs_regions = ::std::os::raw::c_uint;
pub const nl80211_user_reg_hint_type_NL80211_USER_REG_HINT_USER: nl80211_user_reg_hint_type = 0;
pub const nl80211_user_reg_hint_type_NL80211_USER_REG_HINT_CELL_BASE: nl80211_user_reg_hint_type =
    1;
pub const nl80211_user_reg_hint_type_NL80211_USER_REG_HINT_INDOOR: nl80211_user_reg_hint_type = 2;
#[doc = " enum nl80211_user_reg_hint_type - type of user regulatory hint"]
#[doc = ""]
#[doc = " @NL80211_USER_REG_HINT_USER: a user sent the hint. This is always"]
#[doc = "\tassumed if the attribute is not set."]
#[doc = " @NL80211_USER_REG_HINT_CELL_BASE: the hint comes from a cellular"]
#[doc = "\tbase station. Device drivers that have been tested to work"]
#[doc = "\tproperly to support this type of hint can enable these hints"]
#[doc = "\tby setting the NL80211_FEATURE_CELL_BASE_REG_HINTS feature"]
#[doc = "\tcapability on the struct wiphy. The wireless core will"]
#[doc = "\tignore all cell base station hints until at least one device"]
#[doc = "\tpresent has been registered with the wireless core that"]
#[doc = "\thas listed NL80211_FEATURE_CELL_BASE_REG_HINTS as a"]
#[doc = "\tsupported feature."]
#[doc = " @NL80211_USER_REG_HINT_INDOOR: a user sent an hint indicating that the"]
#[doc = "\tplatform is operating in an indoor environment."]
pub type nl80211_user_reg_hint_type = ::std::os::raw::c_uint;
pub const nl80211_survey_info___NL80211_SURVEY_INFO_INVALID: nl80211_survey_info = 0;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_FREQUENCY: nl80211_survey_info = 1;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_NOISE: nl80211_survey_info = 2;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_IN_USE: nl80211_survey_info = 3;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_TIME: nl80211_survey_info = 4;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_TIME_BUSY: nl80211_survey_info = 5;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_TIME_EXT_BUSY: nl80211_survey_info = 6;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_TIME_RX: nl80211_survey_info = 7;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_TIME_TX: nl80211_survey_info = 8;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_TIME_SCAN: nl80211_survey_info = 9;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_PAD: nl80211_survey_info = 10;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_TIME_BSS_RX: nl80211_survey_info = 11;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_FREQUENCY_OFFSET: nl80211_survey_info = 12;
pub const nl80211_survey_info___NL80211_SURVEY_INFO_AFTER_LAST: nl80211_survey_info = 13;
pub const nl80211_survey_info_NL80211_SURVEY_INFO_MAX: nl80211_survey_info = 12;
#[doc = " enum nl80211_survey_info - survey information"]
#[doc = ""]
#[doc = " These attribute types are used with %NL80211_ATTR_SURVEY_INFO"]
#[doc = " when getting information about a survey."]
#[doc = ""]
#[doc = " @__NL80211_SURVEY_INFO_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_SURVEY_INFO_FREQUENCY: center frequency of channel"]
#[doc = " @NL80211_SURVEY_INFO_NOISE: noise level of channel (u8, dBm)"]
#[doc = " @NL80211_SURVEY_INFO_IN_USE: channel is currently being used"]
#[doc = " @NL80211_SURVEY_INFO_TIME: amount of time (in ms) that the radio"]
#[doc = "\twas turned on (on channel or globally)"]
#[doc = " @NL80211_SURVEY_INFO_TIME_BUSY: amount of the time the primary"]
#[doc = "\tchannel was sensed busy (either due to activity or energy detect)"]
#[doc = " @NL80211_SURVEY_INFO_TIME_EXT_BUSY: amount of time the extension"]
#[doc = "\tchannel was sensed busy"]
#[doc = " @NL80211_SURVEY_INFO_TIME_RX: amount of time the radio spent"]
#[doc = "\treceiving data (on channel or globally)"]
#[doc = " @NL80211_SURVEY_INFO_TIME_TX: amount of time the radio spent"]
#[doc = "\ttransmitting data (on channel or globally)"]
#[doc = " @NL80211_SURVEY_INFO_TIME_SCAN: time the radio spent for scan"]
#[doc = "\t(on this channel or globally)"]
#[doc = " @NL80211_SURVEY_INFO_PAD: attribute used for padding for 64-bit alignment"]
#[doc = " @NL80211_SURVEY_INFO_TIME_BSS_RX: amount of time the radio spent"]
#[doc = "\treceiving frames destined to the local BSS"]
#[doc = " @NL80211_SURVEY_INFO_MAX: highest survey info attribute number"]
#[doc = "\tcurrently defined"]
#[doc = " @NL80211_SURVEY_INFO_FREQUENCY_OFFSET: center frequency offset in KHz"]
#[doc = " @__NL80211_SURVEY_INFO_AFTER_LAST: internal use"]
pub type nl80211_survey_info = ::std::os::raw::c_uint;
pub const nl80211_mntr_flags___NL80211_MNTR_FLAG_INVALID: nl80211_mntr_flags = 0;
pub const nl80211_mntr_flags_NL80211_MNTR_FLAG_FCSFAIL: nl80211_mntr_flags = 1;
pub const nl80211_mntr_flags_NL80211_MNTR_FLAG_PLCPFAIL: nl80211_mntr_flags = 2;
pub const nl80211_mntr_flags_NL80211_MNTR_FLAG_CONTROL: nl80211_mntr_flags = 3;
pub const nl80211_mntr_flags_NL80211_MNTR_FLAG_OTHER_BSS: nl80211_mntr_flags = 4;
pub const nl80211_mntr_flags_NL80211_MNTR_FLAG_COOK_FRAMES: nl80211_mntr_flags = 5;
pub const nl80211_mntr_flags_NL80211_MNTR_FLAG_ACTIVE: nl80211_mntr_flags = 6;
pub const nl80211_mntr_flags___NL80211_MNTR_FLAG_AFTER_LAST: nl80211_mntr_flags = 7;
pub const nl80211_mntr_flags_NL80211_MNTR_FLAG_MAX: nl80211_mntr_flags = 6;
#[doc = " enum nl80211_mntr_flags - monitor configuration flags"]
#[doc = ""]
#[doc = " Monitor configuration flags."]
#[doc = ""]
#[doc = " @__NL80211_MNTR_FLAG_INVALID: reserved"]
#[doc = ""]
#[doc = " @NL80211_MNTR_FLAG_FCSFAIL: pass frames with bad FCS"]
#[doc = " @NL80211_MNTR_FLAG_PLCPFAIL: pass frames with bad PLCP"]
#[doc = " @NL80211_MNTR_FLAG_CONTROL: pass control frames"]
#[doc = " @NL80211_MNTR_FLAG_OTHER_BSS: disable BSSID filtering"]
#[doc = " @NL80211_MNTR_FLAG_COOK_FRAMES: report frames after processing."]
#[doc = "\toverrides all other flags."]
#[doc = " @NL80211_MNTR_FLAG_ACTIVE: use the configured MAC address"]
#[doc = "\tand ACK incoming unicast packets."]
#[doc = ""]
#[doc = " @__NL80211_MNTR_FLAG_AFTER_LAST: internal use"]
#[doc = " @NL80211_MNTR_FLAG_MAX: highest possible monitor flag"]
pub type nl80211_mntr_flags = ::std::os::raw::c_uint;
pub const nl80211_mesh_power_mode_NL80211_MESH_POWER_UNKNOWN: nl80211_mesh_power_mode = 0;
pub const nl80211_mesh_power_mode_NL80211_MESH_POWER_ACTIVE: nl80211_mesh_power_mode = 1;
pub const nl80211_mesh_power_mode_NL80211_MESH_POWER_LIGHT_SLEEP: nl80211_mesh_power_mode = 2;
pub const nl80211_mesh_power_mode_NL80211_MESH_POWER_DEEP_SLEEP: nl80211_mesh_power_mode = 3;
pub const nl80211_mesh_power_mode___NL80211_MESH_POWER_AFTER_LAST: nl80211_mesh_power_mode = 4;
pub const nl80211_mesh_power_mode_NL80211_MESH_POWER_MAX: nl80211_mesh_power_mode = 3;
#[doc = " enum nl80211_mesh_power_mode - mesh power save modes"]
#[doc = ""]
#[doc = " @NL80211_MESH_POWER_UNKNOWN: The mesh power mode of the mesh STA is"]
#[doc = "\tnot known or has not been set yet."]
#[doc = " @NL80211_MESH_POWER_ACTIVE: Active mesh power mode. The mesh STA is"]
#[doc = "\tin Awake state all the time."]
#[doc = " @NL80211_MESH_POWER_LIGHT_SLEEP: Light sleep mode. The mesh STA will"]
#[doc = "\talternate between Active and Doze states, but will wake up for"]
#[doc = "\tneighbor's beacons."]
#[doc = " @NL80211_MESH_POWER_DEEP_SLEEP: Deep sleep mode. The mesh STA will"]
#[doc = "\talternate between Active and Doze states, but may not wake up"]
#[doc = "\tfor neighbor's beacons."]
#[doc = ""]
#[doc = " @__NL80211_MESH_POWER_AFTER_LAST - internal use"]
#[doc = " @NL80211_MESH_POWER_MAX - highest possible power save level"]
pub type nl80211_mesh_power_mode = ::std::os::raw::c_uint;
pub const nl80211_meshconf_params___NL80211_MESHCONF_INVALID: nl80211_meshconf_params = 0;
pub const nl80211_meshconf_params_NL80211_MESHCONF_RETRY_TIMEOUT: nl80211_meshconf_params = 1;
pub const nl80211_meshconf_params_NL80211_MESHCONF_CONFIRM_TIMEOUT: nl80211_meshconf_params = 2;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HOLDING_TIMEOUT: nl80211_meshconf_params = 3;
pub const nl80211_meshconf_params_NL80211_MESHCONF_MAX_PEER_LINKS: nl80211_meshconf_params = 4;
pub const nl80211_meshconf_params_NL80211_MESHCONF_MAX_RETRIES: nl80211_meshconf_params = 5;
pub const nl80211_meshconf_params_NL80211_MESHCONF_TTL: nl80211_meshconf_params = 6;
pub const nl80211_meshconf_params_NL80211_MESHCONF_AUTO_OPEN_PLINKS: nl80211_meshconf_params = 7;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES: nl80211_meshconf_params =
    8;
pub const nl80211_meshconf_params_NL80211_MESHCONF_PATH_REFRESH_TIME: nl80211_meshconf_params = 9;
pub const nl80211_meshconf_params_NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT: nl80211_meshconf_params =
    10;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT:
    nl80211_meshconf_params = 11;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL: nl80211_meshconf_params =
    12;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME:
    nl80211_meshconf_params = 13;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HWMP_ROOTMODE: nl80211_meshconf_params = 14;
pub const nl80211_meshconf_params_NL80211_MESHCONF_ELEMENT_TTL: nl80211_meshconf_params = 15;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HWMP_RANN_INTERVAL: nl80211_meshconf_params = 16;
pub const nl80211_meshconf_params_NL80211_MESHCONF_GATE_ANNOUNCEMENTS: nl80211_meshconf_params = 17;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL: nl80211_meshconf_params =
    18;
pub const nl80211_meshconf_params_NL80211_MESHCONF_FORWARDING: nl80211_meshconf_params = 19;
pub const nl80211_meshconf_params_NL80211_MESHCONF_RSSI_THRESHOLD: nl80211_meshconf_params = 20;
pub const nl80211_meshconf_params_NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR:
    nl80211_meshconf_params = 21;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HT_OPMODE: nl80211_meshconf_params = 22;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT:
    nl80211_meshconf_params = 23;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HWMP_ROOT_INTERVAL: nl80211_meshconf_params = 24;
pub const nl80211_meshconf_params_NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL:
    nl80211_meshconf_params = 25;
pub const nl80211_meshconf_params_NL80211_MESHCONF_POWER_MODE: nl80211_meshconf_params = 26;
pub const nl80211_meshconf_params_NL80211_MESHCONF_AWAKE_WINDOW: nl80211_meshconf_params = 27;
pub const nl80211_meshconf_params_NL80211_MESHCONF_PLINK_TIMEOUT: nl80211_meshconf_params = 28;
pub const nl80211_meshconf_params_NL80211_MESHCONF_CONNECTED_TO_GATE: nl80211_meshconf_params = 29;
pub const nl80211_meshconf_params_NL80211_MESHCONF_NOLEARN: nl80211_meshconf_params = 30;
pub const nl80211_meshconf_params_NL80211_MESHCONF_CONNECTED_TO_AS: nl80211_meshconf_params = 31;
pub const nl80211_meshconf_params___NL80211_MESHCONF_ATTR_AFTER_LAST: nl80211_meshconf_params = 32;
pub const nl80211_meshconf_params_NL80211_MESHCONF_ATTR_MAX: nl80211_meshconf_params = 31;
#[doc = " enum nl80211_meshconf_params - mesh configuration parameters"]
#[doc = ""]
#[doc = " Mesh configuration parameters. These can be changed while the mesh is"]
#[doc = " active."]
#[doc = ""]
#[doc = " @__NL80211_MESHCONF_INVALID: internal use"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_RETRY_TIMEOUT: specifies the initial retry timeout in"]
#[doc = "\tmillisecond units, used by the Peer Link Open message"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_CONFIRM_TIMEOUT: specifies the initial confirm timeout, in"]
#[doc = "\tmillisecond units, used by the peer link management to close a peer link"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HOLDING_TIMEOUT: specifies the holding timeout, in"]
#[doc = "\tmillisecond units"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_MAX_PEER_LINKS: maximum number of peer links allowed"]
#[doc = "\ton this mesh interface"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_MAX_RETRIES: specifies the maximum number of peer link"]
#[doc = "\topen retries that can be sent to establish a new peer link instance in a"]
#[doc = "\tmesh"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_TTL: specifies the value of TTL field set at a source mesh"]
#[doc = "\tpoint."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_AUTO_OPEN_PLINKS: whether we should automatically open"]
#[doc = "\tpeer links when we detect compatible mesh peers. Disabled if"]
#[doc = "\t@NL80211_MESH_SETUP_USERSPACE_MPM or @NL80211_MESH_SETUP_USERSPACE_AMPE are"]
#[doc = "\tset."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES: the number of action frames"]
#[doc = "\tcontaining a PREQ that an MP can send to a particular destination (path"]
#[doc = "\ttarget)"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_PATH_REFRESH_TIME: how frequently to refresh mesh paths"]
#[doc = "\t(in milliseconds)"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT: minimum length of time to wait"]
#[doc = "\tuntil giving up on a path discovery (in milliseconds)"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT: The time (in TUs) for which mesh"]
#[doc = "\tpoints receiving a PREQ shall consider the forwarding information from"]
#[doc = "\tthe root to be valid. (TU = time unit)"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL: The minimum interval of time (in"]
#[doc = "\tTUs) during which an MP can send only one action frame containing a PREQ"]
#[doc = "\treference element"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME: The interval of time (in TUs)"]
#[doc = "\tthat it takes for an HWMP information element to propagate across the"]
#[doc = "\tmesh"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HWMP_ROOTMODE: whether root mode is enabled or not"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_ELEMENT_TTL: specifies the value of TTL field set at a"]
#[doc = "\tsource mesh point for path selection elements."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HWMP_RANN_INTERVAL:  The interval of time (in TUs) between"]
#[doc = "\troot announcements are transmitted."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_GATE_ANNOUNCEMENTS: Advertise that this mesh station has"]
#[doc = "\taccess to a broader network beyond the MBSS.  This is done via Root"]
#[doc = "\tAnnouncement frames."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL: The minimum interval of time (in"]
#[doc = "\tTUs) during which a mesh STA can send only one Action frame containing a"]
#[doc = "\tPERR element."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_FORWARDING: set Mesh STA as forwarding or non-forwarding"]
#[doc = "\tor forwarding entity (default is TRUE - forwarding entity)"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_RSSI_THRESHOLD: RSSI threshold in dBm. This specifies the"]
#[doc = "\tthreshold for average signal strength of candidate station to establish"]
#[doc = "\ta peer link."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR: maximum number of neighbors"]
#[doc = "\tto synchronize to for 11s default synchronization method"]
#[doc = "\t(see 11C.12.2.2)"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HT_OPMODE: set mesh HT protection mode."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_ATTR_MAX: highest possible mesh configuration attribute"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT: The time (in TUs) for"]
#[doc = "\twhich mesh STAs receiving a proactive PREQ shall consider the forwarding"]
#[doc = "\tinformation to the root mesh STA to be valid."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HWMP_ROOT_INTERVAL: The interval of time (in TUs) between"]
#[doc = "\tproactive PREQs are transmitted."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL: The minimum interval of time"]
#[doc = "\t(in TUs) during which a mesh STA can send only one Action frame"]
#[doc = "\tcontaining a PREQ element for root path confirmation."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_POWER_MODE: Default mesh power mode for new peer links."]
#[doc = "\ttype &enum nl80211_mesh_power_mode (u32)"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_AWAKE_WINDOW: awake window duration (in TUs)"]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_PLINK_TIMEOUT: If no tx activity is seen from a STA we've"]
#[doc = "\testablished peering with for longer than this time (in seconds), then"]
#[doc = "\tremove it from the STA's list of peers. You may set this to 0 to disable"]
#[doc = "\tthe removal of the STA. Default is 30 minutes."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_CONNECTED_TO_GATE: If set to true then this mesh STA"]
#[doc = "\twill advertise that it is connected to a gate in the mesh formation"]
#[doc = "\tfield.  If left unset then the mesh formation field will only"]
#[doc = "\tadvertise such if there is an active root mesh path."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_NOLEARN: Try to avoid multi-hop path discovery (e.g."]
#[doc = "      PREQ/PREP for HWMP) if the destination is a direct neighbor. Note that"]
#[doc = "      this might not be the optimal decision as a multi-hop route might be"]
#[doc = "      better. So if using this setting you will likely also want to disable"]
#[doc = "      dot11MeshForwarding and use another mesh routing protocol on top."]
#[doc = ""]
#[doc = " @NL80211_MESHCONF_CONNECTED_TO_AS: If set to true then this mesh STA"]
#[doc = "\twill advertise that it is connected to a authentication server"]
#[doc = "\tin the mesh formation field."]
#[doc = ""]
#[doc = " @__NL80211_MESHCONF_ATTR_AFTER_LAST: internal use"]
pub type nl80211_meshconf_params = ::std::os::raw::c_uint;
pub const nl80211_mesh_setup_params___NL80211_MESH_SETUP_INVALID: nl80211_mesh_setup_params = 0;
pub const nl80211_mesh_setup_params_NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL:
    nl80211_mesh_setup_params = 1;
pub const nl80211_mesh_setup_params_NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC:
    nl80211_mesh_setup_params = 2;
pub const nl80211_mesh_setup_params_NL80211_MESH_SETUP_IE: nl80211_mesh_setup_params = 3;
pub const nl80211_mesh_setup_params_NL80211_MESH_SETUP_USERSPACE_AUTH: nl80211_mesh_setup_params =
    4;
pub const nl80211_mesh_setup_params_NL80211_MESH_SETUP_USERSPACE_AMPE: nl80211_mesh_setup_params =
    5;
pub const nl80211_mesh_setup_params_NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC:
    nl80211_mesh_setup_params = 6;
pub const nl80211_mesh_setup_params_NL80211_MESH_SETUP_USERSPACE_MPM: nl80211_mesh_setup_params = 7;
pub const nl80211_mesh_setup_params_NL80211_MESH_SETUP_AUTH_PROTOCOL: nl80211_mesh_setup_params = 8;
pub const nl80211_mesh_setup_params___NL80211_MESH_SETUP_ATTR_AFTER_LAST:
    nl80211_mesh_setup_params = 9;
pub const nl80211_mesh_setup_params_NL80211_MESH_SETUP_ATTR_MAX: nl80211_mesh_setup_params = 8;
#[doc = " enum nl80211_mesh_setup_params - mesh setup parameters"]
#[doc = ""]
#[doc = " Mesh setup parameters.  These are used to start/join a mesh and cannot be"]
#[doc = " changed while the mesh is active."]
#[doc = ""]
#[doc = " @__NL80211_MESH_SETUP_INVALID: Internal use"]
#[doc = ""]
#[doc = " @NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL: Enable this option to use a"]
#[doc = "\tvendor specific path selection algorithm or disable it to use the"]
#[doc = "\tdefault HWMP."]
#[doc = ""]
#[doc = " @NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC: Enable this option to use a"]
#[doc = "\tvendor specific path metric or disable it to use the default Airtime"]
#[doc = "\tmetric."]
#[doc = ""]
#[doc = " @NL80211_MESH_SETUP_IE: Information elements for this mesh, for instance, a"]
#[doc = "\trobust security network ie, or a vendor specific information element"]
#[doc = "\tthat vendors will use to identify the path selection methods and"]
#[doc = "\tmetrics in use."]
#[doc = ""]
#[doc = " @NL80211_MESH_SETUP_USERSPACE_AUTH: Enable this option if an authentication"]
#[doc = "\tdaemon will be authenticating mesh candidates."]
#[doc = ""]
#[doc = " @NL80211_MESH_SETUP_USERSPACE_AMPE: Enable this option if an authentication"]
#[doc = "\tdaemon will be securing peer link frames.  AMPE is a secured version of"]
#[doc = "\tMesh Peering Management (MPM) and is implemented with the assistance of"]
#[doc = "\ta userspace daemon.  When this flag is set, the kernel will send peer"]
#[doc = "\tmanagement frames to a userspace daemon that will implement AMPE"]
#[doc = "\tfunctionality (security capabilities selection, key confirmation, and"]
#[doc = "\tkey management).  When the flag is unset (default), the kernel can"]
#[doc = "\tautonomously complete (unsecured) mesh peering without the need of a"]
#[doc = "\tuserspace daemon."]
#[doc = ""]
#[doc = " @NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC: Enable this option to use a"]
#[doc = "\tvendor specific synchronization method or disable it to use the default"]
#[doc = "\tneighbor offset synchronization"]
#[doc = ""]
#[doc = " @NL80211_MESH_SETUP_USERSPACE_MPM: Enable this option if userspace will"]
#[doc = "\timplement an MPM which handles peer allocation and state."]
#[doc = ""]
#[doc = " @NL80211_MESH_SETUP_AUTH_PROTOCOL: Inform the kernel of the authentication"]
#[doc = "\tmethod (u8, as defined in IEEE 8.4.2.100.6, e.g. 0x1 for SAE)."]
#[doc = "\tDefault is no authentication method required."]
#[doc = ""]
#[doc = " @NL80211_MESH_SETUP_ATTR_MAX: highest possible mesh setup attribute number"]
#[doc = ""]
#[doc = " @__NL80211_MESH_SETUP_ATTR_AFTER_LAST: Internal use"]
pub type nl80211_mesh_setup_params = ::std::os::raw::c_uint;
pub const nl80211_txq_attr___NL80211_TXQ_ATTR_INVALID: nl80211_txq_attr = 0;
pub const nl80211_txq_attr_NL80211_TXQ_ATTR_AC: nl80211_txq_attr = 1;
pub const nl80211_txq_attr_NL80211_TXQ_ATTR_TXOP: nl80211_txq_attr = 2;
pub const nl80211_txq_attr_NL80211_TXQ_ATTR_CWMIN: nl80211_txq_attr = 3;
pub const nl80211_txq_attr_NL80211_TXQ_ATTR_CWMAX: nl80211_txq_attr = 4;
pub const nl80211_txq_attr_NL80211_TXQ_ATTR_AIFS: nl80211_txq_attr = 5;
pub const nl80211_txq_attr___NL80211_TXQ_ATTR_AFTER_LAST: nl80211_txq_attr = 6;
pub const nl80211_txq_attr_NL80211_TXQ_ATTR_MAX: nl80211_txq_attr = 5;
#[doc = " enum nl80211_txq_attr - TX queue parameter attributes"]
#[doc = " @__NL80211_TXQ_ATTR_INVALID: Attribute number 0 is reserved"]
#[doc = " @NL80211_TXQ_ATTR_AC: AC identifier (NL80211_AC_*)"]
#[doc = " @NL80211_TXQ_ATTR_TXOP: Maximum burst time in units of 32 usecs, 0 meaning"]
#[doc = "\tdisabled"]
#[doc = " @NL80211_TXQ_ATTR_CWMIN: Minimum contention window [a value of the form"]
#[doc = "\t2^n-1 in the range 1..32767]"]
#[doc = " @NL80211_TXQ_ATTR_CWMAX: Maximum contention window [a value of the form"]
#[doc = "\t2^n-1 in the range 1..32767]"]
#[doc = " @NL80211_TXQ_ATTR_AIFS: Arbitration interframe space [0..255]"]
#[doc = " @__NL80211_TXQ_ATTR_AFTER_LAST: Internal"]
#[doc = " @NL80211_TXQ_ATTR_MAX: Maximum TXQ attribute number"]
pub type nl80211_txq_attr = ::std::os::raw::c_uint;
pub const nl80211_ac_NL80211_AC_VO: nl80211_ac = 0;
pub const nl80211_ac_NL80211_AC_VI: nl80211_ac = 1;
pub const nl80211_ac_NL80211_AC_BE: nl80211_ac = 2;
pub const nl80211_ac_NL80211_AC_BK: nl80211_ac = 3;
pub const nl80211_ac_NL80211_NUM_ACS: nl80211_ac = 4;
pub type nl80211_ac = ::std::os::raw::c_uint;
pub const nl80211_channel_type_NL80211_CHAN_NO_HT: nl80211_channel_type = 0;
pub const nl80211_channel_type_NL80211_CHAN_HT20: nl80211_channel_type = 1;
pub const nl80211_channel_type_NL80211_CHAN_HT40MINUS: nl80211_channel_type = 2;
pub const nl80211_channel_type_NL80211_CHAN_HT40PLUS: nl80211_channel_type = 3;
#[doc = " enum nl80211_channel_type - channel type"]
#[doc = " @NL80211_CHAN_NO_HT: 20 MHz, non-HT channel"]
#[doc = " @NL80211_CHAN_HT20: 20 MHz HT channel"]
#[doc = " @NL80211_CHAN_HT40MINUS: HT40 channel, secondary channel"]
#[doc = "\tbelow the control channel"]
#[doc = " @NL80211_CHAN_HT40PLUS: HT40 channel, secondary channel"]
#[doc = "\tabove the control channel"]
pub type nl80211_channel_type = ::std::os::raw::c_uint;
pub const nl80211_key_mode_NL80211_KEY_RX_TX: nl80211_key_mode = 0;
pub const nl80211_key_mode_NL80211_KEY_NO_TX: nl80211_key_mode = 1;
pub const nl80211_key_mode_NL80211_KEY_SET_TX: nl80211_key_mode = 2;
#[doc = " enum nl80211_key_mode - Key mode"]
#[doc = ""]
#[doc = " @NL80211_KEY_RX_TX: (Default)"]
#[doc = "\tKey can be used for Rx and Tx immediately"]
#[doc = ""]
#[doc = " The following modes can only be selected for unicast keys and when the"]
#[doc = " driver supports @NL80211_EXT_FEATURE_EXT_KEY_ID:"]
#[doc = ""]
#[doc = " @NL80211_KEY_NO_TX: Only allowed in combination with @NL80211_CMD_NEW_KEY:"]
#[doc = "\tUnicast key can only be used for Rx, Tx not allowed, yet"]
#[doc = " @NL80211_KEY_SET_TX: Only allowed in combination with @NL80211_CMD_SET_KEY:"]
#[doc = "\tThe unicast key identified by idx and mac is cleared for Tx and becomes"]
#[doc = "\tthe preferred Tx key for the station."]
pub type nl80211_key_mode = ::std::os::raw::c_uint;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_20_NOHT: nl80211_chan_width = 0;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_20: nl80211_chan_width = 1;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_40: nl80211_chan_width = 2;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_80: nl80211_chan_width = 3;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_80P80: nl80211_chan_width = 4;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_160: nl80211_chan_width = 5;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_5: nl80211_chan_width = 6;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_10: nl80211_chan_width = 7;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_1: nl80211_chan_width = 8;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_2: nl80211_chan_width = 9;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_4: nl80211_chan_width = 10;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_8: nl80211_chan_width = 11;
pub const nl80211_chan_width_NL80211_CHAN_WIDTH_16: nl80211_chan_width = 12;
#[doc = " enum nl80211_chan_width - channel width definitions"]
#[doc = ""]
#[doc = " These values are used with the %NL80211_ATTR_CHANNEL_WIDTH"]
#[doc = " attribute."]
#[doc = ""]
#[doc = " @NL80211_CHAN_WIDTH_20_NOHT: 20 MHz, non-HT channel"]
#[doc = " @NL80211_CHAN_WIDTH_20: 20 MHz HT channel"]
#[doc = " @NL80211_CHAN_WIDTH_40: 40 MHz channel, the %NL80211_ATTR_CENTER_FREQ1"]
#[doc = "\tattribute must be provided as well"]
#[doc = " @NL80211_CHAN_WIDTH_80: 80 MHz channel, the %NL80211_ATTR_CENTER_FREQ1"]
#[doc = "\tattribute must be provided as well"]
#[doc = " @NL80211_CHAN_WIDTH_80P80: 80+80 MHz channel, the %NL80211_ATTR_CENTER_FREQ1"]
#[doc = "\tand %NL80211_ATTR_CENTER_FREQ2 attributes must be provided as well"]
#[doc = " @NL80211_CHAN_WIDTH_160: 160 MHz channel, the %NL80211_ATTR_CENTER_FREQ1"]
#[doc = "\tattribute must be provided as well"]
#[doc = " @NL80211_CHAN_WIDTH_5: 5 MHz OFDM channel"]
#[doc = " @NL80211_CHAN_WIDTH_10: 10 MHz OFDM channel"]
#[doc = " @NL80211_CHAN_WIDTH_1: 1 MHz OFDM channel"]
#[doc = " @NL80211_CHAN_WIDTH_2: 2 MHz OFDM channel"]
#[doc = " @NL80211_CHAN_WIDTH_4: 4 MHz OFDM channel"]
#[doc = " @NL80211_CHAN_WIDTH_8: 8 MHz OFDM channel"]
#[doc = " @NL80211_CHAN_WIDTH_16: 16 MHz OFDM channel"]
pub type nl80211_chan_width = ::std::os::raw::c_uint;
pub const nl80211_bss_scan_width_NL80211_BSS_CHAN_WIDTH_20: nl80211_bss_scan_width = 0;
pub const nl80211_bss_scan_width_NL80211_BSS_CHAN_WIDTH_10: nl80211_bss_scan_width = 1;
pub const nl80211_bss_scan_width_NL80211_BSS_CHAN_WIDTH_5: nl80211_bss_scan_width = 2;
pub const nl80211_bss_scan_width_NL80211_BSS_CHAN_WIDTH_1: nl80211_bss_scan_width = 3;
pub const nl80211_bss_scan_width_NL80211_BSS_CHAN_WIDTH_2: nl80211_bss_scan_width = 4;
#[doc = " enum nl80211_bss_scan_width - control channel width for a BSS"]
#[doc = ""]
#[doc = " These values are used with the %NL80211_BSS_CHAN_WIDTH attribute."]
#[doc = ""]
#[doc = " @NL80211_BSS_CHAN_WIDTH_20: control channel is 20 MHz wide or compatible"]
#[doc = " @NL80211_BSS_CHAN_WIDTH_10: control channel is 10 MHz wide"]
#[doc = " @NL80211_BSS_CHAN_WIDTH_5: control channel is 5 MHz wide"]
#[doc = " @NL80211_BSS_CHAN_WIDTH_1: control channel is 1 MHz wide"]
#[doc = " @NL80211_BSS_CHAN_WIDTH_2: control channel is 2 MHz wide"]
pub type nl80211_bss_scan_width = ::std::os::raw::c_uint;
pub const nl80211_bss___NL80211_BSS_INVALID: nl80211_bss = 0;
pub const nl80211_bss_NL80211_BSS_BSSID: nl80211_bss = 1;
pub const nl80211_bss_NL80211_BSS_FREQUENCY: nl80211_bss = 2;
pub const nl80211_bss_NL80211_BSS_TSF: nl80211_bss = 3;
pub const nl80211_bss_NL80211_BSS_BEACON_INTERVAL: nl80211_bss = 4;
pub const nl80211_bss_NL80211_BSS_CAPABILITY: nl80211_bss = 5;
pub const nl80211_bss_NL80211_BSS_INFORMATION_ELEMENTS: nl80211_bss = 6;
pub const nl80211_bss_NL80211_BSS_SIGNAL_MBM: nl80211_bss = 7;
pub const nl80211_bss_NL80211_BSS_SIGNAL_UNSPEC: nl80211_bss = 8;
pub const nl80211_bss_NL80211_BSS_STATUS: nl80211_bss = 9;
pub const nl80211_bss_NL80211_BSS_SEEN_MS_AGO: nl80211_bss = 10;
pub const nl80211_bss_NL80211_BSS_BEACON_IES: nl80211_bss = 11;
pub const nl80211_bss_NL80211_BSS_CHAN_WIDTH: nl80211_bss = 12;
pub const nl80211_bss_NL80211_BSS_BEACON_TSF: nl80211_bss = 13;
pub const nl80211_bss_NL80211_BSS_PRESP_DATA: nl80211_bss = 14;
pub const nl80211_bss_NL80211_BSS_LAST_SEEN_BOOTTIME: nl80211_bss = 15;
pub const nl80211_bss_NL80211_BSS_PAD: nl80211_bss = 16;
pub const nl80211_bss_NL80211_BSS_PARENT_TSF: nl80211_bss = 17;
pub const nl80211_bss_NL80211_BSS_PARENT_BSSID: nl80211_bss = 18;
pub const nl80211_bss_NL80211_BSS_CHAIN_SIGNAL: nl80211_bss = 19;
pub const nl80211_bss_NL80211_BSS_FREQUENCY_OFFSET: nl80211_bss = 20;
pub const nl80211_bss___NL80211_BSS_AFTER_LAST: nl80211_bss = 21;
pub const nl80211_bss_NL80211_BSS_MAX: nl80211_bss = 20;
#[doc = " enum nl80211_bss - netlink attributes for a BSS"]
#[doc = ""]
#[doc = " @__NL80211_BSS_INVALID: invalid"]
#[doc = " @NL80211_BSS_BSSID: BSSID of the BSS (6 octets)"]
#[doc = " @NL80211_BSS_FREQUENCY: frequency in MHz (u32)"]
#[doc = " @NL80211_BSS_TSF: TSF of the received probe response/beacon (u64)"]
#[doc = "\t(if @NL80211_BSS_PRESP_DATA is present then this is known to be"]
#[doc = "\tfrom a probe response, otherwise it may be from the same beacon"]
#[doc = "\tthat the NL80211_BSS_BEACON_TSF will be from)"]
#[doc = " @NL80211_BSS_BEACON_INTERVAL: beacon interval of the (I)BSS (u16)"]
#[doc = " @NL80211_BSS_CAPABILITY: capability field (CPU order, u16)"]
#[doc = " @NL80211_BSS_INFORMATION_ELEMENTS: binary attribute containing the"]
#[doc = "\traw information elements from the probe response/beacon (bin);"]
#[doc = "\tif the %NL80211_BSS_BEACON_IES attribute is present and the data is"]
#[doc = "\tdifferent then the IEs here are from a Probe Response frame; otherwise"]
#[doc = "\tthey are from a Beacon frame."]
#[doc = "\tHowever, if the driver does not indicate the source of the IEs, these"]
#[doc = "\tIEs may be from either frame subtype."]
#[doc = "\tIf present, the @NL80211_BSS_PRESP_DATA attribute indicates that the"]
#[doc = "\tdata here is known to be from a probe response, without any heuristics."]
#[doc = " @NL80211_BSS_SIGNAL_MBM: signal strength of probe response/beacon"]
#[doc = "\tin mBm (100 * dBm) (s32)"]
#[doc = " @NL80211_BSS_SIGNAL_UNSPEC: signal strength of the probe response/beacon"]
#[doc = "\tin unspecified units, scaled to 0..100 (u8)"]
#[doc = " @NL80211_BSS_STATUS: status, if this BSS is \"used\""]
#[doc = " @NL80211_BSS_SEEN_MS_AGO: age of this BSS entry in ms"]
#[doc = " @NL80211_BSS_BEACON_IES: binary attribute containing the raw information"]
#[doc = "\telements from a Beacon frame (bin); not present if no Beacon frame has"]
#[doc = "\tyet been received"]
#[doc = " @NL80211_BSS_CHAN_WIDTH: channel width of the control channel"]
#[doc = "\t(u32, enum nl80211_bss_scan_width)"]
#[doc = " @NL80211_BSS_BEACON_TSF: TSF of the last received beacon (u64)"]
#[doc = "\t(not present if no beacon frame has been received yet)"]
#[doc = " @NL80211_BSS_PRESP_DATA: the data in @NL80211_BSS_INFORMATION_ELEMENTS and"]
#[doc = "\t@NL80211_BSS_TSF is known to be from a probe response (flag attribute)"]
#[doc = " @NL80211_BSS_LAST_SEEN_BOOTTIME: CLOCK_BOOTTIME timestamp when this entry"]
#[doc = "\twas last updated by a received frame. The value is expected to be"]
#[doc = "\taccurate to about 10ms. (u64, nanoseconds)"]
#[doc = " @NL80211_BSS_PAD: attribute used for padding for 64-bit alignment"]
#[doc = " @NL80211_BSS_PARENT_TSF: the time at the start of reception of the first"]
#[doc = "\toctet of the timestamp field of the last beacon/probe received for"]
#[doc = "\tthis BSS. The time is the TSF of the BSS specified by"]
#[doc = "\t@NL80211_BSS_PARENT_BSSID. (u64)."]
#[doc = " @NL80211_BSS_PARENT_BSSID: the BSS according to which @NL80211_BSS_PARENT_TSF"]
#[doc = "\tis set."]
#[doc = " @NL80211_BSS_CHAIN_SIGNAL: per-chain signal strength of last BSS update."]
#[doc = "\tContains a nested array of signal strength attributes (u8, dBm),"]
#[doc = "\tusing the nesting index as the antenna number."]
#[doc = " @NL80211_BSS_FREQUENCY_OFFSET: frequency offset in KHz"]
#[doc = " @__NL80211_BSS_AFTER_LAST: internal"]
#[doc = " @NL80211_BSS_MAX: highest BSS attribute"]
pub type nl80211_bss = ::std::os::raw::c_uint;
pub const nl80211_bss_status_NL80211_BSS_STATUS_AUTHENTICATED: nl80211_bss_status = 0;
pub const nl80211_bss_status_NL80211_BSS_STATUS_ASSOCIATED: nl80211_bss_status = 1;
pub const nl80211_bss_status_NL80211_BSS_STATUS_IBSS_JOINED: nl80211_bss_status = 2;
#[doc = " enum nl80211_bss_status - BSS \"status\""]
#[doc = " @NL80211_BSS_STATUS_AUTHENTICATED: Authenticated with this BSS."]
#[doc = "\tNote that this is no longer used since cfg80211 no longer"]
#[doc = "\tkeeps track of whether or not authentication was done with"]
#[doc = "\ta given BSS."]
#[doc = " @NL80211_BSS_STATUS_ASSOCIATED: Associated with this BSS."]
#[doc = " @NL80211_BSS_STATUS_IBSS_JOINED: Joined to this IBSS."]
#[doc = ""]
#[doc = " The BSS status is a BSS attribute in scan dumps, which"]
#[doc = " indicates the status the interface has wrt. this BSS."]
pub type nl80211_bss_status = ::std::os::raw::c_uint;
pub const nl80211_auth_type_NL80211_AUTHTYPE_OPEN_SYSTEM: nl80211_auth_type = 0;
pub const nl80211_auth_type_NL80211_AUTHTYPE_SHARED_KEY: nl80211_auth_type = 1;
pub const nl80211_auth_type_NL80211_AUTHTYPE_FT: nl80211_auth_type = 2;
pub const nl80211_auth_type_NL80211_AUTHTYPE_NETWORK_EAP: nl80211_auth_type = 3;
pub const nl80211_auth_type_NL80211_AUTHTYPE_SAE: nl80211_auth_type = 4;
pub const nl80211_auth_type_NL80211_AUTHTYPE_FILS_SK: nl80211_auth_type = 5;
pub const nl80211_auth_type_NL80211_AUTHTYPE_FILS_SK_PFS: nl80211_auth_type = 6;
pub const nl80211_auth_type_NL80211_AUTHTYPE_FILS_PK: nl80211_auth_type = 7;
pub const nl80211_auth_type___NL80211_AUTHTYPE_NUM: nl80211_auth_type = 8;
pub const nl80211_auth_type_NL80211_AUTHTYPE_MAX: nl80211_auth_type = 7;
pub const nl80211_auth_type_NL80211_AUTHTYPE_AUTOMATIC: nl80211_auth_type = 8;
#[doc = " enum nl80211_auth_type - AuthenticationType"]
#[doc = ""]
#[doc = " @NL80211_AUTHTYPE_OPEN_SYSTEM: Open System authentication"]
#[doc = " @NL80211_AUTHTYPE_SHARED_KEY: Shared Key authentication (WEP only)"]
#[doc = " @NL80211_AUTHTYPE_FT: Fast BSS Transition (IEEE 802.11r)"]
#[doc = " @NL80211_AUTHTYPE_NETWORK_EAP: Network EAP (some Cisco APs and mainly LEAP)"]
#[doc = " @NL80211_AUTHTYPE_SAE: Simultaneous authentication of equals"]
#[doc = " @NL80211_AUTHTYPE_FILS_SK: Fast Initial Link Setup shared key"]
#[doc = " @NL80211_AUTHTYPE_FILS_SK_PFS: Fast Initial Link Setup shared key with PFS"]
#[doc = " @NL80211_AUTHTYPE_FILS_PK: Fast Initial Link Setup public key"]
#[doc = " @__NL80211_AUTHTYPE_NUM: internal"]
#[doc = " @NL80211_AUTHTYPE_MAX: maximum valid auth algorithm"]
#[doc = " @NL80211_AUTHTYPE_AUTOMATIC: determine automatically (if necessary by"]
#[doc = "\ttrying multiple times); this is invalid in netlink -- leave out"]
#[doc = "\tthe attribute for this on CONNECT commands."]
pub type nl80211_auth_type = ::std::os::raw::c_uint;
pub const nl80211_key_type_NL80211_KEYTYPE_GROUP: nl80211_key_type = 0;
pub const nl80211_key_type_NL80211_KEYTYPE_PAIRWISE: nl80211_key_type = 1;
pub const nl80211_key_type_NL80211_KEYTYPE_PEERKEY: nl80211_key_type = 2;
pub const nl80211_key_type_NUM_NL80211_KEYTYPES: nl80211_key_type = 3;
#[doc = " enum nl80211_key_type - Key Type"]
#[doc = " @NL80211_KEYTYPE_GROUP: Group (broadcast/multicast) key"]
#[doc = " @NL80211_KEYTYPE_PAIRWISE: Pairwise (unicast/individual) key"]
#[doc = " @NL80211_KEYTYPE_PEERKEY: PeerKey (DLS)"]
#[doc = " @NUM_NL80211_KEYTYPES: number of defined key types"]
pub type nl80211_key_type = ::std::os::raw::c_uint;
pub const nl80211_mfp_NL80211_MFP_NO: nl80211_mfp = 0;
pub const nl80211_mfp_NL80211_MFP_REQUIRED: nl80211_mfp = 1;
pub const nl80211_mfp_NL80211_MFP_OPTIONAL: nl80211_mfp = 2;
#[doc = " enum nl80211_mfp - Management frame protection state"]
#[doc = " @NL80211_MFP_NO: Management frame protection not used"]
#[doc = " @NL80211_MFP_REQUIRED: Management frame protection required"]
#[doc = " @NL80211_MFP_OPTIONAL: Management frame protection is optional"]
pub type nl80211_mfp = ::std::os::raw::c_uint;
pub const nl80211_wpa_versions_NL80211_WPA_VERSION_1: nl80211_wpa_versions = 1;
pub const nl80211_wpa_versions_NL80211_WPA_VERSION_2: nl80211_wpa_versions = 2;
pub const nl80211_wpa_versions_NL80211_WPA_VERSION_3: nl80211_wpa_versions = 4;
pub type nl80211_wpa_versions = ::std::os::raw::c_uint;
pub const nl80211_key_default_types___NL80211_KEY_DEFAULT_TYPE_INVALID: nl80211_key_default_types =
    0;
pub const nl80211_key_default_types_NL80211_KEY_DEFAULT_TYPE_UNICAST: nl80211_key_default_types = 1;
pub const nl80211_key_default_types_NL80211_KEY_DEFAULT_TYPE_MULTICAST: nl80211_key_default_types =
    2;
pub const nl80211_key_default_types_NUM_NL80211_KEY_DEFAULT_TYPES: nl80211_key_default_types = 3;
#[doc = " enum nl80211_key_default_types - key default types"]
#[doc = " @__NL80211_KEY_DEFAULT_TYPE_INVALID: invalid"]
#[doc = " @NL80211_KEY_DEFAULT_TYPE_UNICAST: key should be used as default"]
#[doc = "\tunicast key"]
#[doc = " @NL80211_KEY_DEFAULT_TYPE_MULTICAST: key should be used as default"]
#[doc = "\tmulticast key"]
#[doc = " @NUM_NL80211_KEY_DEFAULT_TYPES: number of default types"]
pub type nl80211_key_default_types = ::std::os::raw::c_uint;
pub const nl80211_key_attributes___NL80211_KEY_INVALID: nl80211_key_attributes = 0;
pub const nl80211_key_attributes_NL80211_KEY_DATA: nl80211_key_attributes = 1;
pub const nl80211_key_attributes_NL80211_KEY_IDX: nl80211_key_attributes = 2;
pub const nl80211_key_attributes_NL80211_KEY_CIPHER: nl80211_key_attributes = 3;
pub const nl80211_key_attributes_NL80211_KEY_SEQ: nl80211_key_attributes = 4;
pub const nl80211_key_attributes_NL80211_KEY_DEFAULT: nl80211_key_attributes = 5;
pub const nl80211_key_attributes_NL80211_KEY_DEFAULT_MGMT: nl80211_key_attributes = 6;
pub const nl80211_key_attributes_NL80211_KEY_TYPE: nl80211_key_attributes = 7;
pub const nl80211_key_attributes_NL80211_KEY_DEFAULT_TYPES: nl80211_key_attributes = 8;
pub const nl80211_key_attributes_NL80211_KEY_MODE: nl80211_key_attributes = 9;
pub const nl80211_key_attributes_NL80211_KEY_DEFAULT_BEACON: nl80211_key_attributes = 10;
pub const nl80211_key_attributes___NL80211_KEY_AFTER_LAST: nl80211_key_attributes = 11;
pub const nl80211_key_attributes_NL80211_KEY_MAX: nl80211_key_attributes = 10;
#[doc = " enum nl80211_key_attributes - key attributes"]
#[doc = " @__NL80211_KEY_INVALID: invalid"]
#[doc = " @NL80211_KEY_DATA: (temporal) key data; for TKIP this consists of"]
#[doc = "\t16 bytes encryption key followed by 8 bytes each for TX and RX MIC"]
#[doc = "\tkeys"]
#[doc = " @NL80211_KEY_IDX: key ID (u8, 0-3)"]
#[doc = " @NL80211_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11"]
#[doc = "\tsection 7.3.2.25.1, e.g. 0x000FAC04)"]
#[doc = " @NL80211_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and"]
#[doc = "\tCCMP keys, each six bytes in little endian"]
#[doc = " @NL80211_KEY_DEFAULT: flag indicating default key"]
#[doc = " @NL80211_KEY_DEFAULT_MGMT: flag indicating default management key"]
#[doc = " @NL80211_KEY_TYPE: the key type from enum nl80211_key_type, if not"]
#[doc = "\tspecified the default depends on whether a MAC address was"]
#[doc = "\tgiven with the command using the key or not (u32)"]
#[doc = " @NL80211_KEY_DEFAULT_TYPES: A nested attribute containing flags"]
#[doc = "\tattributes, specifying what a key should be set as default as."]
#[doc = "\tSee &enum nl80211_key_default_types."]
#[doc = " @NL80211_KEY_MODE: the mode from enum nl80211_key_mode."]
#[doc = "\tDefaults to @NL80211_KEY_RX_TX."]
#[doc = " @NL80211_KEY_DEFAULT_BEACON: flag indicating default Beacon frame key"]
#[doc = ""]
#[doc = " @__NL80211_KEY_AFTER_LAST: internal"]
#[doc = " @NL80211_KEY_MAX: highest key attribute"]
pub type nl80211_key_attributes = ::std::os::raw::c_uint;
pub const nl80211_tx_rate_attributes___NL80211_TXRATE_INVALID: nl80211_tx_rate_attributes = 0;
pub const nl80211_tx_rate_attributes_NL80211_TXRATE_LEGACY: nl80211_tx_rate_attributes = 1;
pub const nl80211_tx_rate_attributes_NL80211_TXRATE_HT: nl80211_tx_rate_attributes = 2;
pub const nl80211_tx_rate_attributes_NL80211_TXRATE_VHT: nl80211_tx_rate_attributes = 3;
pub const nl80211_tx_rate_attributes_NL80211_TXRATE_GI: nl80211_tx_rate_attributes = 4;
pub const nl80211_tx_rate_attributes_NL80211_TXRATE_HE: nl80211_tx_rate_attributes = 5;
pub const nl80211_tx_rate_attributes_NL80211_TXRATE_HE_GI: nl80211_tx_rate_attributes = 6;
pub const nl80211_tx_rate_attributes_NL80211_TXRATE_HE_LTF: nl80211_tx_rate_attributes = 7;
pub const nl80211_tx_rate_attributes___NL80211_TXRATE_AFTER_LAST: nl80211_tx_rate_attributes = 8;
pub const nl80211_tx_rate_attributes_NL80211_TXRATE_MAX: nl80211_tx_rate_attributes = 7;
#[doc = " enum nl80211_tx_rate_attributes - TX rate set attributes"]
#[doc = " @__NL80211_TXRATE_INVALID: invalid"]
#[doc = " @NL80211_TXRATE_LEGACY: Legacy (non-MCS) rates allowed for TX rate selection"]
#[doc = "\tin an array of rates as defined in IEEE 802.11 7.3.2.2 (u8 values with"]
#[doc = "\t1 = 500 kbps) but without the IE length restriction (at most"]
#[doc = "\t%NL80211_MAX_SUPP_RATES in a single array)."]
#[doc = " @NL80211_TXRATE_HT: HT (MCS) rates allowed for TX rate selection"]
#[doc = "\tin an array of MCS numbers."]
#[doc = " @NL80211_TXRATE_VHT: VHT rates allowed for TX rate selection,"]
#[doc = "\tsee &struct nl80211_txrate_vht"]
#[doc = " @NL80211_TXRATE_GI: configure GI, see &enum nl80211_txrate_gi"]
#[doc = " @NL80211_TXRATE_HE: HE rates allowed for TX rate selection,"]
#[doc = "\tsee &struct nl80211_txrate_he"]
#[doc = " @NL80211_TXRATE_HE_GI: configure HE GI, 0.8us, 1.6us and 3.2us."]
#[doc = " @NL80211_TXRATE_HE_LTF: configure HE LTF, 1XLTF, 2XLTF and 4XLTF."]
#[doc = " @__NL80211_TXRATE_AFTER_LAST: internal"]
#[doc = " @NL80211_TXRATE_MAX: highest TX rate attribute"]
pub type nl80211_tx_rate_attributes = ::std::os::raw::c_uint;
#[doc = " struct nl80211_txrate_vht - VHT MCS/NSS txrate bitmap"]
#[doc = " @mcs: MCS bitmap table for each NSS (array index 0 for 1 stream, etc.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_txrate_vht {
    pub mcs: [__u16; 8usize],
}
#[test]
fn bindgen_test_layout_nl80211_txrate_vht() {
    assert_eq!(
        ::std::mem::size_of::<nl80211_txrate_vht>(),
        16usize,
        concat!("Size of: ", stringify!(nl80211_txrate_vht))
    );
    assert_eq!(
        ::std::mem::align_of::<nl80211_txrate_vht>(),
        2usize,
        concat!("Alignment of ", stringify!(nl80211_txrate_vht))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl80211_txrate_vht>())).mcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_txrate_vht),
            "::",
            stringify!(mcs)
        )
    );
}
#[doc = " struct nl80211_txrate_he - HE MCS/NSS txrate bitmap"]
#[doc = " @mcs: MCS bitmap table for each NSS (array index 0 for 1 stream, etc.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_txrate_he {
    pub mcs: [__u16; 8usize],
}
#[test]
fn bindgen_test_layout_nl80211_txrate_he() {
    assert_eq!(
        ::std::mem::size_of::<nl80211_txrate_he>(),
        16usize,
        concat!("Size of: ", stringify!(nl80211_txrate_he))
    );
    assert_eq!(
        ::std::mem::align_of::<nl80211_txrate_he>(),
        2usize,
        concat!("Alignment of ", stringify!(nl80211_txrate_he))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl80211_txrate_he>())).mcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_txrate_he),
            "::",
            stringify!(mcs)
        )
    );
}
pub const nl80211_txrate_gi_NL80211_TXRATE_DEFAULT_GI: nl80211_txrate_gi = 0;
pub const nl80211_txrate_gi_NL80211_TXRATE_FORCE_SGI: nl80211_txrate_gi = 1;
pub const nl80211_txrate_gi_NL80211_TXRATE_FORCE_LGI: nl80211_txrate_gi = 2;
pub type nl80211_txrate_gi = ::std::os::raw::c_uint;
pub const nl80211_band_NL80211_BAND_2GHZ: nl80211_band = 0;
pub const nl80211_band_NL80211_BAND_5GHZ: nl80211_band = 1;
pub const nl80211_band_NL80211_BAND_60GHZ: nl80211_band = 2;
pub const nl80211_band_NL80211_BAND_6GHZ: nl80211_band = 3;
pub const nl80211_band_NL80211_BAND_S1GHZ: nl80211_band = 4;
pub const nl80211_band_NUM_NL80211_BANDS: nl80211_band = 5;
#[doc = " enum nl80211_band - Frequency band"]
#[doc = " @NL80211_BAND_2GHZ: 2.4 GHz ISM band"]
#[doc = " @NL80211_BAND_5GHZ: around 5 GHz band (4.9 - 5.7 GHz)"]
#[doc = " @NL80211_BAND_60GHZ: around 60 GHz band (58.32 - 69.12 GHz)"]
#[doc = " @NL80211_BAND_6GHZ: around 6 GHz band (5.9 - 7.2 GHz)"]
#[doc = " @NL80211_BAND_S1GHZ: around 900MHz, supported by S1G PHYs"]
#[doc = " @NUM_NL80211_BANDS: number of bands, avoid using this in userspace"]
#[doc = "\tsince newer kernel versions may support more bands"]
pub type nl80211_band = ::std::os::raw::c_uint;
pub const nl80211_ps_state_NL80211_PS_DISABLED: nl80211_ps_state = 0;
pub const nl80211_ps_state_NL80211_PS_ENABLED: nl80211_ps_state = 1;
#[doc = " enum nl80211_ps_state - powersave state"]
#[doc = " @NL80211_PS_DISABLED: powersave is disabled"]
#[doc = " @NL80211_PS_ENABLED: powersave is enabled"]
pub type nl80211_ps_state = ::std::os::raw::c_uint;
pub const nl80211_attr_cqm___NL80211_ATTR_CQM_INVALID: nl80211_attr_cqm = 0;
pub const nl80211_attr_cqm_NL80211_ATTR_CQM_RSSI_THOLD: nl80211_attr_cqm = 1;
pub const nl80211_attr_cqm_NL80211_ATTR_CQM_RSSI_HYST: nl80211_attr_cqm = 2;
pub const nl80211_attr_cqm_NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT: nl80211_attr_cqm = 3;
pub const nl80211_attr_cqm_NL80211_ATTR_CQM_PKT_LOSS_EVENT: nl80211_attr_cqm = 4;
pub const nl80211_attr_cqm_NL80211_ATTR_CQM_TXE_RATE: nl80211_attr_cqm = 5;
pub const nl80211_attr_cqm_NL80211_ATTR_CQM_TXE_PKTS: nl80211_attr_cqm = 6;
pub const nl80211_attr_cqm_NL80211_ATTR_CQM_TXE_INTVL: nl80211_attr_cqm = 7;
pub const nl80211_attr_cqm_NL80211_ATTR_CQM_BEACON_LOSS_EVENT: nl80211_attr_cqm = 8;
pub const nl80211_attr_cqm_NL80211_ATTR_CQM_RSSI_LEVEL: nl80211_attr_cqm = 9;
pub const nl80211_attr_cqm___NL80211_ATTR_CQM_AFTER_LAST: nl80211_attr_cqm = 10;
pub const nl80211_attr_cqm_NL80211_ATTR_CQM_MAX: nl80211_attr_cqm = 9;
#[doc = " enum nl80211_attr_cqm - connection quality monitor attributes"]
#[doc = " @__NL80211_ATTR_CQM_INVALID: invalid"]
#[doc = " @NL80211_ATTR_CQM_RSSI_THOLD: RSSI threshold in dBm. This value specifies"]
#[doc = "\tthe threshold for the RSSI level at which an event will be sent. Zero"]
#[doc = "\tto disable.  Alternatively, if %NL80211_EXT_FEATURE_CQM_RSSI_LIST is"]
#[doc = "\tset, multiple values can be supplied as a low-to-high sorted array of"]
#[doc = "\tthreshold values in dBm.  Events will be sent when the RSSI value"]
#[doc = "\tcrosses any of the thresholds."]
#[doc = " @NL80211_ATTR_CQM_RSSI_HYST: RSSI hysteresis in dBm. This value specifies"]
#[doc = "\tthe minimum amount the RSSI level must change after an event before a"]
#[doc = "\tnew event may be issued (to reduce effects of RSSI oscillation)."]
#[doc = " @NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT: RSSI threshold event"]
#[doc = " @NL80211_ATTR_CQM_PKT_LOSS_EVENT: a u32 value indicating that this many"]
#[doc = "\tconsecutive packets were not acknowledged by the peer"]
#[doc = " @NL80211_ATTR_CQM_TXE_RATE: TX error rate in %. Minimum % of TX failures"]
#[doc = "\tduring the given %NL80211_ATTR_CQM_TXE_INTVL before an"]
#[doc = "\t%NL80211_CMD_NOTIFY_CQM with reported %NL80211_ATTR_CQM_TXE_RATE and"]
#[doc = "\t%NL80211_ATTR_CQM_TXE_PKTS is generated."]
#[doc = " @NL80211_ATTR_CQM_TXE_PKTS: number of attempted packets in a given"]
#[doc = "\t%NL80211_ATTR_CQM_TXE_INTVL before %NL80211_ATTR_CQM_TXE_RATE is"]
#[doc = "\tchecked."]
#[doc = " @NL80211_ATTR_CQM_TXE_INTVL: interval in seconds. Specifies the periodic"]
#[doc = "\tinterval in which %NL80211_ATTR_CQM_TXE_PKTS and"]
#[doc = "\t%NL80211_ATTR_CQM_TXE_RATE must be satisfied before generating an"]
#[doc = "\t%NL80211_CMD_NOTIFY_CQM. Set to 0 to turn off TX error reporting."]
#[doc = " @NL80211_ATTR_CQM_BEACON_LOSS_EVENT: flag attribute that's set in a beacon"]
#[doc = "\tloss event"]
#[doc = " @NL80211_ATTR_CQM_RSSI_LEVEL: the RSSI value in dBm that triggered the"]
#[doc = "\tRSSI threshold event."]
#[doc = " @__NL80211_ATTR_CQM_AFTER_LAST: internal"]
#[doc = " @NL80211_ATTR_CQM_MAX: highest key attribute"]
pub type nl80211_attr_cqm = ::std::os::raw::c_uint;
pub const nl80211_cqm_rssi_threshold_event_NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW:
    nl80211_cqm_rssi_threshold_event = 0;
pub const nl80211_cqm_rssi_threshold_event_NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH:
    nl80211_cqm_rssi_threshold_event = 1;
pub const nl80211_cqm_rssi_threshold_event_NL80211_CQM_RSSI_BEACON_LOSS_EVENT:
    nl80211_cqm_rssi_threshold_event = 2;
#[doc = " enum nl80211_cqm_rssi_threshold_event - RSSI threshold event"]
#[doc = " @NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW: The RSSI level is lower than the"]
#[doc = "      configured threshold"]
#[doc = " @NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH: The RSSI is higher than the"]
#[doc = "      configured threshold"]
#[doc = " @NL80211_CQM_RSSI_BEACON_LOSS_EVENT: (reserved, never sent)"]
pub type nl80211_cqm_rssi_threshold_event = ::std::os::raw::c_uint;
pub const nl80211_tx_power_setting_NL80211_TX_POWER_AUTOMATIC: nl80211_tx_power_setting = 0;
pub const nl80211_tx_power_setting_NL80211_TX_POWER_LIMITED: nl80211_tx_power_setting = 1;
pub const nl80211_tx_power_setting_NL80211_TX_POWER_FIXED: nl80211_tx_power_setting = 2;
#[doc = " enum nl80211_tx_power_setting - TX power adjustment"]
#[doc = " @NL80211_TX_POWER_AUTOMATIC: automatically determine transmit power"]
#[doc = " @NL80211_TX_POWER_LIMITED: limit TX power by the mBm parameter"]
#[doc = " @NL80211_TX_POWER_FIXED: fix TX power to the mBm parameter"]
pub type nl80211_tx_power_setting = ::std::os::raw::c_uint;
pub const nl80211_tid_config_NL80211_TID_CONFIG_ENABLE: nl80211_tid_config = 0;
pub const nl80211_tid_config_NL80211_TID_CONFIG_DISABLE: nl80211_tid_config = 1;
#[doc = " enum nl80211_tid_config - TID config state"]
#[doc = " @NL80211_TID_CONFIG_ENABLE: Enable config for the TID"]
#[doc = " @NL80211_TID_CONFIG_DISABLE: Disable config for the TID"]
pub type nl80211_tid_config = ::std::os::raw::c_uint;
pub const nl80211_tx_rate_setting_NL80211_TX_RATE_AUTOMATIC: nl80211_tx_rate_setting = 0;
pub const nl80211_tx_rate_setting_NL80211_TX_RATE_LIMITED: nl80211_tx_rate_setting = 1;
pub const nl80211_tx_rate_setting_NL80211_TX_RATE_FIXED: nl80211_tx_rate_setting = 2;
pub type nl80211_tx_rate_setting = ::std::os::raw::c_uint;
pub const nl80211_tid_config_attr___NL80211_TID_CONFIG_ATTR_INVALID: nl80211_tid_config_attr = 0;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_PAD: nl80211_tid_config_attr = 1;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_VIF_SUPP: nl80211_tid_config_attr = 2;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_PEER_SUPP: nl80211_tid_config_attr = 3;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_OVERRIDE: nl80211_tid_config_attr = 4;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_TIDS: nl80211_tid_config_attr = 5;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_NOACK: nl80211_tid_config_attr = 6;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_RETRY_SHORT: nl80211_tid_config_attr = 7;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_RETRY_LONG: nl80211_tid_config_attr = 8;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_AMPDU_CTRL: nl80211_tid_config_attr = 9;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL: nl80211_tid_config_attr = 10;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_AMSDU_CTRL: nl80211_tid_config_attr = 11;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE: nl80211_tid_config_attr =
    12;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_TX_RATE: nl80211_tid_config_attr = 13;
pub const nl80211_tid_config_attr___NL80211_TID_CONFIG_ATTR_AFTER_LAST: nl80211_tid_config_attr =
    14;
pub const nl80211_tid_config_attr_NL80211_TID_CONFIG_ATTR_MAX: nl80211_tid_config_attr = 13;
pub type nl80211_tid_config_attr = ::std::os::raw::c_uint;
pub const nl80211_packet_pattern_attr___NL80211_PKTPAT_INVALID: nl80211_packet_pattern_attr = 0;
pub const nl80211_packet_pattern_attr_NL80211_PKTPAT_MASK: nl80211_packet_pattern_attr = 1;
pub const nl80211_packet_pattern_attr_NL80211_PKTPAT_PATTERN: nl80211_packet_pattern_attr = 2;
pub const nl80211_packet_pattern_attr_NL80211_PKTPAT_OFFSET: nl80211_packet_pattern_attr = 3;
pub const nl80211_packet_pattern_attr_NUM_NL80211_PKTPAT: nl80211_packet_pattern_attr = 4;
pub const nl80211_packet_pattern_attr_MAX_NL80211_PKTPAT: nl80211_packet_pattern_attr = 3;
#[doc = " enum nl80211_packet_pattern_attr - packet pattern attribute"]
#[doc = " @__NL80211_PKTPAT_INVALID: invalid number for nested attribute"]
#[doc = " @NL80211_PKTPAT_PATTERN: the pattern, values where the mask has"]
#[doc = "\ta zero bit are ignored"]
#[doc = " @NL80211_PKTPAT_MASK: pattern mask, must be long enough to have"]
#[doc = "\ta bit for each byte in the pattern. The lowest-order bit corresponds"]
#[doc = "\tto the first byte of the pattern, but the bytes of the pattern are"]
#[doc = "\tin a little-endian-like format, i.e. the 9th byte of the pattern"]
#[doc = "\tcorresponds to the lowest-order bit in the second byte of the mask."]
#[doc = "\tFor example: The match 00:xx:00:00:xx:00:00:00:00:xx:xx:xx (where"]
#[doc = "\txx indicates \"don't care\") would be represented by a pattern of"]
#[doc = "\ttwelve zero bytes, and a mask of \"0xed,0x01\"."]
#[doc = "\tNote that the pattern matching is done as though frames were not"]
#[doc = "\t802.11 frames but 802.3 frames, i.e. the frame is fully unpacked"]
#[doc = "\tfirst (including SNAP header unpacking) and then matched."]
#[doc = " @NL80211_PKTPAT_OFFSET: packet offset, pattern is matched after"]
#[doc = "\tthese fixed number of bytes of received packet"]
#[doc = " @NUM_NL80211_PKTPAT: number of attributes"]
#[doc = " @MAX_NL80211_PKTPAT: max attribute number"]
pub type nl80211_packet_pattern_attr = ::std::os::raw::c_uint;
#[doc = " struct nl80211_pattern_support - packet pattern support information"]
#[doc = " @max_patterns: maximum number of patterns supported"]
#[doc = " @min_pattern_len: minimum length of each pattern"]
#[doc = " @max_pattern_len: maximum length of each pattern"]
#[doc = " @max_pkt_offset: maximum Rx packet offset"]
#[doc = ""]
#[doc = " This struct is carried in %NL80211_WOWLAN_TRIG_PKT_PATTERN when"]
#[doc = " that is part of %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED or in"]
#[doc = " %NL80211_ATTR_COALESCE_RULE_PKT_PATTERN when that is part of"]
#[doc = " %NL80211_ATTR_COALESCE_RULE in the capability information given"]
#[doc = " by the kernel to userspace."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_pattern_support {
    pub max_patterns: __u32,
    pub min_pattern_len: __u32,
    pub max_pattern_len: __u32,
    pub max_pkt_offset: __u32,
}
#[test]
fn bindgen_test_layout_nl80211_pattern_support() {
    assert_eq!(
        ::std::mem::size_of::<nl80211_pattern_support>(),
        16usize,
        concat!("Size of: ", stringify!(nl80211_pattern_support))
    );
    assert_eq!(
        ::std::mem::align_of::<nl80211_pattern_support>(),
        1usize,
        concat!("Alignment of ", stringify!(nl80211_pattern_support))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_pattern_support>())).max_patterns as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_pattern_support),
            "::",
            stringify!(max_patterns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_pattern_support>())).min_pattern_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_pattern_support),
            "::",
            stringify!(min_pattern_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_pattern_support>())).max_pattern_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_pattern_support),
            "::",
            stringify!(max_pattern_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_pattern_support>())).max_pkt_offset as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_pattern_support),
            "::",
            stringify!(max_pkt_offset)
        )
    );
}
pub const nl80211_wowlan_triggers___NL80211_WOWLAN_TRIG_INVALID: nl80211_wowlan_triggers = 0;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_ANY: nl80211_wowlan_triggers = 1;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_DISCONNECT: nl80211_wowlan_triggers = 2;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_MAGIC_PKT: nl80211_wowlan_triggers = 3;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_PKT_PATTERN: nl80211_wowlan_triggers = 4;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED: nl80211_wowlan_triggers =
    5;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE: nl80211_wowlan_triggers =
    6;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST: nl80211_wowlan_triggers =
    7;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE: nl80211_wowlan_triggers = 8;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_RFKILL_RELEASE: nl80211_wowlan_triggers = 9;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211: nl80211_wowlan_triggers =
    10;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN:
    nl80211_wowlan_triggers = 11;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023: nl80211_wowlan_triggers = 12;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN: nl80211_wowlan_triggers =
    13;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_TCP_CONNECTION: nl80211_wowlan_triggers = 14;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH: nl80211_wowlan_triggers =
    15;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST: nl80211_wowlan_triggers =
    16;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS:
    nl80211_wowlan_triggers = 17;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_NET_DETECT: nl80211_wowlan_triggers = 18;
pub const nl80211_wowlan_triggers_NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS: nl80211_wowlan_triggers =
    19;
pub const nl80211_wowlan_triggers_NUM_NL80211_WOWLAN_TRIG: nl80211_wowlan_triggers = 20;
pub const nl80211_wowlan_triggers_MAX_NL80211_WOWLAN_TRIG: nl80211_wowlan_triggers = 19;
#[doc = " enum nl80211_wowlan_triggers - WoWLAN trigger definitions"]
#[doc = " @__NL80211_WOWLAN_TRIG_INVALID: invalid number for nested attributes"]
#[doc = " @NL80211_WOWLAN_TRIG_ANY: wake up on any activity, do not really put"]
#[doc = "\tthe chip into a special state -- works best with chips that have"]
#[doc = "\tsupport for low-power operation already (flag)"]
#[doc = "\tNote that this mode is incompatible with all of the others, if"]
#[doc = "\tany others are even supported by the device."]
#[doc = " @NL80211_WOWLAN_TRIG_DISCONNECT: wake up on disconnect, the way disconnect"]
#[doc = "\tis detected is implementation-specific (flag)"]
#[doc = " @NL80211_WOWLAN_TRIG_MAGIC_PKT: wake up on magic packet (6x 0xff, followed"]
#[doc = "\tby 16 repetitions of MAC addr, anywhere in payload) (flag)"]
#[doc = " @NL80211_WOWLAN_TRIG_PKT_PATTERN: wake up on the specified packet patterns"]
#[doc = "\twhich are passed in an array of nested attributes, each nested attribute"]
#[doc = "\tdefining a with attributes from &struct nl80211_wowlan_trig_pkt_pattern."]
#[doc = "\tEach pattern defines a wakeup packet. Packet offset is associated with"]
#[doc = "\teach pattern which is used while matching the pattern. The matching is"]
#[doc = "\tdone on the MSDU, i.e. as though the packet was an 802.3 packet, so the"]
#[doc = "\tpattern matching is done after the packet is converted to the MSDU."]
#[doc = ""]
#[doc = "\tIn %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED, it is a binary attribute"]
#[doc = "\tcarrying a &struct nl80211_pattern_support."]
#[doc = ""]
#[doc = "\tWhen reporting wakeup. it is a u32 attribute containing the 0-based"]
#[doc = "\tindex of the pattern that caused the wakeup, in the patterns passed"]
#[doc = "\tto the kernel when configuring."]
#[doc = " @NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED: Not a real trigger, and cannot be"]
#[doc = "\tused when setting, used only to indicate that GTK rekeying is supported"]
#[doc = "\tby the device (flag)"]
#[doc = " @NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE: wake up on GTK rekey failure (if"]
#[doc = "\tdone by the device) (flag)"]
#[doc = " @NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST: wake up on EAP Identity Request"]
#[doc = "\tpacket (flag)"]
#[doc = " @NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE: wake up on 4-way handshake (flag)"]
#[doc = " @NL80211_WOWLAN_TRIG_RFKILL_RELEASE: wake up when rfkill is released"]
#[doc = "\t(on devices that have rfkill in the device) (flag)"]
#[doc = " @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211: For wakeup reporting only, contains"]
#[doc = "\tthe 802.11 packet that caused the wakeup, e.g. a deauth frame. The frame"]
#[doc = "\tmay be truncated, the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN"]
#[doc = "\tattribute contains the original length."]
#[doc = " @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN: Original length of the 802.11"]
#[doc = "\tpacket, may be bigger than the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211"]
#[doc = "\tattribute if the packet was truncated somewhere."]
#[doc = " @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023: For wakeup reporting only, contains the"]
#[doc = "\t802.11 packet that caused the wakeup, e.g. a magic packet. The frame may"]
#[doc = "\tbe truncated, the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN attribute"]
#[doc = "\tcontains the original length."]
#[doc = " @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN: Original length of the 802.3"]
#[doc = "\tpacket, may be bigger than the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023"]
#[doc = "\tattribute if the packet was truncated somewhere."]
#[doc = " @NL80211_WOWLAN_TRIG_TCP_CONNECTION: TCP connection wake, see DOC section"]
#[doc = "\t\"TCP connection wakeup\" for more details. This is a nested attribute"]
#[doc = "\tcontaining the exact information for establishing and keeping alive"]
#[doc = "\tthe TCP connection."]
#[doc = " @NL80211_WOWLAN_TRIG_TCP_WAKEUP_MATCH: For wakeup reporting only, the"]
#[doc = "\twakeup packet was received on the TCP connection"]
#[doc = " @NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST: For wakeup reporting only, the"]
#[doc = "\tTCP connection was lost or failed to be established"]
#[doc = " @NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS: For wakeup reporting only,"]
#[doc = "\tthe TCP connection ran out of tokens to use for data to send to the"]
#[doc = "\tservice"]
#[doc = " @NL80211_WOWLAN_TRIG_NET_DETECT: wake up when a configured network"]
#[doc = "\tis detected.  This is a nested attribute that contains the"]
#[doc = "\tsame attributes used with @NL80211_CMD_START_SCHED_SCAN.  It"]
#[doc = "\tspecifies how the scan is performed (e.g. the interval, the"]
#[doc = "\tchannels to scan and the initial delay) as well as the scan"]
#[doc = "\tresults that will trigger a wake (i.e. the matchsets).  This"]
#[doc = "\tattribute is also sent in a response to"]
#[doc = "\t@NL80211_CMD_GET_WIPHY, indicating the number of match sets"]
#[doc = "\tsupported by the driver (u32)."]
#[doc = " @NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS: nested attribute"]
#[doc = "\tcontaining an array with information about what triggered the"]
#[doc = "\twake up.  If no elements are present in the array, it means"]
#[doc = "\tthat the information is not available.  If more than one"]
#[doc = "\telement is present, it means that more than one match"]
#[doc = "\toccurred."]
#[doc = "\tEach element in the array is a nested attribute that contains"]
#[doc = "\tone optional %NL80211_ATTR_SSID attribute and one optional"]
#[doc = "\t%NL80211_ATTR_SCAN_FREQUENCIES attribute.  At least one of"]
#[doc = "\tthese attributes must be present.  If"]
#[doc = "\t%NL80211_ATTR_SCAN_FREQUENCIES contains more than one"]
#[doc = "\tfrequency, it means that the match occurred in more than one"]
#[doc = "\tchannel."]
#[doc = " @NUM_NL80211_WOWLAN_TRIG: number of wake on wireless triggers"]
#[doc = " @MAX_NL80211_WOWLAN_TRIG: highest wowlan trigger attribute number"]
#[doc = ""]
#[doc = " These nested attributes are used to configure the wakeup triggers and"]
#[doc = " to report the wakeup reason(s)."]
pub type nl80211_wowlan_triggers = ::std::os::raw::c_uint;
#[doc = " struct nl80211_wowlan_tcp_data_seq - WoWLAN TCP data sequence"]
#[doc = " @start: starting value"]
#[doc = " @offset: offset of sequence number in packet"]
#[doc = " @len: length of the sequence value to write, 1 through 4"]
#[doc = ""]
#[doc = " Note: don't confuse with the TCP sequence number(s), this is for the"]
#[doc = " keepalive packet payload. The actual value is written into the packet"]
#[doc = " in little endian."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_wowlan_tcp_data_seq {
    pub start: __u32,
    pub offset: __u32,
    pub len: __u32,
}
#[test]
fn bindgen_test_layout_nl80211_wowlan_tcp_data_seq() {
    assert_eq!(
        ::std::mem::size_of::<nl80211_wowlan_tcp_data_seq>(),
        12usize,
        concat!("Size of: ", stringify!(nl80211_wowlan_tcp_data_seq))
    );
    assert_eq!(
        ::std::mem::align_of::<nl80211_wowlan_tcp_data_seq>(),
        4usize,
        concat!("Alignment of ", stringify!(nl80211_wowlan_tcp_data_seq))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_wowlan_tcp_data_seq>())).start as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_wowlan_tcp_data_seq),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_wowlan_tcp_data_seq>())).offset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_wowlan_tcp_data_seq),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl80211_wowlan_tcp_data_seq>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_wowlan_tcp_data_seq),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " struct nl80211_wowlan_tcp_data_token - WoWLAN TCP data token config"]
#[doc = " @offset: offset of token in packet"]
#[doc = " @len: length of each token"]
#[doc = " @token_stream: stream of data to be used for the tokens, the length must"]
#[doc = "\tbe a multiple of @len for this to make sense"]
#[repr(C)]
#[derive(Debug)]
pub struct nl80211_wowlan_tcp_data_token {
    pub offset: __u32,
    pub len: __u32,
    pub token_stream: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_nl80211_wowlan_tcp_data_token() {
    assert_eq!(
        ::std::mem::size_of::<nl80211_wowlan_tcp_data_token>(),
        8usize,
        concat!("Size of: ", stringify!(nl80211_wowlan_tcp_data_token))
    );
    assert_eq!(
        ::std::mem::align_of::<nl80211_wowlan_tcp_data_token>(),
        4usize,
        concat!("Alignment of ", stringify!(nl80211_wowlan_tcp_data_token))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_wowlan_tcp_data_token>())).offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_wowlan_tcp_data_token),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_wowlan_tcp_data_token>())).len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_wowlan_tcp_data_token),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_wowlan_tcp_data_token>())).token_stream as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_wowlan_tcp_data_token),
            "::",
            stringify!(token_stream)
        )
    );
}
#[doc = " struct nl80211_wowlan_tcp_data_token_feature - data token features"]
#[doc = " @min_len: minimum token length"]
#[doc = " @max_len: maximum token length"]
#[doc = " @bufsize: total available token buffer size (max size of @token_stream)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_wowlan_tcp_data_token_feature {
    pub min_len: __u32,
    pub max_len: __u32,
    pub bufsize: __u32,
}
#[test]
fn bindgen_test_layout_nl80211_wowlan_tcp_data_token_feature() {
    assert_eq!(
        ::std::mem::size_of::<nl80211_wowlan_tcp_data_token_feature>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(nl80211_wowlan_tcp_data_token_feature)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<nl80211_wowlan_tcp_data_token_feature>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(nl80211_wowlan_tcp_data_token_feature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_wowlan_tcp_data_token_feature>())).min_len as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_wowlan_tcp_data_token_feature),
            "::",
            stringify!(min_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_wowlan_tcp_data_token_feature>())).max_len as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_wowlan_tcp_data_token_feature),
            "::",
            stringify!(max_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_wowlan_tcp_data_token_feature>())).bufsize as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_wowlan_tcp_data_token_feature),
            "::",
            stringify!(bufsize)
        )
    );
}
pub const nl80211_wowlan_tcp_attrs___NL80211_WOWLAN_TCP_INVALID: nl80211_wowlan_tcp_attrs = 0;
pub const nl80211_wowlan_tcp_attrs_NL80211_WOWLAN_TCP_SRC_IPV4: nl80211_wowlan_tcp_attrs = 1;
pub const nl80211_wowlan_tcp_attrs_NL80211_WOWLAN_TCP_DST_IPV4: nl80211_wowlan_tcp_attrs = 2;
pub const nl80211_wowlan_tcp_attrs_NL80211_WOWLAN_TCP_DST_MAC: nl80211_wowlan_tcp_attrs = 3;
pub const nl80211_wowlan_tcp_attrs_NL80211_WOWLAN_TCP_SRC_PORT: nl80211_wowlan_tcp_attrs = 4;
pub const nl80211_wowlan_tcp_attrs_NL80211_WOWLAN_TCP_DST_PORT: nl80211_wowlan_tcp_attrs = 5;
pub const nl80211_wowlan_tcp_attrs_NL80211_WOWLAN_TCP_DATA_PAYLOAD: nl80211_wowlan_tcp_attrs = 6;
pub const nl80211_wowlan_tcp_attrs_NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ: nl80211_wowlan_tcp_attrs =
    7;
pub const nl80211_wowlan_tcp_attrs_NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN: nl80211_wowlan_tcp_attrs =
    8;
pub const nl80211_wowlan_tcp_attrs_NL80211_WOWLAN_TCP_DATA_INTERVAL: nl80211_wowlan_tcp_attrs = 9;
pub const nl80211_wowlan_tcp_attrs_NL80211_WOWLAN_TCP_WAKE_PAYLOAD: nl80211_wowlan_tcp_attrs = 10;
pub const nl80211_wowlan_tcp_attrs_NL80211_WOWLAN_TCP_WAKE_MASK: nl80211_wowlan_tcp_attrs = 11;
pub const nl80211_wowlan_tcp_attrs_NUM_NL80211_WOWLAN_TCP: nl80211_wowlan_tcp_attrs = 12;
pub const nl80211_wowlan_tcp_attrs_MAX_NL80211_WOWLAN_TCP: nl80211_wowlan_tcp_attrs = 11;
#[doc = " enum nl80211_wowlan_tcp_attrs - WoWLAN TCP connection parameters"]
#[doc = " @__NL80211_WOWLAN_TCP_INVALID: invalid number for nested attributes"]
#[doc = " @NL80211_WOWLAN_TCP_SRC_IPV4: source IPv4 address (in network byte order)"]
#[doc = " @NL80211_WOWLAN_TCP_DST_IPV4: destination IPv4 address"]
#[doc = "\t(in network byte order)"]
#[doc = " @NL80211_WOWLAN_TCP_DST_MAC: destination MAC address, this is given because"]
#[doc = "\troute lookup when configured might be invalid by the time we suspend,"]
#[doc = "\tand doing a route lookup when suspending is no longer possible as it"]
#[doc = "\tmight require ARP querying."]
#[doc = " @NL80211_WOWLAN_TCP_SRC_PORT: source port (u16); optional, if not given a"]
#[doc = "\tsocket and port will be allocated"]
#[doc = " @NL80211_WOWLAN_TCP_DST_PORT: destination port (u16)"]
#[doc = " @NL80211_WOWLAN_TCP_DATA_PAYLOAD: data packet payload, at least one byte."]
#[doc = "\tFor feature advertising, a u32 attribute holding the maximum length"]
#[doc = "\tof the data payload."]
#[doc = " @NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ: data packet sequence configuration"]
#[doc = "\t(if desired), a &struct nl80211_wowlan_tcp_data_seq. For feature"]
#[doc = "\tadvertising it is just a flag"]
#[doc = " @NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN: data packet token configuration,"]
#[doc = "\tsee &struct nl80211_wowlan_tcp_data_token and for advertising see"]
#[doc = "\t&struct nl80211_wowlan_tcp_data_token_feature."]
#[doc = " @NL80211_WOWLAN_TCP_DATA_INTERVAL: data interval in seconds, maximum"]
#[doc = "\tinterval in feature advertising (u32)"]
#[doc = " @NL80211_WOWLAN_TCP_WAKE_PAYLOAD: wake packet payload, for advertising a"]
#[doc = "\tu32 attribute holding the maximum length"]
#[doc = " @NL80211_WOWLAN_TCP_WAKE_MASK: Wake packet payload mask, not used for"]
#[doc = "\tfeature advertising. The mask works like @NL80211_PKTPAT_MASK"]
#[doc = "\tbut on the TCP payload only."]
#[doc = " @NUM_NL80211_WOWLAN_TCP: number of TCP attributes"]
#[doc = " @MAX_NL80211_WOWLAN_TCP: highest attribute number"]
pub type nl80211_wowlan_tcp_attrs = ::std::os::raw::c_uint;
#[doc = " struct nl80211_coalesce_rule_support - coalesce rule support information"]
#[doc = " @max_rules: maximum number of rules supported"]
#[doc = " @pat: packet pattern support information"]
#[doc = " @max_delay: maximum supported coalescing delay in msecs"]
#[doc = ""]
#[doc = " This struct is carried in %NL80211_ATTR_COALESCE_RULE in the"]
#[doc = " capability information given by the kernel to userspace."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_coalesce_rule_support {
    pub max_rules: __u32,
    pub pat: nl80211_pattern_support,
    pub max_delay: __u32,
}
#[test]
fn bindgen_test_layout_nl80211_coalesce_rule_support() {
    assert_eq!(
        ::std::mem::size_of::<nl80211_coalesce_rule_support>(),
        24usize,
        concat!("Size of: ", stringify!(nl80211_coalesce_rule_support))
    );
    assert_eq!(
        ::std::mem::align_of::<nl80211_coalesce_rule_support>(),
        1usize,
        concat!("Alignment of ", stringify!(nl80211_coalesce_rule_support))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_coalesce_rule_support>())).max_rules as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_coalesce_rule_support),
            "::",
            stringify!(max_rules)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_coalesce_rule_support>())).pat as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_coalesce_rule_support),
            "::",
            stringify!(pat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_coalesce_rule_support>())).max_delay as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_coalesce_rule_support),
            "::",
            stringify!(max_delay)
        )
    );
}
pub const nl80211_attr_coalesce_rule___NL80211_COALESCE_RULE_INVALID: nl80211_attr_coalesce_rule =
    0;
pub const nl80211_attr_coalesce_rule_NL80211_ATTR_COALESCE_RULE_DELAY: nl80211_attr_coalesce_rule =
    1;
pub const nl80211_attr_coalesce_rule_NL80211_ATTR_COALESCE_RULE_CONDITION:
    nl80211_attr_coalesce_rule = 2;
pub const nl80211_attr_coalesce_rule_NL80211_ATTR_COALESCE_RULE_PKT_PATTERN:
    nl80211_attr_coalesce_rule = 3;
pub const nl80211_attr_coalesce_rule_NUM_NL80211_ATTR_COALESCE_RULE: nl80211_attr_coalesce_rule = 4;
pub const nl80211_attr_coalesce_rule_NL80211_ATTR_COALESCE_RULE_MAX: nl80211_attr_coalesce_rule = 3;
#[doc = " enum nl80211_attr_coalesce_rule - coalesce rule attribute"]
#[doc = " @__NL80211_COALESCE_RULE_INVALID: invalid number for nested attribute"]
#[doc = " @NL80211_ATTR_COALESCE_RULE_DELAY: delay in msecs used for packet coalescing"]
#[doc = " @NL80211_ATTR_COALESCE_RULE_CONDITION: condition for packet coalescence,"]
#[doc = "\tsee &enum nl80211_coalesce_condition."]
#[doc = " @NL80211_ATTR_COALESCE_RULE_PKT_PATTERN: packet offset, pattern is matched"]
#[doc = "\tafter these fixed number of bytes of received packet"]
#[doc = " @NUM_NL80211_ATTR_COALESCE_RULE: number of attributes"]
#[doc = " @NL80211_ATTR_COALESCE_RULE_MAX: max attribute number"]
pub type nl80211_attr_coalesce_rule = ::std::os::raw::c_uint;
pub const nl80211_coalesce_condition_NL80211_COALESCE_CONDITION_MATCH: nl80211_coalesce_condition =
    0;
pub const nl80211_coalesce_condition_NL80211_COALESCE_CONDITION_NO_MATCH:
    nl80211_coalesce_condition = 1;
#[doc = " enum nl80211_coalesce_condition - coalesce rule conditions"]
#[doc = " @NL80211_COALESCE_CONDITION_MATCH: coalaesce Rx packets when patterns"]
#[doc = "\tin a rule are matched."]
#[doc = " @NL80211_COALESCE_CONDITION_NO_MATCH: coalesce Rx packets when patterns"]
#[doc = "\tin a rule are not matched."]
pub type nl80211_coalesce_condition = ::std::os::raw::c_uint;
pub const nl80211_iface_limit_attrs_NL80211_IFACE_LIMIT_UNSPEC: nl80211_iface_limit_attrs = 0;
pub const nl80211_iface_limit_attrs_NL80211_IFACE_LIMIT_MAX: nl80211_iface_limit_attrs = 1;
pub const nl80211_iface_limit_attrs_NL80211_IFACE_LIMIT_TYPES: nl80211_iface_limit_attrs = 2;
pub const nl80211_iface_limit_attrs_NUM_NL80211_IFACE_LIMIT: nl80211_iface_limit_attrs = 3;
pub const nl80211_iface_limit_attrs_MAX_NL80211_IFACE_LIMIT: nl80211_iface_limit_attrs = 2;
#[doc = " enum nl80211_iface_limit_attrs - limit attributes"]
#[doc = " @NL80211_IFACE_LIMIT_UNSPEC: (reserved)"]
#[doc = " @NL80211_IFACE_LIMIT_MAX: maximum number of interfaces that"]
#[doc = "\tcan be chosen from this set of interface types (u32)"]
#[doc = " @NL80211_IFACE_LIMIT_TYPES: nested attribute containing a"]
#[doc = "\tflag attribute for each interface type in this set"]
#[doc = " @NUM_NL80211_IFACE_LIMIT: number of attributes"]
#[doc = " @MAX_NL80211_IFACE_LIMIT: highest attribute number"]
pub type nl80211_iface_limit_attrs = ::std::os::raw::c_uint;
pub const nl80211_if_combination_attrs_NL80211_IFACE_COMB_UNSPEC: nl80211_if_combination_attrs = 0;
pub const nl80211_if_combination_attrs_NL80211_IFACE_COMB_LIMITS: nl80211_if_combination_attrs = 1;
pub const nl80211_if_combination_attrs_NL80211_IFACE_COMB_MAXNUM: nl80211_if_combination_attrs = 2;
pub const nl80211_if_combination_attrs_NL80211_IFACE_COMB_STA_AP_BI_MATCH:
    nl80211_if_combination_attrs = 3;
pub const nl80211_if_combination_attrs_NL80211_IFACE_COMB_NUM_CHANNELS:
    nl80211_if_combination_attrs = 4;
pub const nl80211_if_combination_attrs_NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS:
    nl80211_if_combination_attrs = 5;
pub const nl80211_if_combination_attrs_NL80211_IFACE_COMB_RADAR_DETECT_REGIONS:
    nl80211_if_combination_attrs = 6;
pub const nl80211_if_combination_attrs_NL80211_IFACE_COMB_BI_MIN_GCD: nl80211_if_combination_attrs =
    7;
pub const nl80211_if_combination_attrs_NUM_NL80211_IFACE_COMB: nl80211_if_combination_attrs = 8;
pub const nl80211_if_combination_attrs_MAX_NL80211_IFACE_COMB: nl80211_if_combination_attrs = 7;
#[doc = " enum nl80211_if_combination_attrs -- interface combination attributes"]
#[doc = ""]
#[doc = " @NL80211_IFACE_COMB_UNSPEC: (reserved)"]
#[doc = " @NL80211_IFACE_COMB_LIMITS: Nested attributes containing the limits"]
#[doc = "\tfor given interface types, see &enum nl80211_iface_limit_attrs."]
#[doc = " @NL80211_IFACE_COMB_MAXNUM: u32 attribute giving the total number of"]
#[doc = "\tinterfaces that can be created in this group. This number doesn't"]
#[doc = "\tapply to interfaces purely managed in software, which are listed"]
#[doc = "\tin a separate attribute %NL80211_ATTR_INTERFACES_SOFTWARE."]
#[doc = " @NL80211_IFACE_COMB_STA_AP_BI_MATCH: flag attribute specifying that"]
#[doc = "\tbeacon intervals within this group must be all the same even for"]
#[doc = "\tinfrastructure and AP/GO combinations, i.e. the GO(s) must adopt"]
#[doc = "\tthe infrastructure network's beacon interval."]
#[doc = " @NL80211_IFACE_COMB_NUM_CHANNELS: u32 attribute specifying how many"]
#[doc = "\tdifferent channels may be used within this group."]
#[doc = " @NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS: u32 attribute containing the bitmap"]
#[doc = "\tof supported channel widths for radar detection."]
#[doc = " @NL80211_IFACE_COMB_RADAR_DETECT_REGIONS: u32 attribute containing the bitmap"]
#[doc = "\tof supported regulatory regions for radar detection."]
#[doc = " @NL80211_IFACE_COMB_BI_MIN_GCD: u32 attribute specifying the minimum GCD of"]
#[doc = "\tdifferent beacon intervals supported by all the interface combinations"]
#[doc = "\tin this group (if not present, all beacon intervals be identical)."]
#[doc = " @NUM_NL80211_IFACE_COMB: number of attributes"]
#[doc = " @MAX_NL80211_IFACE_COMB: highest attribute number"]
#[doc = ""]
#[doc = " Examples:"]
#[doc = "\tlimits = [ #{STA} <= 1, #{AP} <= 1 ], matching BI, channels = 1, max = 2"]
#[doc = "\t=> allows an AP and a STA that must match BIs"]
#[doc = ""]
#[doc = "\tnumbers = [ #{AP, P2P-GO} <= 8 ], BI min gcd, channels = 1, max = 8,"]
#[doc = "\t=> allows 8 of AP/GO that can have BI gcd >= min gcd"]
#[doc = ""]
#[doc = "\tnumbers = [ #{STA} <= 2 ], channels = 2, max = 2"]
#[doc = "\t=> allows two STAs on different channels"]
#[doc = ""]
#[doc = "\tnumbers = [ #{STA} <= 1, #{P2P-client,P2P-GO} <= 3 ], max = 4"]
#[doc = "\t=> allows a STA plus three P2P interfaces"]
#[doc = ""]
#[doc = " The list of these four possibilities could completely be contained"]
#[doc = " within the %NL80211_ATTR_INTERFACE_COMBINATIONS attribute to indicate"]
#[doc = " that any of these groups must match."]
#[doc = ""]
#[doc = " \"Combinations\" of just a single interface will not be listed here,"]
#[doc = " a single interface of any valid interface type is assumed to always"]
#[doc = " be possible by itself. This means that implicitly, for each valid"]
#[doc = " interface type, the following group always exists:"]
#[doc = "\tnumbers = [ #{<type>} <= 1 ], channels = 1, max = 1"]
pub type nl80211_if_combination_attrs = ::std::os::raw::c_uint;
pub const nl80211_plink_state_NL80211_PLINK_LISTEN: nl80211_plink_state = 0;
pub const nl80211_plink_state_NL80211_PLINK_OPN_SNT: nl80211_plink_state = 1;
pub const nl80211_plink_state_NL80211_PLINK_OPN_RCVD: nl80211_plink_state = 2;
pub const nl80211_plink_state_NL80211_PLINK_CNF_RCVD: nl80211_plink_state = 3;
pub const nl80211_plink_state_NL80211_PLINK_ESTAB: nl80211_plink_state = 4;
pub const nl80211_plink_state_NL80211_PLINK_HOLDING: nl80211_plink_state = 5;
pub const nl80211_plink_state_NL80211_PLINK_BLOCKED: nl80211_plink_state = 6;
pub const nl80211_plink_state_NUM_NL80211_PLINK_STATES: nl80211_plink_state = 7;
pub const nl80211_plink_state_MAX_NL80211_PLINK_STATES: nl80211_plink_state = 6;
#[doc = " enum nl80211_plink_state - state of a mesh peer link finite state machine"]
#[doc = ""]
#[doc = " @NL80211_PLINK_LISTEN: initial state, considered the implicit"]
#[doc = "\tstate of non existent mesh peer links"]
#[doc = " @NL80211_PLINK_OPN_SNT: mesh plink open frame has been sent to"]
#[doc = "\tthis mesh peer"]
#[doc = " @NL80211_PLINK_OPN_RCVD: mesh plink open frame has been received"]
#[doc = "\tfrom this mesh peer"]
#[doc = " @NL80211_PLINK_CNF_RCVD: mesh plink confirm frame has been"]
#[doc = "\treceived from this mesh peer"]
#[doc = " @NL80211_PLINK_ESTAB: mesh peer link is established"]
#[doc = " @NL80211_PLINK_HOLDING: mesh peer link is being closed or cancelled"]
#[doc = " @NL80211_PLINK_BLOCKED: all frames transmitted from this mesh"]
#[doc = "\tplink are discarded"]
#[doc = " @NUM_NL80211_PLINK_STATES: number of peer link states"]
#[doc = " @MAX_NL80211_PLINK_STATES: highest numerical value of plink states"]
pub type nl80211_plink_state = ::std::os::raw::c_uint;
pub const plink_actions_NL80211_PLINK_ACTION_NO_ACTION: plink_actions = 0;
pub const plink_actions_NL80211_PLINK_ACTION_OPEN: plink_actions = 1;
pub const plink_actions_NL80211_PLINK_ACTION_BLOCK: plink_actions = 2;
pub const plink_actions_NUM_NL80211_PLINK_ACTIONS: plink_actions = 3;
#[doc = " enum nl80211_plink_action - actions to perform in mesh peers"]
#[doc = ""]
#[doc = " @NL80211_PLINK_ACTION_NO_ACTION: perform no action"]
#[doc = " @NL80211_PLINK_ACTION_OPEN: start mesh peer link establishment"]
#[doc = " @NL80211_PLINK_ACTION_BLOCK: block traffic from this mesh peer"]
#[doc = " @NUM_NL80211_PLINK_ACTIONS: number of possible actions"]
pub type plink_actions = ::std::os::raw::c_uint;
pub const nl80211_rekey_data___NL80211_REKEY_DATA_INVALID: nl80211_rekey_data = 0;
pub const nl80211_rekey_data_NL80211_REKEY_DATA_KEK: nl80211_rekey_data = 1;
pub const nl80211_rekey_data_NL80211_REKEY_DATA_KCK: nl80211_rekey_data = 2;
pub const nl80211_rekey_data_NL80211_REKEY_DATA_REPLAY_CTR: nl80211_rekey_data = 3;
pub const nl80211_rekey_data_NL80211_REKEY_DATA_AKM: nl80211_rekey_data = 4;
pub const nl80211_rekey_data_NUM_NL80211_REKEY_DATA: nl80211_rekey_data = 5;
pub const nl80211_rekey_data_MAX_NL80211_REKEY_DATA: nl80211_rekey_data = 4;
#[doc = " enum nl80211_rekey_data - attributes for GTK rekey offload"]
#[doc = " @__NL80211_REKEY_DATA_INVALID: invalid number for nested attributes"]
#[doc = " @NL80211_REKEY_DATA_KEK: key encryption key (binary)"]
#[doc = " @NL80211_REKEY_DATA_KCK: key confirmation key (binary)"]
#[doc = " @NL80211_REKEY_DATA_REPLAY_CTR: replay counter (binary)"]
#[doc = " @NL80211_REKEY_DATA_AKM: AKM data (OUI, suite type)"]
#[doc = " @NUM_NL80211_REKEY_DATA: number of rekey attributes (internal)"]
#[doc = " @MAX_NL80211_REKEY_DATA: highest rekey attribute (internal)"]
pub type nl80211_rekey_data = ::std::os::raw::c_uint;
pub const nl80211_hidden_ssid_NL80211_HIDDEN_SSID_NOT_IN_USE: nl80211_hidden_ssid = 0;
pub const nl80211_hidden_ssid_NL80211_HIDDEN_SSID_ZERO_LEN: nl80211_hidden_ssid = 1;
pub const nl80211_hidden_ssid_NL80211_HIDDEN_SSID_ZERO_CONTENTS: nl80211_hidden_ssid = 2;
#[doc = " enum nl80211_hidden_ssid - values for %NL80211_ATTR_HIDDEN_SSID"]
#[doc = " @NL80211_HIDDEN_SSID_NOT_IN_USE: do not hide SSID (i.e., broadcast it in"]
#[doc = "\tBeacon frames)"]
#[doc = " @NL80211_HIDDEN_SSID_ZERO_LEN: hide SSID by using zero-length SSID element"]
#[doc = "\tin Beacon frames"]
#[doc = " @NL80211_HIDDEN_SSID_ZERO_CONTENTS: hide SSID by using correct length of SSID"]
#[doc = "\telement in Beacon frames but zero out each byte in the SSID"]
pub type nl80211_hidden_ssid = ::std::os::raw::c_uint;
pub const nl80211_sta_wme_attr___NL80211_STA_WME_INVALID: nl80211_sta_wme_attr = 0;
pub const nl80211_sta_wme_attr_NL80211_STA_WME_UAPSD_QUEUES: nl80211_sta_wme_attr = 1;
pub const nl80211_sta_wme_attr_NL80211_STA_WME_MAX_SP: nl80211_sta_wme_attr = 2;
pub const nl80211_sta_wme_attr___NL80211_STA_WME_AFTER_LAST: nl80211_sta_wme_attr = 3;
pub const nl80211_sta_wme_attr_NL80211_STA_WME_MAX: nl80211_sta_wme_attr = 2;
#[doc = " enum nl80211_sta_wme_attr - station WME attributes"]
#[doc = " @__NL80211_STA_WME_INVALID: invalid number for nested attribute"]
#[doc = " @NL80211_STA_WME_UAPSD_QUEUES: bitmap of uapsd queues. the format"]
#[doc = "\tis the same as the AC bitmap in the QoS info field."]
#[doc = " @NL80211_STA_WME_MAX_SP: max service period. the format is the same"]
#[doc = "\tas the MAX_SP field in the QoS info field (but already shifted down)."]
#[doc = " @__NL80211_STA_WME_AFTER_LAST: internal"]
#[doc = " @NL80211_STA_WME_MAX: highest station WME attribute"]
pub type nl80211_sta_wme_attr = ::std::os::raw::c_uint;
pub const nl80211_pmksa_candidate_attr___NL80211_PMKSA_CANDIDATE_INVALID:
    nl80211_pmksa_candidate_attr = 0;
pub const nl80211_pmksa_candidate_attr_NL80211_PMKSA_CANDIDATE_INDEX: nl80211_pmksa_candidate_attr =
    1;
pub const nl80211_pmksa_candidate_attr_NL80211_PMKSA_CANDIDATE_BSSID: nl80211_pmksa_candidate_attr =
    2;
pub const nl80211_pmksa_candidate_attr_NL80211_PMKSA_CANDIDATE_PREAUTH:
    nl80211_pmksa_candidate_attr = 3;
pub const nl80211_pmksa_candidate_attr_NUM_NL80211_PMKSA_CANDIDATE: nl80211_pmksa_candidate_attr =
    4;
pub const nl80211_pmksa_candidate_attr_MAX_NL80211_PMKSA_CANDIDATE: nl80211_pmksa_candidate_attr =
    3;
#[doc = " enum nl80211_pmksa_candidate_attr - attributes for PMKSA caching candidates"]
#[doc = " @__NL80211_PMKSA_CANDIDATE_INVALID: invalid number for nested attributes"]
#[doc = " @NL80211_PMKSA_CANDIDATE_INDEX: candidate index (u32; the smaller, the higher"]
#[doc = "\tpriority)"]
#[doc = " @NL80211_PMKSA_CANDIDATE_BSSID: candidate BSSID (6 octets)"]
#[doc = " @NL80211_PMKSA_CANDIDATE_PREAUTH: RSN pre-authentication supported (flag)"]
#[doc = " @NUM_NL80211_PMKSA_CANDIDATE: number of PMKSA caching candidate attributes"]
#[doc = "\t(internal)"]
#[doc = " @MAX_NL80211_PMKSA_CANDIDATE: highest PMKSA caching candidate attribute"]
#[doc = "\t(internal)"]
pub type nl80211_pmksa_candidate_attr = ::std::os::raw::c_uint;
pub const nl80211_tdls_operation_NL80211_TDLS_DISCOVERY_REQ: nl80211_tdls_operation = 0;
pub const nl80211_tdls_operation_NL80211_TDLS_SETUP: nl80211_tdls_operation = 1;
pub const nl80211_tdls_operation_NL80211_TDLS_TEARDOWN: nl80211_tdls_operation = 2;
pub const nl80211_tdls_operation_NL80211_TDLS_ENABLE_LINK: nl80211_tdls_operation = 3;
pub const nl80211_tdls_operation_NL80211_TDLS_DISABLE_LINK: nl80211_tdls_operation = 4;
#[doc = " enum nl80211_tdls_operation - values for %NL80211_ATTR_TDLS_OPERATION"]
#[doc = " @NL80211_TDLS_DISCOVERY_REQ: Send a TDLS discovery request"]
#[doc = " @NL80211_TDLS_SETUP: Setup TDLS link"]
#[doc = " @NL80211_TDLS_TEARDOWN: Teardown a TDLS link which is already established"]
#[doc = " @NL80211_TDLS_ENABLE_LINK: Enable TDLS link"]
#[doc = " @NL80211_TDLS_DISABLE_LINK: Disable TDLS link"]
pub type nl80211_tdls_operation = ::std::os::raw::c_uint;
pub const nl80211_feature_flags_NL80211_FEATURE_SK_TX_STATUS: nl80211_feature_flags = 1;
pub const nl80211_feature_flags_NL80211_FEATURE_HT_IBSS: nl80211_feature_flags = 2;
pub const nl80211_feature_flags_NL80211_FEATURE_INACTIVITY_TIMER: nl80211_feature_flags = 4;
pub const nl80211_feature_flags_NL80211_FEATURE_CELL_BASE_REG_HINTS: nl80211_feature_flags = 8;
pub const nl80211_feature_flags_NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL: nl80211_feature_flags =
    16;
pub const nl80211_feature_flags_NL80211_FEATURE_SAE: nl80211_feature_flags = 32;
pub const nl80211_feature_flags_NL80211_FEATURE_LOW_PRIORITY_SCAN: nl80211_feature_flags = 64;
pub const nl80211_feature_flags_NL80211_FEATURE_SCAN_FLUSH: nl80211_feature_flags = 128;
pub const nl80211_feature_flags_NL80211_FEATURE_AP_SCAN: nl80211_feature_flags = 256;
pub const nl80211_feature_flags_NL80211_FEATURE_VIF_TXPOWER: nl80211_feature_flags = 512;
pub const nl80211_feature_flags_NL80211_FEATURE_NEED_OBSS_SCAN: nl80211_feature_flags = 1024;
pub const nl80211_feature_flags_NL80211_FEATURE_P2P_GO_CTWIN: nl80211_feature_flags = 2048;
pub const nl80211_feature_flags_NL80211_FEATURE_P2P_GO_OPPPS: nl80211_feature_flags = 4096;
pub const nl80211_feature_flags_NL80211_FEATURE_ADVERTISE_CHAN_LIMITS: nl80211_feature_flags =
    16384;
pub const nl80211_feature_flags_NL80211_FEATURE_FULL_AP_CLIENT_STATE: nl80211_feature_flags = 32768;
pub const nl80211_feature_flags_NL80211_FEATURE_USERSPACE_MPM: nl80211_feature_flags = 65536;
pub const nl80211_feature_flags_NL80211_FEATURE_ACTIVE_MONITOR: nl80211_feature_flags = 131072;
pub const nl80211_feature_flags_NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE: nl80211_feature_flags =
    262144;
pub const nl80211_feature_flags_NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES: nl80211_feature_flags =
    524288;
pub const nl80211_feature_flags_NL80211_FEATURE_WFA_TPC_IE_IN_PROBES: nl80211_feature_flags =
    1048576;
pub const nl80211_feature_flags_NL80211_FEATURE_QUIET: nl80211_feature_flags = 2097152;
pub const nl80211_feature_flags_NL80211_FEATURE_TX_POWER_INSERTION: nl80211_feature_flags = 4194304;
pub const nl80211_feature_flags_NL80211_FEATURE_ACKTO_ESTIMATION: nl80211_feature_flags = 8388608;
pub const nl80211_feature_flags_NL80211_FEATURE_STATIC_SMPS: nl80211_feature_flags = 16777216;
pub const nl80211_feature_flags_NL80211_FEATURE_DYNAMIC_SMPS: nl80211_feature_flags = 33554432;
pub const nl80211_feature_flags_NL80211_FEATURE_SUPPORTS_WMM_ADMISSION: nl80211_feature_flags =
    67108864;
pub const nl80211_feature_flags_NL80211_FEATURE_MAC_ON_CREATE: nl80211_feature_flags = 134217728;
pub const nl80211_feature_flags_NL80211_FEATURE_TDLS_CHANNEL_SWITCH: nl80211_feature_flags =
    268435456;
pub const nl80211_feature_flags_NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR: nl80211_feature_flags =
    536870912;
pub const nl80211_feature_flags_NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR: nl80211_feature_flags =
    1073741824;
pub const nl80211_feature_flags_NL80211_FEATURE_ND_RANDOM_MAC_ADDR: nl80211_feature_flags =
    2147483648;
#[doc = " enum nl80211_feature_flags - device/driver features"]
#[doc = " @NL80211_FEATURE_SK_TX_STATUS: This driver supports reflecting back"]
#[doc = "\tTX status to the socket error queue when requested with the"]
#[doc = "\tsocket option."]
#[doc = " @NL80211_FEATURE_HT_IBSS: This driver supports IBSS with HT datarates."]
#[doc = " @NL80211_FEATURE_INACTIVITY_TIMER: This driver takes care of freeing up"]
#[doc = "\tthe connected inactive stations in AP mode."]
#[doc = " @NL80211_FEATURE_CELL_BASE_REG_HINTS: This driver has been tested"]
#[doc = "\tto work properly to suppport receiving regulatory hints from"]
#[doc = "\tcellular base stations."]
#[doc = " @NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL: (no longer available, only"]
#[doc = "\there to reserve the value for API/ABI compatibility)"]
#[doc = " @NL80211_FEATURE_SAE: This driver supports simultaneous authentication of"]
#[doc = "\tequals (SAE) with user space SME (NL80211_CMD_AUTHENTICATE) in station"]
#[doc = "\tmode"]
#[doc = " @NL80211_FEATURE_LOW_PRIORITY_SCAN: This driver supports low priority scan"]
#[doc = " @NL80211_FEATURE_SCAN_FLUSH: Scan flush is supported"]
#[doc = " @NL80211_FEATURE_AP_SCAN: Support scanning using an AP vif"]
#[doc = " @NL80211_FEATURE_VIF_TXPOWER: The driver supports per-vif TX power setting"]
#[doc = " @NL80211_FEATURE_NEED_OBSS_SCAN: The driver expects userspace to perform"]
#[doc = "\tOBSS scans and generate 20/40 BSS coex reports. This flag is used only"]
#[doc = "\tfor drivers implementing the CONNECT API, for AUTH/ASSOC it is implied."]
#[doc = " @NL80211_FEATURE_P2P_GO_CTWIN: P2P GO implementation supports CT Window"]
#[doc = "\tsetting"]
#[doc = " @NL80211_FEATURE_P2P_GO_OPPPS: P2P GO implementation supports opportunistic"]
#[doc = "\tpowersave"]
#[doc = " @NL80211_FEATURE_FULL_AP_CLIENT_STATE: The driver supports full state"]
#[doc = "\ttransitions for AP clients. Without this flag (and if the driver"]
#[doc = "\tdoesn't have the AP SME in the device) the driver supports adding"]
#[doc = "\tstations only when they're associated and adds them in associated"]
#[doc = "\tstate (to later be transitioned into authorized), with this flag"]
#[doc = "\tthey should be added before even sending the authentication reply"]
#[doc = "\tand then transitioned into authenticated, associated and authorized"]
#[doc = "\tstates using station flags."]
#[doc = "\tNote that even for drivers that support this, the default is to add"]
#[doc = "\tstations in authenticated/associated state, so to add unauthenticated"]
#[doc = "\tstations the authenticated/associated bits have to be set in the mask."]
#[doc = " @NL80211_FEATURE_ADVERTISE_CHAN_LIMITS: cfg80211 advertises channel limits"]
#[doc = "\t(HT40, VHT 80/160 MHz) if this flag is set"]
#[doc = " @NL80211_FEATURE_USERSPACE_MPM: This driver supports a userspace Mesh"]
#[doc = "\tPeering Management entity which may be implemented by registering for"]
#[doc = "\tbeacons or NL80211_CMD_NEW_PEER_CANDIDATE events. The mesh beacon is"]
#[doc = "\tstill generated by the driver."]
#[doc = " @NL80211_FEATURE_ACTIVE_MONITOR: This driver supports an active monitor"]
#[doc = "\tinterface. An active monitor interface behaves like a normal monitor"]
#[doc = "\tinterface, but gets added to the driver. It ensures that incoming"]
#[doc = "\tunicast packets directed at the configured interface address get ACKed."]
#[doc = " @NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE: This driver supports dynamic"]
#[doc = "\tchannel bandwidth change (e.g., HT 20 <-> 40 MHz channel) during the"]
#[doc = "\tlifetime of a BSS."]
#[doc = " @NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES: This device adds a DS Parameter"]
#[doc = "\tSet IE to probe requests."]
#[doc = " @NL80211_FEATURE_WFA_TPC_IE_IN_PROBES: This device adds a WFA TPC Report IE"]
#[doc = "\tto probe requests."]
#[doc = " @NL80211_FEATURE_QUIET: This device, in client mode, supports Quiet Period"]
#[doc = "\trequests sent to it by an AP."]
#[doc = " @NL80211_FEATURE_TX_POWER_INSERTION: This device is capable of inserting the"]
#[doc = "\tcurrent tx power value into the TPC Report IE in the spectrum"]
#[doc = "\tmanagement TPC Report action frame, and in the Radio Measurement Link"]
#[doc = "\tMeasurement Report action frame."]
#[doc = " @NL80211_FEATURE_ACKTO_ESTIMATION: This driver supports dynamic ACK timeout"]
#[doc = "\testimation (dynack). %NL80211_ATTR_WIPHY_DYN_ACK flag attribute is used"]
#[doc = "\tto enable dynack."]
#[doc = " @NL80211_FEATURE_STATIC_SMPS: Device supports static spatial"]
#[doc = "\tmultiplexing powersave, ie. can turn off all but one chain"]
#[doc = "\teven on HT connections that should be using more chains."]
#[doc = " @NL80211_FEATURE_DYNAMIC_SMPS: Device supports dynamic spatial"]
#[doc = "\tmultiplexing powersave, ie. can turn off all but one chain"]
#[doc = "\tand then wake the rest up as required after, for example,"]
#[doc = "\trts/cts handshake."]
#[doc = " @NL80211_FEATURE_SUPPORTS_WMM_ADMISSION: the device supports setting up WMM"]
#[doc = "\tTSPEC sessions (TID aka TSID 0-7) with the %NL80211_CMD_ADD_TX_TS"]
#[doc = "\tcommand. Standard IEEE 802.11 TSPEC setup is not yet supported, it"]
#[doc = "\tneeds to be able to handle Block-Ack agreements and other things."]
#[doc = " @NL80211_FEATURE_MAC_ON_CREATE: Device supports configuring"]
#[doc = "\tthe vif's MAC address upon creation."]
#[doc = "\tSee 'macaddr' field in the vif_params (cfg80211.h)."]
#[doc = " @NL80211_FEATURE_TDLS_CHANNEL_SWITCH: Driver supports channel switching when"]
#[doc = "\toperating as a TDLS peer."]
#[doc = " @NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR: This device/driver supports using a"]
#[doc = "\trandom MAC address during scan (if the device is unassociated); the"]
#[doc = "\t%NL80211_SCAN_FLAG_RANDOM_ADDR flag may be set for scans and the MAC"]
#[doc = "\taddress mask/value will be used."]
#[doc = " @NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR: This device/driver supports"]
#[doc = "\tusing a random MAC address for every scan iteration during scheduled"]
#[doc = "\tscan (while not associated), the %NL80211_SCAN_FLAG_RANDOM_ADDR may"]
#[doc = "\tbe set for scheduled scan and the MAC address mask/value will be used."]
#[doc = " @NL80211_FEATURE_ND_RANDOM_MAC_ADDR: This device/driver supports using a"]
#[doc = "\trandom MAC address for every scan iteration during \"net detect\", i.e."]
#[doc = "\tscan in unassociated WoWLAN, the %NL80211_SCAN_FLAG_RANDOM_ADDR may"]
#[doc = "\tbe set for scheduled scan and the MAC address mask/value will be used."]
pub type nl80211_feature_flags = ::std::os::raw::c_uint;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_VHT_IBSS: nl80211_ext_feature_index = 0;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_RRM: nl80211_ext_feature_index = 1;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER:
    nl80211_ext_feature_index = 2;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_SCAN_START_TIME: nl80211_ext_feature_index =
    3;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_BSS_PARENT_TSF: nl80211_ext_feature_index =
    4;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_SET_SCAN_DWELL: nl80211_ext_feature_index =
    5;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_BEACON_RATE_LEGACY:
    nl80211_ext_feature_index = 6;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_BEACON_RATE_HT: nl80211_ext_feature_index =
    7;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_BEACON_RATE_VHT: nl80211_ext_feature_index =
    8;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_FILS_STA: nl80211_ext_feature_index = 9;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA:
    nl80211_ext_feature_index = 10;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED:
    nl80211_ext_feature_index = 11;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI:
    nl80211_ext_feature_index = 12;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_CQM_RSSI_LIST: nl80211_ext_feature_index =
    13;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_FILS_SK_OFFLOAD: nl80211_ext_feature_index =
    14;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK:
    nl80211_ext_feature_index = 15;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X:
    nl80211_ext_feature_index = 16;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME:
    nl80211_ext_feature_index = 17;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP:
    nl80211_ext_feature_index = 18;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE:
    nl80211_ext_feature_index = 19;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION:
    nl80211_ext_feature_index = 20;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_MFP_OPTIONAL: nl80211_ext_feature_index =
    21;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_LOW_SPAN_SCAN: nl80211_ext_feature_index =
    22;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_LOW_POWER_SCAN: nl80211_ext_feature_index =
    23;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN:
    nl80211_ext_feature_index = 24;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_DFS_OFFLOAD: nl80211_ext_feature_index = 25;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211:
    nl80211_ext_feature_index = 26;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT:
    nl80211_ext_feature_index = 27;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT:
    nl80211_ext_feature_index = 27;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_TXQS: nl80211_ext_feature_index = 28;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_SCAN_RANDOM_SN: nl80211_ext_feature_index =
    29;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT:
    nl80211_ext_feature_index = 30;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_CAN_REPLACE_PTK0:
    nl80211_ext_feature_index = 31;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER:
    nl80211_ext_feature_index = 32;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_AIRTIME_FAIRNESS:
    nl80211_ext_feature_index = 33;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_AP_PMKSA_CACHING:
    nl80211_ext_feature_index = 34;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD:
    nl80211_ext_feature_index = 35;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_EXT_KEY_ID: nl80211_ext_feature_index = 36;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_STA_TX_PWR: nl80211_ext_feature_index = 37;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_SAE_OFFLOAD: nl80211_ext_feature_index = 38;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_VLAN_OFFLOAD: nl80211_ext_feature_index =
    39;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_AQL: nl80211_ext_feature_index = 40;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_BEACON_PROTECTION:
    nl80211_ext_feature_index = 41;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH:
    nl80211_ext_feature_index = 42;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_PROTECTED_TWT: nl80211_ext_feature_index =
    43;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_DEL_IBSS_STA: nl80211_ext_feature_index =
    44;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS:
    nl80211_ext_feature_index = 45;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT:
    nl80211_ext_feature_index = 46;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_SCAN_FREQ_KHZ: nl80211_ext_feature_index =
    47;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS:
    nl80211_ext_feature_index = 48;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION:
    nl80211_ext_feature_index = 49;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK:
    nl80211_ext_feature_index = 50;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_SAE_OFFLOAD_AP: nl80211_ext_feature_index =
    51;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_FILS_DISCOVERY: nl80211_ext_feature_index =
    52;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP:
    nl80211_ext_feature_index = 53;
pub const nl80211_ext_feature_index_NL80211_EXT_FEATURE_BEACON_RATE_HE: nl80211_ext_feature_index =
    54;
pub const nl80211_ext_feature_index_NUM_NL80211_EXT_FEATURES: nl80211_ext_feature_index = 55;
pub const nl80211_ext_feature_index_MAX_NL80211_EXT_FEATURES: nl80211_ext_feature_index = 54;
#[doc = " enum nl80211_ext_feature_index - bit index of extended features."]
#[doc = " @NL80211_EXT_FEATURE_VHT_IBSS: This driver supports IBSS with VHT datarates."]
#[doc = " @NL80211_EXT_FEATURE_RRM: This driver supports RRM. When featured, user can"]
#[doc = "\trequest to use RRM (see %NL80211_ATTR_USE_RRM) with"]
#[doc = "\t%NL80211_CMD_ASSOCIATE and %NL80211_CMD_CONNECT requests, which will set"]
#[doc = "\tthe ASSOC_REQ_USE_RRM flag in the association request even if"]
#[doc = "\tNL80211_FEATURE_QUIET is not advertized."]
#[doc = " @NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER: This device supports MU-MIMO air"]
#[doc = "\tsniffer which means that it can be configured to hear packets from"]
#[doc = "\tcertain groups which can be configured by the"]
#[doc = "\t%NL80211_ATTR_MU_MIMO_GROUP_DATA attribute,"]
#[doc = "\tor can be configured to follow a station by configuring the"]
#[doc = "\t%NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR attribute."]
#[doc = " @NL80211_EXT_FEATURE_SCAN_START_TIME: This driver includes the actual"]
#[doc = "\ttime the scan started in scan results event. The time is the TSF of"]
#[doc = "\tthe BSS that the interface that requested the scan is connected to"]
#[doc = "\t(if available)."]
#[doc = " @NL80211_EXT_FEATURE_BSS_PARENT_TSF: Per BSS, this driver reports the"]
#[doc = "\ttime the last beacon/probe was received. The time is the TSF of the"]
#[doc = "\tBSS that the interface that requested the scan is connected to"]
#[doc = "\t(if available)."]
#[doc = " @NL80211_EXT_FEATURE_SET_SCAN_DWELL: This driver supports configuration of"]
#[doc = "\tchannel dwell time."]
#[doc = " @NL80211_EXT_FEATURE_BEACON_RATE_LEGACY: Driver supports beacon rate"]
#[doc = "\tconfiguration (AP/mesh), supporting a legacy (non HT/VHT) rate."]
#[doc = " @NL80211_EXT_FEATURE_BEACON_RATE_HT: Driver supports beacon rate"]
#[doc = "\tconfiguration (AP/mesh) with HT rates."]
#[doc = " @NL80211_EXT_FEATURE_BEACON_RATE_VHT: Driver supports beacon rate"]
#[doc = "\tconfiguration (AP/mesh) with VHT rates."]
#[doc = " @NL80211_EXT_FEATURE_FILS_STA: This driver supports Fast Initial Link Setup"]
#[doc = "\twith user space SME (NL80211_CMD_AUTHENTICATE) in station mode."]
#[doc = " @NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA: This driver supports randomized TA"]
#[doc = "\tin @NL80211_CMD_FRAME while not associated."]
#[doc = " @NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED: This driver supports"]
#[doc = "\trandomized TA in @NL80211_CMD_FRAME while associated."]
#[doc = " @NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI: The driver supports sched_scan"]
#[doc = "\tfor reporting BSSs with better RSSI than the current connected BSS"]
#[doc = "\t(%NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI)."]
#[doc = " @NL80211_EXT_FEATURE_CQM_RSSI_LIST: With this driver the"]
#[doc = "\t%NL80211_ATTR_CQM_RSSI_THOLD attribute accepts a list of zero or more"]
#[doc = "\tRSSI threshold values to monitor rather than exactly one threshold."]
#[doc = " @NL80211_EXT_FEATURE_FILS_SK_OFFLOAD: Driver SME supports FILS shared key"]
#[doc = "\tauthentication with %NL80211_CMD_CONNECT."]
#[doc = " @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK: Device wants to do 4-way"]
#[doc = "\thandshake with PSK in station mode (PSK is passed as part of the connect"]
#[doc = "\tand associate commands), doing it in the host might not be supported."]
#[doc = " @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X: Device wants to do doing 4-way"]
#[doc = "\thandshake with 802.1X in station mode (will pass EAP frames to the host"]
#[doc = "\tand accept the set_pmk/del_pmk commands), doing it in the host might not"]
#[doc = "\tbe supported."]
#[doc = " @NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME: Driver is capable of overriding"]
#[doc = "\tthe max channel attribute in the FILS request params IE with the"]
#[doc = "\tactual dwell time."]
#[doc = " @NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP: Driver accepts broadcast probe"]
#[doc = "\tresponse"]
#[doc = " @NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE: Driver supports sending"]
#[doc = "\tthe first probe request in each channel at rate of at least 5.5Mbps."]
#[doc = " @NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION: Driver supports"]
#[doc = "\tprobe request tx deferral and suppression"]
#[doc = " @NL80211_EXT_FEATURE_MFP_OPTIONAL: Driver supports the %NL80211_MFP_OPTIONAL"]
#[doc = "\tvalue in %NL80211_ATTR_USE_MFP."]
#[doc = " @NL80211_EXT_FEATURE_LOW_SPAN_SCAN: Driver supports low span scan."]
#[doc = " @NL80211_EXT_FEATURE_LOW_POWER_SCAN: Driver supports low power scan."]
#[doc = " @NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN: Driver supports high accuracy scan."]
#[doc = " @NL80211_EXT_FEATURE_DFS_OFFLOAD: HW/driver will offload DFS actions."]
#[doc = "\tDevice or driver will do all DFS-related actions by itself,"]
#[doc = "\tinforming user-space about CAC progress, radar detection event,"]
#[doc = "\tchannel change triggered by radar detection event."]
#[doc = "\tNo need to start CAC from user-space, no need to react to"]
#[doc = "\t\"radar detected\" event."]
#[doc = " @NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211: Driver supports sending and"]
#[doc = "\treceiving control port frames over nl80211 instead of the netdevice."]
#[doc = " @NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT: This driver/device supports"]
#[doc = "\t(average) ACK signal strength reporting."]
#[doc = " @NL80211_EXT_FEATURE_TXQS: Driver supports FQ-CoDel-enabled intermediate"]
#[doc = "      TXQs."]
#[doc = " @NL80211_EXT_FEATURE_SCAN_RANDOM_SN: Driver/device supports randomizing the"]
#[doc = "\tSN in probe request frames if requested by %NL80211_SCAN_FLAG_RANDOM_SN."]
#[doc = " @NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT: Driver/device can omit all data"]
#[doc = "\texcept for supported rates from the probe request content if requested"]
#[doc = "\tby the %NL80211_SCAN_FLAG_MIN_PREQ_CONTENT flag."]
#[doc = " @NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER: Driver supports enabling fine"]
#[doc = "\ttiming measurement responder role."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_CAN_REPLACE_PTK0: Driver/device confirm that they are"]
#[doc = "      able to rekey an in-use key correctly. Userspace must not rekey PTK keys"]
#[doc = "      if this flag is not set. Ignoring this can leak clear text packets and/or"]
#[doc = "      freeze the connection."]
#[doc = " @NL80211_EXT_FEATURE_EXT_KEY_ID: Driver supports \"Extended Key ID for"]
#[doc = "      Individually Addressed Frames\" from IEEE802.11-2016."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_AIRTIME_FAIRNESS: Driver supports getting airtime"]
#[doc = "\tfairness for transmitted packets and has enabled airtime fairness"]
#[doc = "\tscheduling."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_AP_PMKSA_CACHING: Driver/device supports PMKSA caching"]
#[doc = "\t(set/del PMKSA operations) in AP mode."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD: Driver supports"]
#[doc = "\tfiltering of sched scan results using band specific RSSI thresholds."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_STA_TX_PWR: This driver supports controlling tx power"]
#[doc = "\tto a station."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_SAE_OFFLOAD: Device wants to do SAE authentication in"]
#[doc = "\tstation mode (SAE password is passed as part of the connect command)."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_VLAN_OFFLOAD: The driver supports a single netdev"]
#[doc = "\twith VLAN tagged frames and separate VLAN-specific netdevs added using"]
#[doc = "\tvconfig similarly to the Ethernet case."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_AQL: The driver supports the Airtime Queue Limit (AQL)"]
#[doc = "\tfeature, which prevents bufferbloat by using the expected transmission"]
#[doc = "\ttime to limit the amount of data buffered in the hardware."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_BEACON_PROTECTION: The driver supports Beacon protection"]
#[doc = "\tand can receive key configuration for BIGTK using key indexes 6 and 7."]
#[doc = " @NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT: The driver supports Beacon"]
#[doc = "\tprotection as a client only and cannot transmit protected beacons."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH: The driver can disable the"]
#[doc = "\tforwarding of preauth frames over the control port. They are then"]
#[doc = "\thandled as ordinary data frames."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_PROTECTED_TWT: Driver supports protected TWT frames"]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_DEL_IBSS_STA: The driver supports removing stations"]
#[doc = "      in IBSS mode, essentially by dropping their state."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS: management frame registrations"]
#[doc = "\tare possible for multicast frames and those will be reported properly."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_SCAN_FREQ_KHZ: This driver supports receiving and"]
#[doc = "\treporting scan request with %NL80211_ATTR_SCAN_FREQ_KHZ. In order to"]
#[doc = "\treport %NL80211_ATTR_SCAN_FREQ_KHZ, %NL80211_SCAN_FLAG_FREQ_KHZ must be"]
#[doc = "\tincluded in the scan request."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS: The driver"]
#[doc = "\tcan report tx status for control port over nl80211 tx operations."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION: Driver supports Operating"]
#[doc = "\tChannel Validation (OCV) when using driver's SME for RSNA handshakes."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK: Device wants to do 4-way"]
#[doc = "\thandshake with PSK in AP mode (PSK is passed as part of the start AP"]
#[doc = "\tcommand)."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_SAE_OFFLOAD_AP: Device wants to do SAE authentication"]
#[doc = "\tin AP mode (SAE password is passed as part of the start AP command)."]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_FILS_DISCOVERY: Driver/device supports FILS discovery"]
#[doc = "\tframes transmission"]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP: Driver/device supports"]
#[doc = "\tunsolicited broadcast probe response transmission"]
#[doc = ""]
#[doc = " @NL80211_EXT_FEATURE_BEACON_RATE_HE: Driver supports beacon rate"]
#[doc = "\tconfiguration (AP/mesh) with HE rates."]
#[doc = ""]
#[doc = " @NUM_NL80211_EXT_FEATURES: number of extended features."]
#[doc = " @MAX_NL80211_EXT_FEATURES: highest extended feature index."]
pub type nl80211_ext_feature_index = ::std::os::raw::c_uint;
pub const nl80211_probe_resp_offload_support_attr_NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS:
    nl80211_probe_resp_offload_support_attr = 1;
pub const nl80211_probe_resp_offload_support_attr_NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2:
    nl80211_probe_resp_offload_support_attr = 2;
pub const nl80211_probe_resp_offload_support_attr_NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P:
    nl80211_probe_resp_offload_support_attr = 4;
pub const nl80211_probe_resp_offload_support_attr_NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U:
    nl80211_probe_resp_offload_support_attr = 8;
#[doc = " enum nl80211_probe_resp_offload_support_attr - optional supported"]
#[doc = "\tprotocols for probe-response offloading by the driver/FW."]
#[doc = "\tTo be used with the %NL80211_ATTR_PROBE_RESP_OFFLOAD attribute."]
#[doc = "\tEach enum value represents a bit in the bitmap of supported"]
#[doc = "\tprotocols. Typically a subset of probe-requests belonging to a"]
#[doc = "\tsupported protocol will be excluded from offload and uploaded"]
#[doc = "\tto the host."]
#[doc = ""]
#[doc = " @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS: Support for WPS ver. 1"]
#[doc = " @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2: Support for WPS ver. 2"]
#[doc = " @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P: Support for P2P"]
#[doc = " @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U: Support for 802.11u"]
pub type nl80211_probe_resp_offload_support_attr = ::std::os::raw::c_uint;
pub const nl80211_connect_failed_reason_NL80211_CONN_FAIL_MAX_CLIENTS:
    nl80211_connect_failed_reason = 0;
pub const nl80211_connect_failed_reason_NL80211_CONN_FAIL_BLOCKED_CLIENT:
    nl80211_connect_failed_reason = 1;
#[doc = " enum nl80211_connect_failed_reason - connection request failed reasons"]
#[doc = " @NL80211_CONN_FAIL_MAX_CLIENTS: Maximum number of clients that can be"]
#[doc = "\thandled by the AP is reached."]
#[doc = " @NL80211_CONN_FAIL_BLOCKED_CLIENT: Connection request is rejected due to ACL."]
pub type nl80211_connect_failed_reason = ::std::os::raw::c_uint;
pub const nl80211_timeout_reason_NL80211_TIMEOUT_UNSPECIFIED: nl80211_timeout_reason = 0;
pub const nl80211_timeout_reason_NL80211_TIMEOUT_SCAN: nl80211_timeout_reason = 1;
pub const nl80211_timeout_reason_NL80211_TIMEOUT_AUTH: nl80211_timeout_reason = 2;
pub const nl80211_timeout_reason_NL80211_TIMEOUT_ASSOC: nl80211_timeout_reason = 3;
#[doc = " enum nl80211_timeout_reason - timeout reasons"]
#[doc = ""]
#[doc = " @NL80211_TIMEOUT_UNSPECIFIED: Timeout reason unspecified."]
#[doc = " @NL80211_TIMEOUT_SCAN: Scan (AP discovery) timed out."]
#[doc = " @NL80211_TIMEOUT_AUTH: Authentication timed out."]
#[doc = " @NL80211_TIMEOUT_ASSOC: Association timed out."]
pub type nl80211_timeout_reason = ::std::os::raw::c_uint;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_LOW_PRIORITY: nl80211_scan_flags = 1;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_FLUSH: nl80211_scan_flags = 2;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_AP: nl80211_scan_flags = 4;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_RANDOM_ADDR: nl80211_scan_flags = 8;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME: nl80211_scan_flags = 16;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP: nl80211_scan_flags = 32;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE: nl80211_scan_flags = 64;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION:
    nl80211_scan_flags = 128;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_LOW_SPAN: nl80211_scan_flags = 256;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_LOW_POWER: nl80211_scan_flags = 512;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_HIGH_ACCURACY: nl80211_scan_flags = 1024;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_RANDOM_SN: nl80211_scan_flags = 2048;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_MIN_PREQ_CONTENT: nl80211_scan_flags = 4096;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_FREQ_KHZ: nl80211_scan_flags = 8192;
pub const nl80211_scan_flags_NL80211_SCAN_FLAG_COLOCATED_6GHZ: nl80211_scan_flags = 16384;
#[doc = " enum nl80211_scan_flags -  scan request control flags"]
#[doc = ""]
#[doc = " Scan request control flags are used to control the handling"]
#[doc = " of NL80211_CMD_TRIGGER_SCAN and NL80211_CMD_START_SCHED_SCAN"]
#[doc = " requests."]
#[doc = ""]
#[doc = " NL80211_SCAN_FLAG_LOW_SPAN, NL80211_SCAN_FLAG_LOW_POWER, and"]
#[doc = " NL80211_SCAN_FLAG_HIGH_ACCURACY flags are exclusive of each other, i.e., only"]
#[doc = " one of them can be used in the request."]
#[doc = ""]
#[doc = " @NL80211_SCAN_FLAG_LOW_PRIORITY: scan request has low priority"]
#[doc = " @NL80211_SCAN_FLAG_FLUSH: flush cache before scanning"]
#[doc = " @NL80211_SCAN_FLAG_AP: force a scan even if the interface is configured"]
#[doc = "\tas AP and the beaconing has already been configured. This attribute is"]
#[doc = "\tdangerous because will destroy stations performance as a lot of frames"]
#[doc = "\twill be lost while scanning off-channel, therefore it must be used only"]
#[doc = "\twhen really needed"]
#[doc = " @NL80211_SCAN_FLAG_RANDOM_ADDR: use a random MAC address for this scan (or"]
#[doc = "\tfor scheduled scan: a different one for every scan iteration). When the"]
#[doc = "\tflag is set, depending on device capabilities the @NL80211_ATTR_MAC and"]
#[doc = "\t@NL80211_ATTR_MAC_MASK attributes may also be given in which case only"]
#[doc = "\tthe masked bits will be preserved from the MAC address and the remainder"]
#[doc = "\trandomised. If the attributes are not given full randomisation (46 bits,"]
#[doc = "\tlocally administered 1, multicast 0) is assumed."]
#[doc = "\tThis flag must not be requested when the feature isn't supported, check"]
#[doc = "\tthe nl80211 feature flags for the device."]
#[doc = " @NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME: fill the dwell time in the FILS"]
#[doc = "\trequest parameters IE in the probe request"]
#[doc = " @NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP: accept broadcast probe responses"]
#[doc = " @NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE: send probe request frames at"]
#[doc = "\trate of at least 5.5M. In case non OCE AP is discovered in the channel,"]
#[doc = "\tonly the first probe req in the channel will be sent in high rate."]
#[doc = " @NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION: allow probe request"]
#[doc = "\ttx deferral (dot11FILSProbeDelay shall be set to 15ms)"]
#[doc = "\tand suppression (if it has received a broadcast Probe Response frame,"]
#[doc = "\tBeacon frame or FILS Discovery frame from an AP that the STA considers"]
#[doc = "\ta suitable candidate for (re-)association - suitable in terms of"]
#[doc = "\tSSID and/or RSSI."]
#[doc = " @NL80211_SCAN_FLAG_LOW_SPAN: Span corresponds to the total time taken to"]
#[doc = "\taccomplish the scan. Thus, this flag intends the driver to perform the"]
#[doc = "\tscan request with lesser span/duration. It is specific to the driver"]
#[doc = "\timplementations on how this is accomplished. Scan accuracy may get"]
#[doc = "\timpacted with this flag."]
#[doc = " @NL80211_SCAN_FLAG_LOW_POWER: This flag intends the scan attempts to consume"]
#[doc = "\toptimal possible power. Drivers can resort to their specific means to"]
#[doc = "\toptimize the power. Scan accuracy may get impacted with this flag."]
#[doc = " @NL80211_SCAN_FLAG_HIGH_ACCURACY: Accuracy here intends to the extent of scan"]
#[doc = "\tresults obtained. Thus HIGH_ACCURACY scan flag aims to get maximum"]
#[doc = "\tpossible scan results. This flag hints the driver to use the best"]
#[doc = "\tpossible scan configuration to improve the accuracy in scanning."]
#[doc = "\tLatency and power use may get impacted with this flag."]
#[doc = " @NL80211_SCAN_FLAG_RANDOM_SN: randomize the sequence number in probe"]
#[doc = "\trequest frames from this scan to avoid correlation/tracking being"]
#[doc = "\tpossible."]
#[doc = " @NL80211_SCAN_FLAG_MIN_PREQ_CONTENT: minimize probe request content to"]
#[doc = "\tonly have supported rates and no additional capabilities (unless"]
#[doc = "\tadded by userspace explicitly.)"]
#[doc = " @NL80211_SCAN_FLAG_FREQ_KHZ: report scan results with"]
#[doc = "\t%NL80211_ATTR_SCAN_FREQ_KHZ. This also means"]
#[doc = "\t%NL80211_ATTR_SCAN_FREQUENCIES will not be included."]
#[doc = " @NL80211_SCAN_FLAG_COLOCATED_6GHZ: scan for colocated APs reported by"]
#[doc = "\t2.4/5 GHz APs"]
pub type nl80211_scan_flags = ::std::os::raw::c_uint;
pub const nl80211_acl_policy_NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED: nl80211_acl_policy = 0;
pub const nl80211_acl_policy_NL80211_ACL_POLICY_DENY_UNLESS_LISTED: nl80211_acl_policy = 1;
#[doc = " enum nl80211_acl_policy - access control policy"]
#[doc = ""]
#[doc = " Access control policy is applied on a MAC list set by"]
#[doc = " %NL80211_CMD_START_AP and %NL80211_CMD_SET_MAC_ACL, to"]
#[doc = " be used with %NL80211_ATTR_ACL_POLICY."]
#[doc = ""]
#[doc = " @NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED: Deny stations which are"]
#[doc = "\tlisted in ACL, i.e. allow all the stations which are not listed"]
#[doc = "\tin ACL to authenticate."]
#[doc = " @NL80211_ACL_POLICY_DENY_UNLESS_LISTED: Allow the stations which are listed"]
#[doc = "\tin ACL, i.e. deny all the stations which are not listed in ACL."]
pub type nl80211_acl_policy = ::std::os::raw::c_uint;
pub const nl80211_smps_mode_NL80211_SMPS_OFF: nl80211_smps_mode = 0;
pub const nl80211_smps_mode_NL80211_SMPS_STATIC: nl80211_smps_mode = 1;
pub const nl80211_smps_mode_NL80211_SMPS_DYNAMIC: nl80211_smps_mode = 2;
pub const nl80211_smps_mode___NL80211_SMPS_AFTER_LAST: nl80211_smps_mode = 3;
pub const nl80211_smps_mode_NL80211_SMPS_MAX: nl80211_smps_mode = 2;
#[doc = " enum nl80211_smps_mode - SMPS mode"]
#[doc = ""]
#[doc = " Requested SMPS mode (for AP mode)"]
#[doc = ""]
#[doc = " @NL80211_SMPS_OFF: SMPS off (use all antennas)."]
#[doc = " @NL80211_SMPS_STATIC: static SMPS (use a single antenna)"]
#[doc = " @NL80211_SMPS_DYNAMIC: dynamic smps (start with a single antenna and"]
#[doc = "\tturn on other antennas after CTS/RTS)."]
pub type nl80211_smps_mode = ::std::os::raw::c_uint;
pub const nl80211_radar_event_NL80211_RADAR_DETECTED: nl80211_radar_event = 0;
pub const nl80211_radar_event_NL80211_RADAR_CAC_FINISHED: nl80211_radar_event = 1;
pub const nl80211_radar_event_NL80211_RADAR_CAC_ABORTED: nl80211_radar_event = 2;
pub const nl80211_radar_event_NL80211_RADAR_NOP_FINISHED: nl80211_radar_event = 3;
pub const nl80211_radar_event_NL80211_RADAR_PRE_CAC_EXPIRED: nl80211_radar_event = 4;
pub const nl80211_radar_event_NL80211_RADAR_CAC_STARTED: nl80211_radar_event = 5;
#[doc = " enum nl80211_radar_event - type of radar event for DFS operation"]
#[doc = ""]
#[doc = " Type of event to be used with NL80211_ATTR_RADAR_EVENT to inform userspace"]
#[doc = " about detected radars or success of the channel available check (CAC)"]
#[doc = ""]
#[doc = " @NL80211_RADAR_DETECTED: A radar pattern has been detected. The channel is"]
#[doc = "\tnow unusable."]
#[doc = " @NL80211_RADAR_CAC_FINISHED: Channel Availability Check has been finished,"]
#[doc = "\tthe channel is now available."]
#[doc = " @NL80211_RADAR_CAC_ABORTED: Channel Availability Check has been aborted, no"]
#[doc = "\tchange to the channel status."]
#[doc = " @NL80211_RADAR_NOP_FINISHED: The Non-Occupancy Period for this channel is"]
#[doc = "\tover, channel becomes usable."]
#[doc = " @NL80211_RADAR_PRE_CAC_EXPIRED: Channel Availability Check done on this"]
#[doc = "\tnon-operating channel is expired and no longer valid. New CAC must"]
#[doc = "\tbe done on this channel before starting the operation. This is not"]
#[doc = "\tapplicable for ETSI dfs domain where pre-CAC is valid for ever."]
#[doc = " @NL80211_RADAR_CAC_STARTED: Channel Availability Check has been started,"]
#[doc = "\tshould be generated by HW if NL80211_EXT_FEATURE_DFS_OFFLOAD is enabled."]
pub type nl80211_radar_event = ::std::os::raw::c_uint;
pub const nl80211_dfs_state_NL80211_DFS_USABLE: nl80211_dfs_state = 0;
pub const nl80211_dfs_state_NL80211_DFS_UNAVAILABLE: nl80211_dfs_state = 1;
pub const nl80211_dfs_state_NL80211_DFS_AVAILABLE: nl80211_dfs_state = 2;
#[doc = " enum nl80211_dfs_state - DFS states for channels"]
#[doc = ""]
#[doc = " Channel states used by the DFS code."]
#[doc = ""]
#[doc = " @NL80211_DFS_USABLE: The channel can be used, but channel availability"]
#[doc = "\tcheck (CAC) must be performed before using it for AP or IBSS."]
#[doc = " @NL80211_DFS_UNAVAILABLE: A radar has been detected on this channel, it"]
#[doc = "\tis therefore marked as not available."]
#[doc = " @NL80211_DFS_AVAILABLE: The channel has been CAC checked and is available."]
pub type nl80211_dfs_state = ::std::os::raw::c_uint;
pub const nl80211_protocol_features_NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP:
    nl80211_protocol_features = 1;
#[doc = " enum nl80211_protocol_features - nl80211 protocol features"]
#[doc = " @NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP: nl80211 supports splitting"]
#[doc = "\twiphy dumps (if requested by the application with the attribute"]
#[doc = "\t%NL80211_ATTR_SPLIT_WIPHY_DUMP. Also supported is filtering the"]
#[doc = "\twiphy dump by %NL80211_ATTR_WIPHY, %NL80211_ATTR_IFINDEX or"]
#[doc = "\t%NL80211_ATTR_WDEV."]
pub type nl80211_protocol_features = ::std::os::raw::c_uint;
pub const nl80211_crit_proto_id_NL80211_CRIT_PROTO_UNSPEC: nl80211_crit_proto_id = 0;
pub const nl80211_crit_proto_id_NL80211_CRIT_PROTO_DHCP: nl80211_crit_proto_id = 1;
pub const nl80211_crit_proto_id_NL80211_CRIT_PROTO_EAPOL: nl80211_crit_proto_id = 2;
pub const nl80211_crit_proto_id_NL80211_CRIT_PROTO_APIPA: nl80211_crit_proto_id = 3;
pub const nl80211_crit_proto_id_NUM_NL80211_CRIT_PROTO: nl80211_crit_proto_id = 4;
#[doc = " enum nl80211_crit_proto_id - nl80211 critical protocol identifiers"]
#[doc = ""]
#[doc = " @NL80211_CRIT_PROTO_UNSPEC: protocol unspecified."]
#[doc = " @NL80211_CRIT_PROTO_DHCP: BOOTP or DHCPv6 protocol."]
#[doc = " @NL80211_CRIT_PROTO_EAPOL: EAPOL protocol."]
#[doc = " @NL80211_CRIT_PROTO_APIPA: APIPA protocol."]
#[doc = " @NUM_NL80211_CRIT_PROTO: must be kept last."]
pub type nl80211_crit_proto_id = ::std::os::raw::c_uint;
pub const nl80211_rxmgmt_flags_NL80211_RXMGMT_FLAG_ANSWERED: nl80211_rxmgmt_flags = 1;
pub const nl80211_rxmgmt_flags_NL80211_RXMGMT_FLAG_EXTERNAL_AUTH: nl80211_rxmgmt_flags = 2;
#[doc = " enum nl80211_rxmgmt_flags - flags for received management frame."]
#[doc = ""]
#[doc = " Used by cfg80211_rx_mgmt()"]
#[doc = ""]
#[doc = " @NL80211_RXMGMT_FLAG_ANSWERED: frame was answered by device/driver."]
#[doc = " @NL80211_RXMGMT_FLAG_EXTERNAL_AUTH: Host driver intends to offload"]
#[doc = "\tthe authentication. Exclusively defined for host drivers that"]
#[doc = "\tadvertises the SME functionality but would like the userspace"]
#[doc = "\tto handle certain authentication algorithms (e.g. SAE)."]
pub type nl80211_rxmgmt_flags = ::std::os::raw::c_uint;
#[doc = " struct nl80211_vendor_cmd_info - vendor command data"]
#[doc = " @vendor_id: If the %NL80211_VENDOR_ID_IS_LINUX flag is clear, then the"]
#[doc = "\tvalue is a 24-bit OUI; if it is set then a separately allocated ID"]
#[doc = "\tmay be used, but no such IDs are allocated yet. New IDs should be"]
#[doc = "\tadded to this file when needed."]
#[doc = " @subcmd: sub-command ID for the command"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_vendor_cmd_info {
    pub vendor_id: __u32,
    pub subcmd: __u32,
}
#[test]
fn bindgen_test_layout_nl80211_vendor_cmd_info() {
    assert_eq!(
        ::std::mem::size_of::<nl80211_vendor_cmd_info>(),
        8usize,
        concat!("Size of: ", stringify!(nl80211_vendor_cmd_info))
    );
    assert_eq!(
        ::std::mem::align_of::<nl80211_vendor_cmd_info>(),
        4usize,
        concat!("Alignment of ", stringify!(nl80211_vendor_cmd_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_vendor_cmd_info>())).vendor_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_vendor_cmd_info),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl80211_vendor_cmd_info>())).subcmd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_vendor_cmd_info),
            "::",
            stringify!(subcmd)
        )
    );
}
pub const nl80211_tdls_peer_capability_NL80211_TDLS_PEER_HT: nl80211_tdls_peer_capability = 1;
pub const nl80211_tdls_peer_capability_NL80211_TDLS_PEER_VHT: nl80211_tdls_peer_capability = 2;
pub const nl80211_tdls_peer_capability_NL80211_TDLS_PEER_WMM: nl80211_tdls_peer_capability = 4;
#[doc = " enum nl80211_tdls_peer_capability - TDLS peer flags."]
#[doc = ""]
#[doc = " Used by tdls_mgmt() to determine which conditional elements need"]
#[doc = " to be added to TDLS Setup frames."]
#[doc = ""]
#[doc = " @NL80211_TDLS_PEER_HT: TDLS peer is HT capable."]
#[doc = " @NL80211_TDLS_PEER_VHT: TDLS peer is VHT capable."]
#[doc = " @NL80211_TDLS_PEER_WMM: TDLS peer is WMM capable."]
pub type nl80211_tdls_peer_capability = ::std::os::raw::c_uint;
pub const nl80211_sched_scan_plan___NL80211_SCHED_SCAN_PLAN_INVALID: nl80211_sched_scan_plan = 0;
pub const nl80211_sched_scan_plan_NL80211_SCHED_SCAN_PLAN_INTERVAL: nl80211_sched_scan_plan = 1;
pub const nl80211_sched_scan_plan_NL80211_SCHED_SCAN_PLAN_ITERATIONS: nl80211_sched_scan_plan = 2;
pub const nl80211_sched_scan_plan___NL80211_SCHED_SCAN_PLAN_AFTER_LAST: nl80211_sched_scan_plan = 3;
pub const nl80211_sched_scan_plan_NL80211_SCHED_SCAN_PLAN_MAX: nl80211_sched_scan_plan = 2;
#[doc = " enum nl80211_sched_scan_plan - scanning plan for scheduled scan"]
#[doc = " @__NL80211_SCHED_SCAN_PLAN_INVALID: attribute number 0 is reserved"]
#[doc = " @NL80211_SCHED_SCAN_PLAN_INTERVAL: interval between scan iterations. In"]
#[doc = "\tseconds (u32)."]
#[doc = " @NL80211_SCHED_SCAN_PLAN_ITERATIONS: number of scan iterations in this"]
#[doc = "\tscan plan (u32). The last scan plan must not specify this attribute"]
#[doc = "\tbecause it will run infinitely. A value of zero is invalid as it will"]
#[doc = "\tmake the scan plan meaningless."]
#[doc = " @NL80211_SCHED_SCAN_PLAN_MAX: highest scheduled scan plan attribute number"]
#[doc = "\tcurrently defined"]
#[doc = " @__NL80211_SCHED_SCAN_PLAN_AFTER_LAST: internal use"]
pub type nl80211_sched_scan_plan = ::std::os::raw::c_uint;
#[doc = " struct nl80211_bss_select_rssi_adjust - RSSI adjustment parameters."]
#[doc = ""]
#[doc = " @band: band of BSS that must match for RSSI value adjustment. The value"]
#[doc = "\tof this field is according to &enum nl80211_band."]
#[doc = " @delta: value used to adjust the RSSI value of matching BSS in dB."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_bss_select_rssi_adjust {
    pub band: __u8,
    pub delta: __s8,
}
#[test]
fn bindgen_test_layout_nl80211_bss_select_rssi_adjust() {
    assert_eq!(
        ::std::mem::size_of::<nl80211_bss_select_rssi_adjust>(),
        2usize,
        concat!("Size of: ", stringify!(nl80211_bss_select_rssi_adjust))
    );
    assert_eq!(
        ::std::mem::align_of::<nl80211_bss_select_rssi_adjust>(),
        1usize,
        concat!("Alignment of ", stringify!(nl80211_bss_select_rssi_adjust))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_bss_select_rssi_adjust>())).band as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_bss_select_rssi_adjust),
            "::",
            stringify!(band)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nl80211_bss_select_rssi_adjust>())).delta as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nl80211_bss_select_rssi_adjust),
            "::",
            stringify!(delta)
        )
    );
}
pub const nl80211_bss_select_attr___NL80211_BSS_SELECT_ATTR_INVALID: nl80211_bss_select_attr = 0;
pub const nl80211_bss_select_attr_NL80211_BSS_SELECT_ATTR_RSSI: nl80211_bss_select_attr = 1;
pub const nl80211_bss_select_attr_NL80211_BSS_SELECT_ATTR_BAND_PREF: nl80211_bss_select_attr = 2;
pub const nl80211_bss_select_attr_NL80211_BSS_SELECT_ATTR_RSSI_ADJUST: nl80211_bss_select_attr = 3;
pub const nl80211_bss_select_attr___NL80211_BSS_SELECT_ATTR_AFTER_LAST: nl80211_bss_select_attr = 4;
pub const nl80211_bss_select_attr_NL80211_BSS_SELECT_ATTR_MAX: nl80211_bss_select_attr = 3;
#[doc = " enum nl80211_bss_select_attr - attributes for bss selection."]
#[doc = ""]
#[doc = " @__NL80211_BSS_SELECT_ATTR_INVALID: reserved."]
#[doc = " @NL80211_BSS_SELECT_ATTR_RSSI: Flag indicating only RSSI-based BSS selection"]
#[doc = "\tis requested."]
#[doc = " @NL80211_BSS_SELECT_ATTR_BAND_PREF: attribute indicating BSS"]
#[doc = "\tselection should be done such that the specified band is preferred."]
#[doc = "\tWhen there are multiple BSS-es in the preferred band, the driver"]
#[doc = "\tshall use RSSI-based BSS selection as a second step. The value of"]
#[doc = "\tthis attribute is according to &enum nl80211_band (u32)."]
#[doc = " @NL80211_BSS_SELECT_ATTR_RSSI_ADJUST: When present the RSSI level for"]
#[doc = "\tBSS-es in the specified band is to be adjusted before doing"]
#[doc = "\tRSSI-based BSS selection. The attribute value is a packed structure"]
#[doc = "\tvalue as specified by &struct nl80211_bss_select_rssi_adjust."]
#[doc = " @NL80211_BSS_SELECT_ATTR_MAX: highest bss select attribute number."]
#[doc = " @__NL80211_BSS_SELECT_ATTR_AFTER_LAST: internal use."]
#[doc = ""]
#[doc = " One and only one of these attributes are found within %NL80211_ATTR_BSS_SELECT"]
#[doc = " for %NL80211_CMD_CONNECT. It specifies the required BSS selection behaviour"]
#[doc = " which the driver shall use."]
pub type nl80211_bss_select_attr = ::std::os::raw::c_uint;
pub const nl80211_nan_function_type_NL80211_NAN_FUNC_PUBLISH: nl80211_nan_function_type = 0;
pub const nl80211_nan_function_type_NL80211_NAN_FUNC_SUBSCRIBE: nl80211_nan_function_type = 1;
pub const nl80211_nan_function_type_NL80211_NAN_FUNC_FOLLOW_UP: nl80211_nan_function_type = 2;
pub const nl80211_nan_function_type___NL80211_NAN_FUNC_TYPE_AFTER_LAST: nl80211_nan_function_type =
    3;
pub const nl80211_nan_function_type_NL80211_NAN_FUNC_MAX_TYPE: nl80211_nan_function_type = 2;
#[doc = " enum nl80211_nan_function_type - NAN function type"]
#[doc = ""]
#[doc = " Defines the function type of a NAN function"]
#[doc = ""]
#[doc = " @NL80211_NAN_FUNC_PUBLISH: function is publish"]
#[doc = " @NL80211_NAN_FUNC_SUBSCRIBE: function is subscribe"]
#[doc = " @NL80211_NAN_FUNC_FOLLOW_UP: function is follow-up"]
pub type nl80211_nan_function_type = ::std::os::raw::c_uint;
pub const nl80211_nan_publish_type_NL80211_NAN_SOLICITED_PUBLISH: nl80211_nan_publish_type = 1;
pub const nl80211_nan_publish_type_NL80211_NAN_UNSOLICITED_PUBLISH: nl80211_nan_publish_type = 2;
#[doc = " enum nl80211_nan_publish_type - NAN publish tx type"]
#[doc = ""]
#[doc = " Defines how to send publish Service Discovery Frames"]
#[doc = ""]
#[doc = " @NL80211_NAN_SOLICITED_PUBLISH: publish function is solicited"]
#[doc = " @NL80211_NAN_UNSOLICITED_PUBLISH: publish function is unsolicited"]
pub type nl80211_nan_publish_type = ::std::os::raw::c_uint;
pub const nl80211_nan_func_term_reason_NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST:
    nl80211_nan_func_term_reason = 0;
pub const nl80211_nan_func_term_reason_NL80211_NAN_FUNC_TERM_REASON_TTL_EXPIRED:
    nl80211_nan_func_term_reason = 1;
pub const nl80211_nan_func_term_reason_NL80211_NAN_FUNC_TERM_REASON_ERROR:
    nl80211_nan_func_term_reason = 2;
#[doc = " enum nl80211_nan_func_term_reason - NAN functions termination reason"]
#[doc = ""]
#[doc = " Defines termination reasons of a NAN function"]
#[doc = ""]
#[doc = " @NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST: requested by user"]
#[doc = " @NL80211_NAN_FUNC_TERM_REASON_TTL_EXPIRED: timeout"]
#[doc = " @NL80211_NAN_FUNC_TERM_REASON_ERROR: errored"]
pub type nl80211_nan_func_term_reason = ::std::os::raw::c_uint;
pub const nl80211_nan_func_attributes___NL80211_NAN_FUNC_INVALID: nl80211_nan_func_attributes = 0;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_TYPE: nl80211_nan_func_attributes = 1;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_SERVICE_ID: nl80211_nan_func_attributes = 2;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_PUBLISH_TYPE: nl80211_nan_func_attributes =
    3;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_PUBLISH_BCAST: nl80211_nan_func_attributes =
    4;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE:
    nl80211_nan_func_attributes = 5;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_FOLLOW_UP_ID: nl80211_nan_func_attributes =
    6;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID:
    nl80211_nan_func_attributes = 7;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_FOLLOW_UP_DEST: nl80211_nan_func_attributes =
    8;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_CLOSE_RANGE: nl80211_nan_func_attributes = 9;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_TTL: nl80211_nan_func_attributes = 10;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_SERVICE_INFO: nl80211_nan_func_attributes =
    11;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_SRF: nl80211_nan_func_attributes = 12;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_RX_MATCH_FILTER:
    nl80211_nan_func_attributes = 13;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_TX_MATCH_FILTER:
    nl80211_nan_func_attributes = 14;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_INSTANCE_ID: nl80211_nan_func_attributes =
    15;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_TERM_REASON: nl80211_nan_func_attributes =
    16;
pub const nl80211_nan_func_attributes_NUM_NL80211_NAN_FUNC_ATTR: nl80211_nan_func_attributes = 17;
pub const nl80211_nan_func_attributes_NL80211_NAN_FUNC_ATTR_MAX: nl80211_nan_func_attributes = 16;
#[doc = " enum nl80211_nan_func_attributes - NAN function attributes"]
#[doc = " @__NL80211_NAN_FUNC_INVALID: invalid"]
#[doc = " @NL80211_NAN_FUNC_TYPE: &enum nl80211_nan_function_type (u8)."]
#[doc = " @NL80211_NAN_FUNC_SERVICE_ID: 6 bytes of the service ID hash as"]
#[doc = "\tspecified in NAN spec. This is a binary attribute."]
#[doc = " @NL80211_NAN_FUNC_PUBLISH_TYPE: relevant if the function's type is"]
#[doc = "\tpublish. Defines the transmission type for the publish Service Discovery"]
#[doc = "\tFrame, see &enum nl80211_nan_publish_type. Its type is u8."]
#[doc = " @NL80211_NAN_FUNC_PUBLISH_BCAST: relevant if the function is a solicited"]
#[doc = "\tpublish. Should the solicited publish Service Discovery Frame be sent to"]
#[doc = "\tthe NAN Broadcast address. This is a flag."]
#[doc = " @NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE: relevant if the function's type is"]
#[doc = "\tsubscribe. Is the subscribe active. This is a flag."]
#[doc = " @NL80211_NAN_FUNC_FOLLOW_UP_ID: relevant if the function's type is follow up."]
#[doc = "\tThe instance ID for the follow up Service Discovery Frame. This is u8."]
#[doc = " @NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID: relevant if the function's type"]
#[doc = "\tis follow up. This is a u8."]
#[doc = "\tThe requestor instance ID for the follow up Service Discovery Frame."]
#[doc = " @NL80211_NAN_FUNC_FOLLOW_UP_DEST: the MAC address of the recipient of the"]
#[doc = "\tfollow up Service Discovery Frame. This is a binary attribute."]
#[doc = " @NL80211_NAN_FUNC_CLOSE_RANGE: is this function limited for devices in a"]
#[doc = "\tclose range. The range itself (RSSI) is defined by the device."]
#[doc = "\tThis is a flag."]
#[doc = " @NL80211_NAN_FUNC_TTL: strictly positive number of DWs this function should"]
#[doc = "\tstay active. If not present infinite TTL is assumed. This is a u32."]
#[doc = " @NL80211_NAN_FUNC_SERVICE_INFO: array of bytes describing the service"]
#[doc = "\tspecific info. This is a binary attribute."]
#[doc = " @NL80211_NAN_FUNC_SRF: Service Receive Filter. This is a nested attribute."]
#[doc = "\tSee &enum nl80211_nan_srf_attributes."]
#[doc = " @NL80211_NAN_FUNC_RX_MATCH_FILTER: Receive Matching filter. This is a nested"]
#[doc = "\tattribute. It is a list of binary values."]
#[doc = " @NL80211_NAN_FUNC_TX_MATCH_FILTER: Transmit Matching filter. This is a"]
#[doc = "\tnested attribute. It is a list of binary values."]
#[doc = " @NL80211_NAN_FUNC_INSTANCE_ID: The instance ID of the function."]
#[doc = "\tIts type is u8 and it cannot be 0."]
#[doc = " @NL80211_NAN_FUNC_TERM_REASON: NAN function termination reason."]
#[doc = "\tSee &enum nl80211_nan_func_term_reason."]
#[doc = ""]
#[doc = " @NUM_NL80211_NAN_FUNC_ATTR: internal"]
#[doc = " @NL80211_NAN_FUNC_ATTR_MAX: highest NAN function attribute"]
pub type nl80211_nan_func_attributes = ::std::os::raw::c_uint;
pub const nl80211_nan_srf_attributes___NL80211_NAN_SRF_INVALID: nl80211_nan_srf_attributes = 0;
pub const nl80211_nan_srf_attributes_NL80211_NAN_SRF_INCLUDE: nl80211_nan_srf_attributes = 1;
pub const nl80211_nan_srf_attributes_NL80211_NAN_SRF_BF: nl80211_nan_srf_attributes = 2;
pub const nl80211_nan_srf_attributes_NL80211_NAN_SRF_BF_IDX: nl80211_nan_srf_attributes = 3;
pub const nl80211_nan_srf_attributes_NL80211_NAN_SRF_MAC_ADDRS: nl80211_nan_srf_attributes = 4;
pub const nl80211_nan_srf_attributes_NUM_NL80211_NAN_SRF_ATTR: nl80211_nan_srf_attributes = 5;
pub const nl80211_nan_srf_attributes_NL80211_NAN_SRF_ATTR_MAX: nl80211_nan_srf_attributes = 4;
#[doc = " enum nl80211_nan_srf_attributes - NAN Service Response filter attributes"]
#[doc = " @__NL80211_NAN_SRF_INVALID: invalid"]
#[doc = " @NL80211_NAN_SRF_INCLUDE: present if the include bit of the SRF set."]
#[doc = "\tThis is a flag."]
#[doc = " @NL80211_NAN_SRF_BF: Bloom Filter. Present if and only if"]
#[doc = "\t%NL80211_NAN_SRF_MAC_ADDRS isn't present. This attribute is binary."]
#[doc = " @NL80211_NAN_SRF_BF_IDX: index of the Bloom Filter. Mandatory if"]
#[doc = "\t%NL80211_NAN_SRF_BF is present. This is a u8."]
#[doc = " @NL80211_NAN_SRF_MAC_ADDRS: list of MAC addresses for the SRF. Present if"]
#[doc = "\tand only if %NL80211_NAN_SRF_BF isn't present. This is a nested"]
#[doc = "\tattribute. Each nested attribute is a MAC address."]
#[doc = " @NUM_NL80211_NAN_SRF_ATTR: internal"]
#[doc = " @NL80211_NAN_SRF_ATTR_MAX: highest NAN SRF attribute"]
pub type nl80211_nan_srf_attributes = ::std::os::raw::c_uint;
pub const nl80211_nan_match_attributes___NL80211_NAN_MATCH_INVALID: nl80211_nan_match_attributes =
    0;
pub const nl80211_nan_match_attributes_NL80211_NAN_MATCH_FUNC_LOCAL: nl80211_nan_match_attributes =
    1;
pub const nl80211_nan_match_attributes_NL80211_NAN_MATCH_FUNC_PEER: nl80211_nan_match_attributes =
    2;
pub const nl80211_nan_match_attributes_NUM_NL80211_NAN_MATCH_ATTR: nl80211_nan_match_attributes = 3;
pub const nl80211_nan_match_attributes_NL80211_NAN_MATCH_ATTR_MAX: nl80211_nan_match_attributes = 2;
#[doc = " enum nl80211_nan_match_attributes - NAN match attributes"]
#[doc = " @__NL80211_NAN_MATCH_INVALID: invalid"]
#[doc = " @NL80211_NAN_MATCH_FUNC_LOCAL: the local function that had the"]
#[doc = "\tmatch. This is a nested attribute."]
#[doc = "\tSee &enum nl80211_nan_func_attributes."]
#[doc = " @NL80211_NAN_MATCH_FUNC_PEER: the peer function"]
#[doc = "\tthat caused the match. This is a nested attribute."]
#[doc = "\tSee &enum nl80211_nan_func_attributes."]
#[doc = ""]
#[doc = " @NUM_NL80211_NAN_MATCH_ATTR: internal"]
#[doc = " @NL80211_NAN_MATCH_ATTR_MAX: highest NAN match attribute"]
pub type nl80211_nan_match_attributes = ::std::os::raw::c_uint;
pub const nl80211_external_auth_action_NL80211_EXTERNAL_AUTH_START: nl80211_external_auth_action =
    0;
pub const nl80211_external_auth_action_NL80211_EXTERNAL_AUTH_ABORT: nl80211_external_auth_action =
    1;
#[doc = " nl80211_external_auth_action - Action to perform with external"]
#[doc = "     authentication request. Used by NL80211_ATTR_EXTERNAL_AUTH_ACTION."]
#[doc = " @NL80211_EXTERNAL_AUTH_START: Start the authentication."]
#[doc = " @NL80211_EXTERNAL_AUTH_ABORT: Abort the ongoing authentication."]
pub type nl80211_external_auth_action = ::std::os::raw::c_uint;
pub const nl80211_ftm_responder_attributes___NL80211_FTM_RESP_ATTR_INVALID:
    nl80211_ftm_responder_attributes = 0;
pub const nl80211_ftm_responder_attributes_NL80211_FTM_RESP_ATTR_ENABLED:
    nl80211_ftm_responder_attributes = 1;
pub const nl80211_ftm_responder_attributes_NL80211_FTM_RESP_ATTR_LCI:
    nl80211_ftm_responder_attributes = 2;
pub const nl80211_ftm_responder_attributes_NL80211_FTM_RESP_ATTR_CIVICLOC:
    nl80211_ftm_responder_attributes = 3;
pub const nl80211_ftm_responder_attributes___NL80211_FTM_RESP_ATTR_LAST:
    nl80211_ftm_responder_attributes = 4;
pub const nl80211_ftm_responder_attributes_NL80211_FTM_RESP_ATTR_MAX:
    nl80211_ftm_responder_attributes = 3;
#[doc = " enum nl80211_ftm_responder_attributes - fine timing measurement"]
#[doc = "\tresponder attributes"]
#[doc = " @__NL80211_FTM_RESP_ATTR_INVALID: Invalid"]
#[doc = " @NL80211_FTM_RESP_ATTR_ENABLED: FTM responder is enabled"]
#[doc = " @NL80211_FTM_RESP_ATTR_LCI: The content of Measurement Report Element"]
#[doc = "\t(9.4.2.22 in 802.11-2016) with type 8 - LCI (9.4.2.22.10),"]
#[doc = "\ti.e. starting with the measurement token"]
#[doc = " @NL80211_FTM_RESP_ATTR_CIVIC: The content of Measurement Report Element"]
#[doc = "\t(9.4.2.22 in 802.11-2016) with type 11 - Civic (Section 9.4.2.22.13),"]
#[doc = "\ti.e. starting with the measurement token"]
#[doc = " @__NL80211_FTM_RESP_ATTR_LAST: Internal"]
#[doc = " @NL80211_FTM_RESP_ATTR_MAX: highest FTM responder attribute."]
pub type nl80211_ftm_responder_attributes = ::std::os::raw::c_uint;
pub const nl80211_ftm_responder_stats___NL80211_FTM_STATS_INVALID: nl80211_ftm_responder_stats = 0;
pub const nl80211_ftm_responder_stats_NL80211_FTM_STATS_SUCCESS_NUM: nl80211_ftm_responder_stats =
    1;
pub const nl80211_ftm_responder_stats_NL80211_FTM_STATS_PARTIAL_NUM: nl80211_ftm_responder_stats =
    2;
pub const nl80211_ftm_responder_stats_NL80211_FTM_STATS_FAILED_NUM: nl80211_ftm_responder_stats = 3;
pub const nl80211_ftm_responder_stats_NL80211_FTM_STATS_ASAP_NUM: nl80211_ftm_responder_stats = 4;
pub const nl80211_ftm_responder_stats_NL80211_FTM_STATS_NON_ASAP_NUM: nl80211_ftm_responder_stats =
    5;
pub const nl80211_ftm_responder_stats_NL80211_FTM_STATS_TOTAL_DURATION_MSEC:
    nl80211_ftm_responder_stats = 6;
pub const nl80211_ftm_responder_stats_NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM:
    nl80211_ftm_responder_stats = 7;
pub const nl80211_ftm_responder_stats_NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM:
    nl80211_ftm_responder_stats = 8;
pub const nl80211_ftm_responder_stats_NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM:
    nl80211_ftm_responder_stats = 9;
pub const nl80211_ftm_responder_stats_NL80211_FTM_STATS_PAD: nl80211_ftm_responder_stats = 10;
pub const nl80211_ftm_responder_stats___NL80211_FTM_STATS_AFTER_LAST: nl80211_ftm_responder_stats =
    11;
pub const nl80211_ftm_responder_stats_NL80211_FTM_STATS_MAX: nl80211_ftm_responder_stats = 10;
pub type nl80211_ftm_responder_stats = ::std::os::raw::c_uint;
pub const nl80211_preamble_NL80211_PREAMBLE_LEGACY: nl80211_preamble = 0;
pub const nl80211_preamble_NL80211_PREAMBLE_HT: nl80211_preamble = 1;
pub const nl80211_preamble_NL80211_PREAMBLE_VHT: nl80211_preamble = 2;
pub const nl80211_preamble_NL80211_PREAMBLE_DMG: nl80211_preamble = 3;
pub const nl80211_preamble_NL80211_PREAMBLE_HE: nl80211_preamble = 4;
#[doc = " enum nl80211_preamble - frame preamble types"]
#[doc = " @NL80211_PREAMBLE_LEGACY: legacy (HR/DSSS, OFDM, ERP PHY) preamble"]
#[doc = " @NL80211_PREAMBLE_HT: HT preamble"]
#[doc = " @NL80211_PREAMBLE_VHT: VHT preamble"]
#[doc = " @NL80211_PREAMBLE_DMG: DMG preamble"]
#[doc = " @NL80211_PREAMBLE_HE: HE preamble"]
pub type nl80211_preamble = ::std::os::raw::c_uint;
pub const nl80211_peer_measurement_type_NL80211_PMSR_TYPE_INVALID: nl80211_peer_measurement_type =
    0;
pub const nl80211_peer_measurement_type_NL80211_PMSR_TYPE_FTM: nl80211_peer_measurement_type = 1;
pub const nl80211_peer_measurement_type_NUM_NL80211_PMSR_TYPES: nl80211_peer_measurement_type = 2;
pub const nl80211_peer_measurement_type_NL80211_PMSR_TYPE_MAX: nl80211_peer_measurement_type = 1;
#[doc = " enum nl80211_peer_measurement_type - peer measurement types"]
#[doc = " @NL80211_PMSR_TYPE_INVALID: invalid/unused, needed as we use"]
#[doc = "\tthese numbers also for attributes"]
#[doc = ""]
#[doc = " @NL80211_PMSR_TYPE_FTM: flight time measurement"]
#[doc = ""]
#[doc = " @NUM_NL80211_PMSR_TYPES: internal"]
#[doc = " @NL80211_PMSR_TYPE_MAX: highest type number"]
pub type nl80211_peer_measurement_type = ::std::os::raw::c_uint;
pub const nl80211_peer_measurement_status_NL80211_PMSR_STATUS_SUCCESS:
    nl80211_peer_measurement_status = 0;
pub const nl80211_peer_measurement_status_NL80211_PMSR_STATUS_REFUSED:
    nl80211_peer_measurement_status = 1;
pub const nl80211_peer_measurement_status_NL80211_PMSR_STATUS_TIMEOUT:
    nl80211_peer_measurement_status = 2;
pub const nl80211_peer_measurement_status_NL80211_PMSR_STATUS_FAILURE:
    nl80211_peer_measurement_status = 3;
#[doc = " enum nl80211_peer_measurement_status - peer measurement status"]
#[doc = " @NL80211_PMSR_STATUS_SUCCESS: measurement completed successfully"]
#[doc = " @NL80211_PMSR_STATUS_REFUSED: measurement was locally refused"]
#[doc = " @NL80211_PMSR_STATUS_TIMEOUT: measurement timed out"]
#[doc = " @NL80211_PMSR_STATUS_FAILURE: measurement failed, a type-dependent"]
#[doc = "\treason may be available in the response data"]
pub type nl80211_peer_measurement_status = ::std::os::raw::c_uint;
pub const nl80211_peer_measurement_req___NL80211_PMSR_REQ_ATTR_INVALID:
    nl80211_peer_measurement_req = 0;
pub const nl80211_peer_measurement_req_NL80211_PMSR_REQ_ATTR_DATA: nl80211_peer_measurement_req = 1;
pub const nl80211_peer_measurement_req_NL80211_PMSR_REQ_ATTR_GET_AP_TSF:
    nl80211_peer_measurement_req = 2;
pub const nl80211_peer_measurement_req_NUM_NL80211_PMSR_REQ_ATTRS: nl80211_peer_measurement_req = 3;
pub const nl80211_peer_measurement_req_NL80211_PMSR_REQ_ATTR_MAX: nl80211_peer_measurement_req = 2;
#[doc = " enum nl80211_peer_measurement_req - peer measurement request attributes"]
#[doc = " @__NL80211_PMSR_REQ_ATTR_INVALID: invalid"]
#[doc = ""]
#[doc = " @NL80211_PMSR_REQ_ATTR_DATA: This is a nested attribute with measurement"]
#[doc = "\ttype-specific request data inside. The attributes used are from the"]
#[doc = "\tenums named nl80211_peer_measurement_<type>_req."]
#[doc = " @NL80211_PMSR_REQ_ATTR_GET_AP_TSF: include AP TSF timestamp, if supported"]
#[doc = "\t(flag attribute)"]
#[doc = ""]
#[doc = " @NUM_NL80211_PMSR_REQ_ATTRS: internal"]
#[doc = " @NL80211_PMSR_REQ_ATTR_MAX: highest attribute number"]
pub type nl80211_peer_measurement_req = ::std::os::raw::c_uint;
pub const nl80211_peer_measurement_resp___NL80211_PMSR_RESP_ATTR_INVALID:
    nl80211_peer_measurement_resp = 0;
pub const nl80211_peer_measurement_resp_NL80211_PMSR_RESP_ATTR_DATA: nl80211_peer_measurement_resp =
    1;
pub const nl80211_peer_measurement_resp_NL80211_PMSR_RESP_ATTR_STATUS:
    nl80211_peer_measurement_resp = 2;
pub const nl80211_peer_measurement_resp_NL80211_PMSR_RESP_ATTR_HOST_TIME:
    nl80211_peer_measurement_resp = 3;
pub const nl80211_peer_measurement_resp_NL80211_PMSR_RESP_ATTR_AP_TSF:
    nl80211_peer_measurement_resp = 4;
pub const nl80211_peer_measurement_resp_NL80211_PMSR_RESP_ATTR_FINAL:
    nl80211_peer_measurement_resp = 5;
pub const nl80211_peer_measurement_resp_NL80211_PMSR_RESP_ATTR_PAD: nl80211_peer_measurement_resp =
    6;
pub const nl80211_peer_measurement_resp_NUM_NL80211_PMSR_RESP_ATTRS: nl80211_peer_measurement_resp =
    7;
pub const nl80211_peer_measurement_resp_NL80211_PMSR_RESP_ATTR_MAX: nl80211_peer_measurement_resp =
    6;
#[doc = " enum nl80211_peer_measurement_resp - peer measurement response attributes"]
#[doc = " @__NL80211_PMSR_RESP_ATTR_INVALID: invalid"]
#[doc = ""]
#[doc = " @NL80211_PMSR_RESP_ATTR_DATA: This is a nested attribute with measurement"]
#[doc = "\ttype-specific results inside. The attributes used are from the enums"]
#[doc = "\tnamed nl80211_peer_measurement_<type>_resp."]
#[doc = " @NL80211_PMSR_RESP_ATTR_STATUS: u32 value with the measurement status"]
#[doc = "\t(using values from &enum nl80211_peer_measurement_status.)"]
#[doc = " @NL80211_PMSR_RESP_ATTR_HOST_TIME: host time (%CLOCK_BOOTTIME) when the"]
#[doc = "\tresult was measured; this value is not expected to be accurate to"]
#[doc = "\tmore than 20ms. (u64, nanoseconds)"]
#[doc = " @NL80211_PMSR_RESP_ATTR_AP_TSF: TSF of the AP that the interface"]
#[doc = "\tdoing the measurement is connected to when the result was measured."]
#[doc = "\tThis shall be accurately reported if supported and requested"]
#[doc = "\t(u64, usec)"]
#[doc = " @NL80211_PMSR_RESP_ATTR_FINAL: If results are sent to the host partially"]
#[doc = "\t(*e.g. with FTM per-burst data) this flag will be cleared on all but"]
#[doc = "\tthe last result; if all results are combined it's set on the single"]
#[doc = "\tresult."]
#[doc = " @NL80211_PMSR_RESP_ATTR_PAD: padding for 64-bit attributes, ignore"]
#[doc = ""]
#[doc = " @NUM_NL80211_PMSR_RESP_ATTRS: internal"]
#[doc = " @NL80211_PMSR_RESP_ATTR_MAX: highest attribute number"]
pub type nl80211_peer_measurement_resp = ::std::os::raw::c_uint;
pub const nl80211_peer_measurement_peer_attrs___NL80211_PMSR_PEER_ATTR_INVALID:
    nl80211_peer_measurement_peer_attrs = 0;
pub const nl80211_peer_measurement_peer_attrs_NL80211_PMSR_PEER_ATTR_ADDR:
    nl80211_peer_measurement_peer_attrs = 1;
pub const nl80211_peer_measurement_peer_attrs_NL80211_PMSR_PEER_ATTR_CHAN:
    nl80211_peer_measurement_peer_attrs = 2;
pub const nl80211_peer_measurement_peer_attrs_NL80211_PMSR_PEER_ATTR_REQ:
    nl80211_peer_measurement_peer_attrs = 3;
pub const nl80211_peer_measurement_peer_attrs_NL80211_PMSR_PEER_ATTR_RESP:
    nl80211_peer_measurement_peer_attrs = 4;
pub const nl80211_peer_measurement_peer_attrs_NUM_NL80211_PMSR_PEER_ATTRS:
    nl80211_peer_measurement_peer_attrs = 5;
pub const nl80211_peer_measurement_peer_attrs_NL80211_PMSR_PEER_ATTR_MAX:
    nl80211_peer_measurement_peer_attrs = 4;
#[doc = " enum nl80211_peer_measurement_peer_attrs - peer attributes for measurement"]
#[doc = " @__NL80211_PMSR_PEER_ATTR_INVALID: invalid"]
#[doc = ""]
#[doc = " @NL80211_PMSR_PEER_ATTR_ADDR: peer's MAC address"]
#[doc = " @NL80211_PMSR_PEER_ATTR_CHAN: channel definition, nested, using top-level"]
#[doc = "\tattributes like %NL80211_ATTR_WIPHY_FREQ etc."]
#[doc = " @NL80211_PMSR_PEER_ATTR_REQ: This is a nested attribute indexed by"]
#[doc = "\tmeasurement type, with attributes from the"]
#[doc = "\t&enum nl80211_peer_measurement_req inside."]
#[doc = " @NL80211_PMSR_PEER_ATTR_RESP: This is a nested attribute indexed by"]
#[doc = "\tmeasurement type, with attributes from the"]
#[doc = "\t&enum nl80211_peer_measurement_resp inside."]
#[doc = ""]
#[doc = " @NUM_NL80211_PMSR_PEER_ATTRS: internal"]
#[doc = " @NL80211_PMSR_PEER_ATTR_MAX: highest attribute number"]
pub type nl80211_peer_measurement_peer_attrs = ::std::os::raw::c_uint;
pub const nl80211_peer_measurement_attrs___NL80211_PMSR_ATTR_INVALID:
    nl80211_peer_measurement_attrs = 0;
pub const nl80211_peer_measurement_attrs_NL80211_PMSR_ATTR_MAX_PEERS:
    nl80211_peer_measurement_attrs = 1;
pub const nl80211_peer_measurement_attrs_NL80211_PMSR_ATTR_REPORT_AP_TSF:
    nl80211_peer_measurement_attrs = 2;
pub const nl80211_peer_measurement_attrs_NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR:
    nl80211_peer_measurement_attrs = 3;
pub const nl80211_peer_measurement_attrs_NL80211_PMSR_ATTR_TYPE_CAPA:
    nl80211_peer_measurement_attrs = 4;
pub const nl80211_peer_measurement_attrs_NL80211_PMSR_ATTR_PEERS: nl80211_peer_measurement_attrs =
    5;
pub const nl80211_peer_measurement_attrs_NUM_NL80211_PMSR_ATTR: nl80211_peer_measurement_attrs = 6;
pub const nl80211_peer_measurement_attrs_NL80211_PMSR_ATTR_MAX: nl80211_peer_measurement_attrs = 5;
#[doc = " enum nl80211_peer_measurement_attrs - peer measurement attributes"]
#[doc = " @__NL80211_PMSR_ATTR_INVALID: invalid"]
#[doc = ""]
#[doc = " @NL80211_PMSR_ATTR_MAX_PEERS: u32 attribute used for capability"]
#[doc = "\tadvertisement only, indicates the maximum number of peers"]
#[doc = "\tmeasurements can be done with in a single request"]
#[doc = " @NL80211_PMSR_ATTR_REPORT_AP_TSF: flag attribute in capability"]
#[doc = "\tindicating that the connected AP's TSF can be reported in"]
#[doc = "\tmeasurement results"]
#[doc = " @NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR: flag attribute in capability"]
#[doc = "\tindicating that MAC address randomization is supported."]
#[doc = " @NL80211_PMSR_ATTR_TYPE_CAPA: capabilities reported by the device,"]
#[doc = "\tthis contains a nesting indexed by measurement type, and"]
#[doc = "\ttype-specific capabilities inside, which are from the enums"]
#[doc = "\tnamed nl80211_peer_measurement_<type>_capa."]
#[doc = " @NL80211_PMSR_ATTR_PEERS: nested attribute, the nesting index is"]
#[doc = "\tmeaningless, just a list of peers to measure with, with the"]
#[doc = "\tsub-attributes taken from"]
#[doc = "\t&enum nl80211_peer_measurement_peer_attrs."]
#[doc = ""]
#[doc = " @NUM_NL80211_PMSR_ATTR: internal"]
#[doc = " @NL80211_PMSR_ATTR_MAX: highest attribute number"]
pub type nl80211_peer_measurement_attrs = ::std::os::raw::c_uint;
pub const nl80211_peer_measurement_ftm_capa___NL80211_PMSR_FTM_CAPA_ATTR_INVALID:
    nl80211_peer_measurement_ftm_capa = 0;
pub const nl80211_peer_measurement_ftm_capa_NL80211_PMSR_FTM_CAPA_ATTR_ASAP:
    nl80211_peer_measurement_ftm_capa = 1;
pub const nl80211_peer_measurement_ftm_capa_NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP:
    nl80211_peer_measurement_ftm_capa = 2;
pub const nl80211_peer_measurement_ftm_capa_NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI:
    nl80211_peer_measurement_ftm_capa = 3;
pub const nl80211_peer_measurement_ftm_capa_NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC:
    nl80211_peer_measurement_ftm_capa = 4;
pub const nl80211_peer_measurement_ftm_capa_NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES:
    nl80211_peer_measurement_ftm_capa = 5;
pub const nl80211_peer_measurement_ftm_capa_NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS:
    nl80211_peer_measurement_ftm_capa = 6;
pub const nl80211_peer_measurement_ftm_capa_NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT:
    nl80211_peer_measurement_ftm_capa = 7;
pub const nl80211_peer_measurement_ftm_capa_NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST:
    nl80211_peer_measurement_ftm_capa = 8;
pub const nl80211_peer_measurement_ftm_capa_NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED:
    nl80211_peer_measurement_ftm_capa = 9;
pub const nl80211_peer_measurement_ftm_capa_NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED:
    nl80211_peer_measurement_ftm_capa = 10;
pub const nl80211_peer_measurement_ftm_capa_NUM_NL80211_PMSR_FTM_CAPA_ATTR:
    nl80211_peer_measurement_ftm_capa = 11;
pub const nl80211_peer_measurement_ftm_capa_NL80211_PMSR_FTM_CAPA_ATTR_MAX:
    nl80211_peer_measurement_ftm_capa = 10;
#[doc = " enum nl80211_peer_measurement_ftm_capa - FTM capabilities"]
#[doc = " @__NL80211_PMSR_FTM_CAPA_ATTR_INVALID: invalid"]
#[doc = ""]
#[doc = " @NL80211_PMSR_FTM_CAPA_ATTR_ASAP: flag attribute indicating ASAP mode"]
#[doc = "\tis supported"]
#[doc = " @NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP: flag attribute indicating non-ASAP"]
#[doc = "\tmode is supported"]
#[doc = " @NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI: flag attribute indicating if LCI"]
#[doc = "\tdata can be requested during the measurement"]
#[doc = " @NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC: flag attribute indicating if civic"]
#[doc = "\tlocation data can be requested during the measurement"]
#[doc = " @NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES: u32 bitmap attribute of bits"]
#[doc = "\tfrom &enum nl80211_preamble."]
#[doc = " @NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS: bitmap of values from"]
#[doc = "\t&enum nl80211_chan_width indicating the supported channel"]
#[doc = "\tbandwidths for FTM. Note that a higher channel bandwidth may be"]
#[doc = "\tconfigured to allow for other measurements types with different"]
#[doc = "\tbandwidth requirement in the same measurement."]
#[doc = " @NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT: u32 attribute indicating"]
#[doc = "\tthe maximum bursts exponent that can be used (if not present anything"]
#[doc = "\tis valid)"]
#[doc = " @NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST: u32 attribute indicating"]
#[doc = "\tthe maximum FTMs per burst (if not present anything is valid)"]
#[doc = " @NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED: flag attribute indicating if"]
#[doc = "\ttrigger based ranging measurement is supported"]
#[doc = " @NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED: flag attribute indicating"]
#[doc = "\tif non trigger based ranging measurement is supported"]
#[doc = ""]
#[doc = " @NUM_NL80211_PMSR_FTM_CAPA_ATTR: internal"]
#[doc = " @NL80211_PMSR_FTM_CAPA_ATTR_MAX: highest attribute number"]
pub type nl80211_peer_measurement_ftm_capa = ::std::os::raw::c_uint;
pub const nl80211_peer_measurement_ftm_req___NL80211_PMSR_FTM_REQ_ATTR_INVALID:
    nl80211_peer_measurement_ftm_req = 0;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_ASAP:
    nl80211_peer_measurement_ftm_req = 1;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE:
    nl80211_peer_measurement_ftm_req = 2;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP:
    nl80211_peer_measurement_ftm_req = 3;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD:
    nl80211_peer_measurement_ftm_req = 4;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION:
    nl80211_peer_measurement_ftm_req = 5;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST:
    nl80211_peer_measurement_ftm_req = 6;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES:
    nl80211_peer_measurement_ftm_req = 7;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI:
    nl80211_peer_measurement_ftm_req = 8;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC:
    nl80211_peer_measurement_ftm_req = 9;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED:
    nl80211_peer_measurement_ftm_req = 10;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED:
    nl80211_peer_measurement_ftm_req = 11;
pub const nl80211_peer_measurement_ftm_req_NUM_NL80211_PMSR_FTM_REQ_ATTR:
    nl80211_peer_measurement_ftm_req = 12;
pub const nl80211_peer_measurement_ftm_req_NL80211_PMSR_FTM_REQ_ATTR_MAX:
    nl80211_peer_measurement_ftm_req = 11;
#[doc = " enum nl80211_peer_measurement_ftm_req - FTM request attributes"]
#[doc = " @__NL80211_PMSR_FTM_REQ_ATTR_INVALID: invalid"]
#[doc = ""]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_ASAP: ASAP mode requested (flag)"]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE: preamble type (see"]
#[doc = "\t&enum nl80211_preamble), optional for DMG (u32)"]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP: number of bursts exponent as in"]
#[doc = "\t802.11-2016 9.4.2.168 \"Fine Timing Measurement Parameters element\""]
#[doc = "\t(u8, 0-15, optional with default 15 i.e. \"no preference\")"]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD: interval between bursts in units"]
#[doc = "\tof 100ms (u16, optional with default 0)"]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION: burst duration, as in 802.11-2016"]
#[doc = "\tTable 9-257 \"Burst Duration field encoding\" (u8, 0-15, optional with"]
#[doc = "\tdefault 15 i.e. \"no preference\")"]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST: number of successful FTM frames"]
#[doc = "\trequested per burst"]
#[doc = "\t(u8, 0-31, optional with default 0 i.e. \"no preference\")"]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES: number of FTMR frame retries"]
#[doc = "\t(u8, default 3)"]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI: request LCI data (flag)"]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC: request civic location data"]
#[doc = "\t(flag)"]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED: request trigger based ranging"]
#[doc = "\tmeasurement (flag)."]
#[doc = "\tThis attribute and %NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED are"]
#[doc = "\tmutually exclusive."]
#[doc = "      if neither %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED nor"]
#[doc = "\t%NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED is set, EDCA based"]
#[doc = "\tranging will be used."]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED: request non trigger based"]
#[doc = "\tranging measurement (flag)"]
#[doc = "\tThis attribute and %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED are"]
#[doc = "\tmutually exclusive."]
#[doc = "      if neither %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED nor"]
#[doc = "\t%NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED is set, EDCA based"]
#[doc = "\tranging will be used."]
#[doc = ""]
#[doc = " @NUM_NL80211_PMSR_FTM_REQ_ATTR: internal"]
#[doc = " @NL80211_PMSR_FTM_REQ_ATTR_MAX: highest attribute number"]
pub type nl80211_peer_measurement_ftm_req = ::std::os::raw::c_uint;
pub const nl80211_peer_measurement_ftm_failure_reasons_NL80211_PMSR_FTM_FAILURE_UNSPECIFIED:
    nl80211_peer_measurement_ftm_failure_reasons = 0;
pub const nl80211_peer_measurement_ftm_failure_reasons_NL80211_PMSR_FTM_FAILURE_NO_RESPONSE:
    nl80211_peer_measurement_ftm_failure_reasons = 1;
pub const nl80211_peer_measurement_ftm_failure_reasons_NL80211_PMSR_FTM_FAILURE_REJECTED:
    nl80211_peer_measurement_ftm_failure_reasons = 2;
pub const nl80211_peer_measurement_ftm_failure_reasons_NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL:
    nl80211_peer_measurement_ftm_failure_reasons = 3;
pub const nl80211_peer_measurement_ftm_failure_reasons_NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE:
    nl80211_peer_measurement_ftm_failure_reasons = 4;
pub const nl80211_peer_measurement_ftm_failure_reasons_NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP : nl80211_peer_measurement_ftm_failure_reasons = 5 ;
pub const nl80211_peer_measurement_ftm_failure_reasons_NL80211_PMSR_FTM_FAILURE_PEER_BUSY:
    nl80211_peer_measurement_ftm_failure_reasons = 6;
pub const nl80211_peer_measurement_ftm_failure_reasons_NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS : nl80211_peer_measurement_ftm_failure_reasons = 7 ;
#[doc = " enum nl80211_peer_measurement_ftm_failure_reasons - FTM failure reasons"]
#[doc = " @NL80211_PMSR_FTM_FAILURE_UNSPECIFIED: unspecified failure, not used"]
#[doc = " @NL80211_PMSR_FTM_FAILURE_NO_RESPONSE: no response from the FTM responder"]
#[doc = " @NL80211_PMSR_FTM_FAILURE_REJECTED: FTM responder rejected measurement"]
#[doc = " @NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL: we already know the peer is"]
#[doc = "\ton a different channel, so can't measure (if we didn't know, we'd"]
#[doc = "\ttry and get no response)"]
#[doc = " @NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE: peer can't actually do FTM"]
#[doc = " @NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP: invalid T1/T4 timestamps"]
#[doc = "\treceived"]
#[doc = " @NL80211_PMSR_FTM_FAILURE_PEER_BUSY: peer reports busy, you may retry"]
#[doc = "\tlater (see %NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME)"]
#[doc = " @NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS: parameters were changed"]
#[doc = "\tby the peer and are no longer supported"]
pub type nl80211_peer_measurement_ftm_failure_reasons = ::std::os::raw::c_uint;
pub const nl80211_peer_measurement_ftm_resp___NL80211_PMSR_FTM_RESP_ATTR_INVALID:
    nl80211_peer_measurement_ftm_resp = 0;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON:
    nl80211_peer_measurement_ftm_resp = 1;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX:
    nl80211_peer_measurement_ftm_resp = 2;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS:
    nl80211_peer_measurement_ftm_resp = 3;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES:
    nl80211_peer_measurement_ftm_resp = 4;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME:
    nl80211_peer_measurement_ftm_resp = 5;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP:
    nl80211_peer_measurement_ftm_resp = 6;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION:
    nl80211_peer_measurement_ftm_resp = 7;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST:
    nl80211_peer_measurement_ftm_resp = 8;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG:
    nl80211_peer_measurement_ftm_resp = 9;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD:
    nl80211_peer_measurement_ftm_resp = 10;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_TX_RATE:
    nl80211_peer_measurement_ftm_resp = 11;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_RX_RATE:
    nl80211_peer_measurement_ftm_resp = 12;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG:
    nl80211_peer_measurement_ftm_resp = 13;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE:
    nl80211_peer_measurement_ftm_resp = 14;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD:
    nl80211_peer_measurement_ftm_resp = 15;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG:
    nl80211_peer_measurement_ftm_resp = 16;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE:
    nl80211_peer_measurement_ftm_resp = 17;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD:
    nl80211_peer_measurement_ftm_resp = 18;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_LCI:
    nl80211_peer_measurement_ftm_resp = 19;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC:
    nl80211_peer_measurement_ftm_resp = 20;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_PAD:
    nl80211_peer_measurement_ftm_resp = 21;
pub const nl80211_peer_measurement_ftm_resp_NUM_NL80211_PMSR_FTM_RESP_ATTR:
    nl80211_peer_measurement_ftm_resp = 22;
pub const nl80211_peer_measurement_ftm_resp_NL80211_PMSR_FTM_RESP_ATTR_MAX:
    nl80211_peer_measurement_ftm_resp = 21;
#[doc = " enum nl80211_peer_measurement_ftm_resp - FTM response attributes"]
#[doc = " @__NL80211_PMSR_FTM_RESP_ATTR_INVALID: invalid"]
#[doc = ""]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON: FTM-specific failure reason"]
#[doc = "\t(u32, optional)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX: optional, if bursts are reported"]
#[doc = "\tas separate results then it will be the burst index 0...(N-1) and"]
#[doc = "\tthe top level will indicate partial results (u32)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS: number of FTM Request frames"]
#[doc = "\ttransmitted (u32, optional)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES: number of FTM Request frames"]
#[doc = "\tthat were acknowleged (u32, optional)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME: retry time received from the"]
#[doc = "\tbusy peer (u32, seconds)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP: actual number of bursts exponent"]
#[doc = "\tused by the responder (similar to request, u8)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION: actual burst duration used by"]
#[doc = "\tthe responder (similar to request, u8)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST: actual FTMs per burst used"]
#[doc = "\tby the responder (similar to request, u8)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG: average RSSI across all FTM action"]
#[doc = "\tframes (optional, s32, 1/2 dBm)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD: RSSI spread across all FTM action"]
#[doc = "\tframes (optional, s32, 1/2 dBm)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_TX_RATE: bitrate we used for the response to the"]
#[doc = "\tFTM action frame (optional, nested, using &enum nl80211_rate_info"]
#[doc = "\tattributes)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_RX_RATE: bitrate the responder used for the FTM"]
#[doc = "\taction frame (optional, nested, using &enum nl80211_rate_info attrs)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG: average RTT (s64, picoseconds, optional"]
#[doc = "\tbut one of RTT/DIST must be present)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE: RTT variance (u64, ps^2, note that"]
#[doc = "\tstandard deviation is the square root of variance, optional)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD: RTT spread (u64, picoseconds,"]
#[doc = "\toptional)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG: average distance (s64, mm, optional"]
#[doc = "\tbut one of RTT/DIST must be present)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE: distance variance (u64, mm^2, note"]
#[doc = "\tthat standard deviation is the square root of variance, optional)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD: distance spread (u64, mm, optional)"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_LCI: LCI data from peer (binary, optional);"]
#[doc = "\tthis is the contents of the Measurement Report Element (802.11-2016"]
#[doc = "\t9.4.2.22.1) starting with the Measurement Token, with Measurement"]
#[doc = "\tType 8."]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC: civic location data from peer"]
#[doc = "\t(binary, optional);"]
#[doc = "\tthis is the contents of the Measurement Report Element (802.11-2016"]
#[doc = "\t9.4.2.22.1) starting with the Measurement Token, with Measurement"]
#[doc = "\tType 11."]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_PAD: ignore, for u64/s64 padding only"]
#[doc = ""]
#[doc = " @NUM_NL80211_PMSR_FTM_RESP_ATTR: internal"]
#[doc = " @NL80211_PMSR_FTM_RESP_ATTR_MAX: highest attribute number"]
pub type nl80211_peer_measurement_ftm_resp = ::std::os::raw::c_uint;
pub const nl80211_obss_pd_attributes___NL80211_HE_OBSS_PD_ATTR_INVALID: nl80211_obss_pd_attributes =
    0;
pub const nl80211_obss_pd_attributes_NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET:
    nl80211_obss_pd_attributes = 1;
pub const nl80211_obss_pd_attributes_NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET:
    nl80211_obss_pd_attributes = 2;
pub const nl80211_obss_pd_attributes_NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET:
    nl80211_obss_pd_attributes = 3;
pub const nl80211_obss_pd_attributes_NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP:
    nl80211_obss_pd_attributes = 4;
pub const nl80211_obss_pd_attributes_NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP:
    nl80211_obss_pd_attributes = 5;
pub const nl80211_obss_pd_attributes_NL80211_HE_OBSS_PD_ATTR_SR_CTRL: nl80211_obss_pd_attributes =
    6;
pub const nl80211_obss_pd_attributes___NL80211_HE_OBSS_PD_ATTR_LAST: nl80211_obss_pd_attributes = 7;
pub const nl80211_obss_pd_attributes_NL80211_HE_OBSS_PD_ATTR_MAX: nl80211_obss_pd_attributes = 6;
#[doc = " enum nl80211_obss_pd_attributes - OBSS packet detection attributes"]
#[doc = " @__NL80211_HE_OBSS_PD_ATTR_INVALID: Invalid"]
#[doc = ""]
#[doc = " @NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET: the OBSS PD minimum tx power offset."]
#[doc = " @NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET: the OBSS PD maximum tx power offset."]
#[doc = " @NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET: the non-SRG OBSS PD maximum"]
#[doc = "\ttx power offset."]
#[doc = " @NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP: bitmap that indicates the BSS color"]
#[doc = "\tvalues used by members of the SRG."]
#[doc = " @NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP: bitmap that indicates the partial"]
#[doc = "\tBSSID values used by members of the SRG."]
#[doc = " @NL80211_HE_OBSS_PD_ATTR_SR_CTRL: The SR Control field of SRP element."]
#[doc = ""]
#[doc = " @__NL80211_HE_OBSS_PD_ATTR_LAST: Internal"]
#[doc = " @NL80211_HE_OBSS_PD_ATTR_MAX: highest OBSS PD attribute."]
pub type nl80211_obss_pd_attributes = ::std::os::raw::c_uint;
pub const nl80211_bss_color_attributes___NL80211_HE_BSS_COLOR_ATTR_INVALID:
    nl80211_bss_color_attributes = 0;
pub const nl80211_bss_color_attributes_NL80211_HE_BSS_COLOR_ATTR_COLOR:
    nl80211_bss_color_attributes = 1;
pub const nl80211_bss_color_attributes_NL80211_HE_BSS_COLOR_ATTR_DISABLED:
    nl80211_bss_color_attributes = 2;
pub const nl80211_bss_color_attributes_NL80211_HE_BSS_COLOR_ATTR_PARTIAL:
    nl80211_bss_color_attributes = 3;
pub const nl80211_bss_color_attributes___NL80211_HE_BSS_COLOR_ATTR_LAST:
    nl80211_bss_color_attributes = 4;
pub const nl80211_bss_color_attributes_NL80211_HE_BSS_COLOR_ATTR_MAX: nl80211_bss_color_attributes =
    3;
#[doc = " enum nl80211_bss_color_attributes - BSS Color attributes"]
#[doc = " @__NL80211_HE_BSS_COLOR_ATTR_INVALID: Invalid"]
#[doc = ""]
#[doc = " @NL80211_HE_BSS_COLOR_ATTR_COLOR: the current BSS Color."]
#[doc = " @NL80211_HE_BSS_COLOR_ATTR_DISABLED: is BSS coloring disabled."]
#[doc = " @NL80211_HE_BSS_COLOR_ATTR_PARTIAL: the AID equation to be used.."]
#[doc = ""]
#[doc = " @__NL80211_HE_BSS_COLOR_ATTR_LAST: Internal"]
#[doc = " @NL80211_HE_BSS_COLOR_ATTR_MAX: highest BSS Color attribute."]
pub type nl80211_bss_color_attributes = ::std::os::raw::c_uint;
pub const nl80211_iftype_akm_attributes___NL80211_IFTYPE_AKM_ATTR_INVALID:
    nl80211_iftype_akm_attributes = 0;
pub const nl80211_iftype_akm_attributes_NL80211_IFTYPE_AKM_ATTR_IFTYPES:
    nl80211_iftype_akm_attributes = 1;
pub const nl80211_iftype_akm_attributes_NL80211_IFTYPE_AKM_ATTR_SUITES:
    nl80211_iftype_akm_attributes = 2;
pub const nl80211_iftype_akm_attributes___NL80211_IFTYPE_AKM_ATTR_LAST:
    nl80211_iftype_akm_attributes = 3;
pub const nl80211_iftype_akm_attributes_NL80211_IFTYPE_AKM_ATTR_MAX: nl80211_iftype_akm_attributes =
    2;
#[doc = " enum nl80211_iftype_akm_attributes - interface type AKM attributes"]
#[doc = " @__NL80211_IFTYPE_AKM_ATTR_INVALID: Invalid"]
#[doc = ""]
#[doc = " @NL80211_IFTYPE_AKM_ATTR_IFTYPES: nested attribute containing a flag"]
#[doc = "\tattribute for each interface type that supports AKM suites specified in"]
#[doc = "\t%NL80211_IFTYPE_AKM_ATTR_SUITES"]
#[doc = " @NL80211_IFTYPE_AKM_ATTR_SUITES: an array of u32. Used to indicate supported"]
#[doc = "\tAKM suites for the specified interface types."]
#[doc = ""]
#[doc = " @__NL80211_IFTYPE_AKM_ATTR_LAST: Internal"]
#[doc = " @NL80211_IFTYPE_AKM_ATTR_MAX: highest interface type AKM attribute."]
pub type nl80211_iftype_akm_attributes = ::std::os::raw::c_uint;
pub const nl80211_fils_discovery_attributes___NL80211_FILS_DISCOVERY_ATTR_INVALID:
    nl80211_fils_discovery_attributes = 0;
pub const nl80211_fils_discovery_attributes_NL80211_FILS_DISCOVERY_ATTR_INT_MIN:
    nl80211_fils_discovery_attributes = 1;
pub const nl80211_fils_discovery_attributes_NL80211_FILS_DISCOVERY_ATTR_INT_MAX:
    nl80211_fils_discovery_attributes = 2;
pub const nl80211_fils_discovery_attributes_NL80211_FILS_DISCOVERY_ATTR_TMPL:
    nl80211_fils_discovery_attributes = 3;
pub const nl80211_fils_discovery_attributes___NL80211_FILS_DISCOVERY_ATTR_LAST:
    nl80211_fils_discovery_attributes = 4;
pub const nl80211_fils_discovery_attributes_NL80211_FILS_DISCOVERY_ATTR_MAX:
    nl80211_fils_discovery_attributes = 3;
#[doc = " enum nl80211_fils_discovery_attributes - FILS discovery configuration"]
#[doc = " from IEEE Std 802.11ai-2016, Annex C.3 MIB detail."]
#[doc = ""]
#[doc = " @__NL80211_FILS_DISCOVERY_ATTR_INVALID: Invalid"]
#[doc = ""]
#[doc = " @NL80211_FILS_DISCOVERY_ATTR_INT_MIN: Minimum packet interval (u32, TU)."]
#[doc = "\tAllowed range: 0..10000 (TU = Time Unit)"]
#[doc = " @NL80211_FILS_DISCOVERY_ATTR_INT_MAX: Maximum packet interval (u32, TU)."]
#[doc = "\tAllowed range: 0..10000 (TU = Time Unit)"]
#[doc = " @NL80211_FILS_DISCOVERY_ATTR_TMPL: Template data for FILS discovery action"]
#[doc = "\tframe including the headers."]
#[doc = ""]
#[doc = " @__NL80211_FILS_DISCOVERY_ATTR_LAST: Internal"]
#[doc = " @NL80211_FILS_DISCOVERY_ATTR_MAX: highest attribute"]
pub type nl80211_fils_discovery_attributes = ::std::os::raw::c_uint;
pub const nl80211_unsol_bcast_probe_resp_attributes___NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INVALID : nl80211_unsol_bcast_probe_resp_attributes = 0 ;
pub const nl80211_unsol_bcast_probe_resp_attributes_NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT:
    nl80211_unsol_bcast_probe_resp_attributes = 1;
pub const nl80211_unsol_bcast_probe_resp_attributes_NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL:
    nl80211_unsol_bcast_probe_resp_attributes = 2;
pub const nl80211_unsol_bcast_probe_resp_attributes___NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_LAST:
    nl80211_unsol_bcast_probe_resp_attributes = 3;
pub const nl80211_unsol_bcast_probe_resp_attributes_NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX:
    nl80211_unsol_bcast_probe_resp_attributes = 2;
#[doc = " enum nl80211_unsol_bcast_probe_resp_attributes - Unsolicited broadcast probe"]
#[doc = "\tresponse configuration. Applicable only in 6GHz."]
#[doc = ""]
#[doc = " @__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INVALID: Invalid"]
#[doc = ""]
#[doc = " @NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT: Maximum packet interval (u32, TU)."]
#[doc = "\tAllowed range: 0..20 (TU = Time Unit). IEEE P802.11ax/D6.0"]
#[doc = "\t26.17.2.3.2 (AP behavior for fast passive scanning)."]
#[doc = " @NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL: Unsolicited broadcast probe response"]
#[doc = "\tframe template (binary)."]
#[doc = ""]
#[doc = " @__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_LAST: Internal"]
#[doc = " @NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX: highest attribute"]
pub type nl80211_unsol_bcast_probe_resp_attributes = ::std::os::raw::c_uint;
pub const nl80211_sae_pwe_mechanism_NL80211_SAE_PWE_UNSPECIFIED: nl80211_sae_pwe_mechanism = 0;
pub const nl80211_sae_pwe_mechanism_NL80211_SAE_PWE_HUNT_AND_PECK: nl80211_sae_pwe_mechanism = 1;
pub const nl80211_sae_pwe_mechanism_NL80211_SAE_PWE_HASH_TO_ELEMENT: nl80211_sae_pwe_mechanism = 2;
pub const nl80211_sae_pwe_mechanism_NL80211_SAE_PWE_BOTH: nl80211_sae_pwe_mechanism = 3;
#[doc = " enum nl80211_sae_pwe_mechanism - The mechanism(s) allowed for SAE PWE"]
#[doc = "\tderivation. Applicable only when WPA3-Personal SAE authentication is"]
#[doc = "\tused."]
#[doc = ""]
#[doc = " @NL80211_SAE_PWE_UNSPECIFIED: not specified, used internally to indicate that"]
#[doc = "\tattribute is not present from userspace."]
#[doc = " @NL80211_SAE_PWE_HUNT_AND_PECK: hunting-and-pecking loop only"]
#[doc = " @NL80211_SAE_PWE_HASH_TO_ELEMENT: hash-to-element only"]
#[doc = " @NL80211_SAE_PWE_BOTH: both hunting-and-pecking loop and hash-to-element"]
#[doc = "\tcan be used."]
pub type nl80211_sae_pwe_mechanism = ::std::os::raw::c_uint;
pub const nl80211_sar_type_NL80211_SAR_TYPE_POWER: nl80211_sar_type = 0;
pub const nl80211_sar_type_NUM_NL80211_SAR_TYPE: nl80211_sar_type = 1;
#[doc = " enum nl80211_sar_type - type of SAR specs"]
#[doc = ""]
#[doc = " @NL80211_SAR_TYPE_POWER: power limitation specified in 0.25dBm unit"]
#[doc = ""]
pub type nl80211_sar_type = ::std::os::raw::c_uint;
pub const nl80211_sar_attrs___NL80211_SAR_ATTR_INVALID: nl80211_sar_attrs = 0;
pub const nl80211_sar_attrs_NL80211_SAR_ATTR_TYPE: nl80211_sar_attrs = 1;
pub const nl80211_sar_attrs_NL80211_SAR_ATTR_SPECS: nl80211_sar_attrs = 2;
pub const nl80211_sar_attrs___NL80211_SAR_ATTR_LAST: nl80211_sar_attrs = 3;
pub const nl80211_sar_attrs_NL80211_SAR_ATTR_MAX: nl80211_sar_attrs = 2;
#[doc = " enum nl80211_sar_attrs - Attributes for SAR spec"]
#[doc = ""]
#[doc = " @NL80211_SAR_ATTR_TYPE: the SAR type as defined in &enum nl80211_sar_type."]
#[doc = ""]
#[doc = " @NL80211_SAR_ATTR_SPECS: Nested array of SAR power"]
#[doc = "\tlimit specifications. Each specification contains a set"]
#[doc = "\tof %nl80211_sar_specs_attrs."]
#[doc = ""]
#[doc = "\tFor SET operation, it contains array of %NL80211_SAR_ATTR_SPECS_POWER"]
#[doc = "\tand %NL80211_SAR_ATTR_SPECS_RANGE_INDEX."]
#[doc = ""]
#[doc = "\tFor sar_capa dump, it contains array of"]
#[doc = "\t%NL80211_SAR_ATTR_SPECS_START_FREQ"]
#[doc = "\tand %NL80211_SAR_ATTR_SPECS_END_FREQ."]
#[doc = ""]
#[doc = " @__NL80211_SAR_ATTR_LAST: Internal"]
#[doc = " @NL80211_SAR_ATTR_MAX: highest sar attribute"]
#[doc = ""]
#[doc = " These attributes are used with %NL80211_CMD_SET_SAR_SPEC"]
pub type nl80211_sar_attrs = ::std::os::raw::c_uint;
pub const nl80211_sar_specs_attrs___NL80211_SAR_ATTR_SPECS_INVALID: nl80211_sar_specs_attrs = 0;
pub const nl80211_sar_specs_attrs_NL80211_SAR_ATTR_SPECS_POWER: nl80211_sar_specs_attrs = 1;
pub const nl80211_sar_specs_attrs_NL80211_SAR_ATTR_SPECS_RANGE_INDEX: nl80211_sar_specs_attrs = 2;
pub const nl80211_sar_specs_attrs_NL80211_SAR_ATTR_SPECS_START_FREQ: nl80211_sar_specs_attrs = 3;
pub const nl80211_sar_specs_attrs_NL80211_SAR_ATTR_SPECS_END_FREQ: nl80211_sar_specs_attrs = 4;
pub const nl80211_sar_specs_attrs___NL80211_SAR_ATTR_SPECS_LAST: nl80211_sar_specs_attrs = 5;
pub const nl80211_sar_specs_attrs_NL80211_SAR_ATTR_SPECS_MAX: nl80211_sar_specs_attrs = 4;
#[doc = " enum nl80211_sar_specs_attrs - Attributes for SAR power limit specs"]
#[doc = ""]
#[doc = " @NL80211_SAR_ATTR_SPECS_POWER: Required (s32)value to specify the actual"]
#[doc = "\tpower limit value in units of 0.25 dBm if type is"]
#[doc = "\tNL80211_SAR_TYPE_POWER. (i.e., a value of 44 represents 11 dBm)."]
#[doc = "\t0 means userspace doesn't have SAR limitation on this associated range."]
#[doc = ""]
#[doc = " @NL80211_SAR_ATTR_SPECS_RANGE_INDEX: Required (u32) value to specify the"]
#[doc = "\tindex of exported freq range table and the associated power limitation"]
#[doc = "\tis applied to this range."]
#[doc = ""]
#[doc = "\tUserspace isn't required to set all the ranges advertised by WLAN driver,"]
#[doc = "\tand userspace can skip some certain ranges. These skipped ranges don't"]
#[doc = "\thave SAR limitations, and they are same as setting the"]
#[doc = "\t%NL80211_SAR_ATTR_SPECS_POWER to any unreasonable high value because any"]
#[doc = "\tvalue higher than regulatory allowed value just means SAR power"]
#[doc = "\tlimitation is removed, but it's required to set at least one range."]
#[doc = "\tIt's not allowed to set duplicated range in one SET operation."]
#[doc = ""]
#[doc = "\tEvery SET operation overwrites previous SET operation."]
#[doc = ""]
#[doc = " @NL80211_SAR_ATTR_SPECS_START_FREQ: Required (u32) value to specify the start"]
#[doc = "\tfrequency of this range edge when registering SAR capability to wiphy."]
#[doc = "\tIt's not a channel center frequency. The unit is kHz."]
#[doc = ""]
#[doc = " @NL80211_SAR_ATTR_SPECS_END_FREQ: Required (u32) value to specify the end"]
#[doc = "\tfrequency of this range edge when registering SAR capability to wiphy."]
#[doc = "\tIt's not a channel center frequency. The unit is kHz."]
#[doc = ""]
#[doc = " @__NL80211_SAR_ATTR_SPECS_LAST: Internal"]
#[doc = " @NL80211_SAR_ATTR_SPECS_MAX: highest sar specs attribute"]
pub type nl80211_sar_specs_attrs = ::std::os::raw::c_uint;
